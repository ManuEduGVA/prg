{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Inicio","text":""},{"location":"#desarrollo-de-aplicaciones-multiplataforma-web-programacion","title":"Desarrollo de Aplicaciones Multiplataforma / Web  -- Programaci\u00f3n","text":""},{"location":"#2025-2026","title":"2025 - 2026","text":"<p>Imagen de Artur Shamsutdinov en Pixabay</p> <p>Profesores:</p> <ul> <li>Jos\u00e9 Manuel Romero Mart\u00ednez</li> <li>jm.romeromartinez@edu.gva.es</li> <li>Vicente Javier Esalava Mu\u00f1oz</li> <li>vj.eslavamunoz@edu.gva.es</li> </ul>"},{"location":"Unidad%201%20Introducci%C3%B3n%20a%20la%20Programaci%C3%B3n/1_Introducci%C3%B3n%20a%20la%20programacion/","title":"1 Introducci\u00f3n a la programacion","text":""},{"location":"Unidad%201%20Introducci%C3%B3n%20a%20la%20Programaci%C3%B3n/1_Introducci%C3%B3n%20a%20la%20programacion/#1-algoritmos-y-programas","title":"1. Algoritmos y Programas","text":"<p>Algoritmo: secuencia ordenada de pasos, descrita sin ambig\u00fcedades, que conducen a la soluci\u00f3n de un problema dado.</p> <p>Los algoritmos son independientes de los lenguajes de programaci\u00f3n y de las computadoras donde se ejecutan. Un mismo algoritmo puede ser expresado en diferentes lenguajes de programaci\u00f3n y podr\u00eda ser ejecutado en diferentes dispositivos. Piensa en una receta de cocina, \u00e9sta puede ser expresada en castellano, ingl\u00e9s o franc\u00e9s, podr\u00eda ser cocinada en fog\u00f3n o vitrocer\u00e1mica, por un cocinero o m\u00e1s, etc. Pero independientemente de todas estas circunstancias, el plato se preparar\u00e1 siguiendo los mismos pasos.</p> <p>La diferencia fundamental entre algoritmo y programa es que, en el segundo, los pasos que permiten resolver el problema, deben escribirse en un determinado lenguaje de programaci\u00f3n para que puedan ser ejecutados en el ordenador y as\u00ed obtener la soluci\u00f3n.</p> <p>Los lenguajes de programaci\u00f3n son s\u00f3lo un medio para expresar el algoritmo y el ordenador un procesador para ejecutarlo. Mediante el lenguaje creramos programas que ejecutan uno o m\u00e1s algoritmos en un sistema espec\u00edfico.</p> <p>En esencia, todo problema se puede describir por medio de un algoritmo y las caracter\u00edsticas fundamentales que \u00e9stos deben cumplir son:</p> <ul> <li>Debe ser preciso e indicar el orden de realizaci\u00f3n paso a paso.</li> <li>Debe estar definido, si se ejecuta dos o m\u00e1s veces, debe obtener el mismo resultado cada vez.</li> <li>Debe ser finito, debe tener un n\u00famero finito de pasos.</li> </ul>"},{"location":"Unidad%201%20Introducci%C3%B3n%20a%20la%20Programaci%C3%B3n/1_Introducci%C3%B3n%20a%20la%20programacion/#2-paradigmas-de-programacion","title":"2. Paradigmas de Programaci\u00f3n","text":"<p>Paradigma de programaci\u00f3n: es un modelo b\u00e1sico para el dise\u00f1o y la implementaci\u00f3n de programas. Este modelo determinar\u00e1 como ser\u00e1 el proceso de dise\u00f1o y la estructura final de un programa. Son las reglas del juego. Tienes una pelota o bal\u00f3n y una porter\u00eda, pero no es lo mismo jugar al f\u00fatbol que al balonmano. Pero en ambos tu objetivo es introducir el bal\u00f3n en la porter\u00eda y anotar m\u00e1s que tu rival. Igual pasa con los lenguajes, existen reglas y seg\u00fan las usemos podremos hacer unas cosas u otras. Tipos: Programaci\u00f3n Estructurada, Programaci\u00f3n Modular, Programaci\u00f3n Declarativa Programaci\u00f3n Orientada a Objetos, Programaci\u00f3n Reactiva, etc.</p>"},{"location":"Unidad%201%20Introducci%C3%B3n%20a%20la%20Programaci%C3%B3n/1_Introducci%C3%B3n%20a%20la%20programacion/#3-fases-de-programacion","title":"3. Fases de Programaci\u00f3n","text":"<p>El proceso de creaci\u00f3n de software puede dividirse en diferentes fases: - Fase de resoluci\u00f3n del problema: An\u00e1lisis y Dise\u00f1o. - Fase de implementaci\u00f3n: Codificaci\u00f3n y Pruebas. - Fase de explotaci\u00f3n y mantenimiento.</p>"},{"location":"Unidad%201%20Introducci%C3%B3n%20a%20la%20Programaci%C3%B3n/1_Introducci%C3%B3n%20a%20la%20programacion/#4-tipos-de-lenguajes","title":"4. Tipos de Lenguajes","text":""},{"location":"Unidad%201%20Introducci%C3%B3n%20a%20la%20Programaci%C3%B3n/1_Introducci%C3%B3n%20a%20la%20programacion/#41-cercania-al-programador","title":"4.1. Cercan\u00eda al programador","text":"<ul> <li>Alto nivel: C, C++, Java, Kotlin, Python, etc.</li> <li>Bajo nivel: ensamblador, m\u00e1quina, etc.</li> </ul>"},{"location":"Unidad%201%20Introducci%C3%B3n%20a%20la%20Programaci%C3%B3n/1_Introducci%C3%B3n%20a%20la%20programacion/#42-generaciones","title":"4.2. Generaciones","text":"<ul> <li>Primera generaci\u00f3n: lenguaje maquina. </li> <li>Segunda generaci\u00f3n: se crearon los primeros lenguajes ensambladores. </li> <li>Tercera generaci\u00f3n: se crean los primeros lenguajes de alto nivel. Ej. C, Pascal, Cobol\u2026 </li> <li>Cuarta generaci\u00f3n: son los lenguajes capaces de generar c\u00f3digo por si solos, son los llamados RAD, con lo cuales se pueden realizar aplicaciones sin ser un experto en el lenguaje.</li> <li>Quinta generaci\u00f3n: aqu\u00ed se encuentran los lenguajes orientados a la inteligencia artificial. Ej. LISP </li> </ul>"},{"location":"Unidad%201%20Introducci%C3%B3n%20a%20la%20Programaci%C3%B3n/1_Introducci%C3%B3n%20a%20la%20programacion/#5-traductores-compiladores-e-interpretes","title":"5. Traductores: Compiladores e Int\u00e9rpretes","text":"<p>La traducci\u00f3n de un programa escrito en un lenguaje de programaci\u00f3n a un lenguaje de m\u00e1quina se realiza mediante un traductor. Este traductor puede ser un compilador o un int\u00e9rprete. Sus fases principales, son: - An\u00e1lisis l\u00e9xico: se analiza el programa fuente y se separa en tokens. - An\u00e1lisis sint\u00e1ctico: se analiza la estructura del programa y se comprueba que la sintaxis sea correcta. - An\u00e1lisis sem\u00e1ntico: se comprueba que el programa tenga sentido y que no haya errores. - Optimizaci\u00f3n: se realiza una serie de optimizaciones para mejorar el rendimiento del programa. - Enlazador: se enlazan las librer\u00edas necesarias para que el programa funcione.</p>"},{"location":"Unidad%201%20Introducci%C3%B3n%20a%20la%20Programaci%C3%B3n/1_Introducci%C3%B3n%20a%20la%20programacion/#51-lenguaje-compilado","title":"5.1. Lenguaje compilado","text":"<p>Gracias al compiladores se convierte el c\u00f3digo a binarios que se ejecutan en el sistema operativo.</p>"},{"location":"Unidad%201%20Introducci%C3%B3n%20a%20la%20Programaci%C3%B3n/1_Introducci%C3%B3n%20a%20la%20programacion/#52-lenguaje-interpretado","title":"5.2. Lenguaje interpretado","text":"<p>Los lenguaje interpretados, necesita de dicho int\u00e9rprete, que lea la instrucci\u00f3n que se necesita ejecutar, realice el proceso de traducci\u00f3n de la misma y la ejecute.</p>"},{"location":"Unidad%201%20Introducci%C3%B3n%20a%20la%20Programaci%C3%B3n/1_Introducci%C3%B3n%20a%20la%20programacion/#53-lenguaje-mixto-o-intermedio","title":"5.3. Lenguaje mixto o intermedio","text":"<p>Es un lenguaje que se compila a un c\u00f3digo objeto o intermedio y se interpreta en una m\u00e1quina virtual . Ej. Java o Kotlin.</p>"},{"location":"Unidad%201%20Introducci%C3%B3n%20a%20la%20Programaci%C3%B3n/1_Introducci%C3%B3n%20a%20la%20programacion/#6-paradigmas-de-programacion","title":"6. Paradigmas de Programaci\u00f3n","text":"<p>Los lenguajes de programaci\u00f3n tambi\u00e9n se pueden clasificar por paradigmas. Un paradigma de programaci\u00f3n es una forma de clasificar los lenguajes de programaci\u00f3n seg\u00fan las caracter\u00edsticas y estilos de programaci\u00f3n que promueven. Aqu\u00ed hay una descripci\u00f3n general de algunos de los paradigmas m\u00e1s comunes:</p> <p>Programaci\u00f3n Imperativa:</p> <p>En la programaci\u00f3n imperativa, los programas son una serie de comandos que la computadora ejecuta en orden. Los comandos cambian el estado del programa. Los lenguajes de programaci\u00f3n imperativa incluyen C, C++, Java y Python.</p> <p>Programaci\u00f3n Declarativa:</p> <p>En la programaci\u00f3n declarativa, los programas describen el resultado que se desea, no c\u00f3mo lograrlo. Los lenguajes de programaci\u00f3n declarativa incluyen SQL y HTML.</p> <p>Programaci\u00f3n Procedimental:</p> <p>La programaci\u00f3n procedimental es un subtipo de programaci\u00f3n imperativa. En la programaci\u00f3n procedimental, los programas son una serie de procedimientos o funciones que manipulan el estado del programa. Los lenguajes de programaci\u00f3n procedimental incluyen C, Pascal y BASIC.</p> <p>Programaci\u00f3n Orientada a Objetos (OOP):</p> <p>En la programaci\u00f3n orientada a objetos, los programas son una colecci\u00f3n de objetos que interact\u00faan entre s\u00ed. Los objetos son instancias de clases, que contienen datos y m\u00e9todos que operan en esos datos. Los lenguajes de programaci\u00f3n orientados a objetos incluyen Java, C++, Python y Ruby.</p> <p>Programaci\u00f3n Funcional:</p> <p>En la programaci\u00f3n funcional, los programas son una serie de funciones matem\u00e1ticas. Las funciones no tienen estado y no cambian ning\u00fan dato. Los lenguajes de programaci\u00f3n funcional incluyen Haskell, Erlang y Lisp.</p> <p>Programaci\u00f3n L\u00f3gica:</p> <p>En la programaci\u00f3n l\u00f3gica, los programas son una serie de afirmaciones en l\u00f3gica formal. La computadora deduce la respuesta a una pregunta utilizando estas afirmaciones. Los lenguajes de programaci\u00f3n l\u00f3gica incluyen Prolog y Datalog.</p> <p>Programaci\u00f3n de Eventos:</p> <p>En la programaci\u00f3n basada en eventos, el flujo del programa est\u00e1 determinado por eventos, como la entrada del usuario o los cambios en el estado del sistema. Este paradigma es com\u00fanmente utilizado en la programaci\u00f3n de interfaces gr\u00e1ficas de usuario y servidores. Los lenguajes que soportan la programaci\u00f3n basada en eventos incluyen JavaScript y Python.</p> <p>Estos son solo algunos de los paradigmas de programaci\u00f3n m\u00e1s comunes. Muchos lenguajes de programaci\u00f3n soportan m\u00faltiples paradigmas. Por ejemplo, Python admite tanto la programaci\u00f3n imperativa como la orientada a objetos. La elecci\u00f3n del paradigma depende del problema que se est\u00e9 tratando de resolver y de las preferencias del programador.</p>"},{"location":"Unidad%201%20Introducci%C3%B3n%20a%20la%20Programaci%C3%B3n/1_Introducci%C3%B3n%20a%20la%20programacion/#7-elementos-de-un-lenguaje-de-programacion","title":"7. Elementos de un Lenguaje de Programaci\u00f3n","text":"<p>Un lenguaje de programaci\u00f3n es un lenguaje formal que proporciona un conjunto de instrucciones que permiten a un programador escribir secuencias de comandos, que son interpretadas por una m\u00e1quina, para producir un comportamiento deseado. Estos lenguajes son utilizados para controlar el comportamiento de las m\u00e1quinas o para expresar algoritmos.</p> <p>Los lenguajes de programaci\u00f3n constan de varios elementos clave, que incluyen:</p> <p>1. Sintaxis:</p> <p>La sintaxis de un lenguaje de programaci\u00f3n se refiere a las reglas que rigen la estructura de las declaraciones y expresiones v\u00e1lidas en ese lenguaje. Por ejemplo, en el lenguaje de programaci\u00f3n Python, la indentaci\u00f3n es parte de la sintaxis y se utiliza para delimitar bloques de c\u00f3digo.</p> <p>2. Sem\u00e1ntica:</p> <p>La sem\u00e1ntica de un lenguaje de programaci\u00f3n se refiere al significado de las declaraciones y expresiones. Por ejemplo, en la mayor\u00eda de los lenguajes de programaci\u00f3n, la expresi\u00f3n \"a = b + c\" significa que el valor de \"b + c\" debe ser calculado y luego asignado a la variable \"a\".</p> <p>3. Tipos de Datos:</p> <p>Los tipos de datos son los diferentes tipos de valores que pueden ser representados y manipulados en un lenguaje de programaci\u00f3n. Los tipos de datos comunes incluyen n\u00fameros enteros, n\u00fameros de punto flotante, caracteres, cadenas y booleanos. Los tipos de datos es algo crucial para clasificar la informaci\u00f3n y reflejan:   - Conjunto de valores v\u00e1lidos admitidos: enteros, decimales, caracteres, cadenas y booleanos.   - Conjunto de operaciones v\u00e1lidas para ese conjunto de valores: adici\u00f3n, multiplicaci\u00f3n, comparaci\u00f3n de igualdad, etc. (por ejemplo es lo mismo la divisi\u00f3n entera que la divisi\u00f3n real, es decir, 3/2) </p> <p>4. Variables:</p> <p>Las variables son s\u00edmbolos que representan valores en el programa. Las variables tienen tipos, y un valor de un tipo particular puede ser asignado a una variable.</p> <p>5. Operadores:</p> <p>Los operadores son s\u00edmbolos que representan operaciones espec\u00edficas. Por ejemplo, \"+\" es un operador que representa la adici\u00f3n, y \"==\" es un operador que representa la comparaci\u00f3n de igualdad.</p> <p>6. Control de Flujo:</p> <p>Las estructuras de control de flujo determinan el orden en el que se ejecutan las instrucciones en un programa. Las estructuras de control de flujo comunes incluyen condicionales (como \"if\" y \"switch\" en C++) y bucles (como \"for\" y \"while\").</p> <p>7. Subrutinas y Funciones:</p> <p>Las subrutinas y funciones son bloques de c\u00f3digo que pueden ser definidos y llamados por nombre. Permiten la reutilizaci\u00f3n de c\u00f3digo y ayudan a hacer los programas m\u00e1s modulares y m\u00e1s f\u00e1ciles de entender y mantener.</p> <p>8. Comentarios:</p> <p>Los comentarios son notas que los programadores dejan en el c\u00f3digo para explicar lo que hace el c\u00f3digo o por qu\u00e9 se tom\u00f3 una decisi\u00f3n particular de programaci\u00f3n. Los comentarios no son ejecutados como parte del programa.</p> <p>Estos son solo algunos de los elementos b\u00e1sicos de un lenguaje de programaci\u00f3n. Los lenguajes de programaci\u00f3n pueden variar ampliamente en t\u00e9rminos de qu\u00e9 elementos soportan y c\u00f3mo se implementan estos elementos.</p>"},{"location":"Unidad%201%20Introducci%C3%B3n%20a%20la%20Programaci%C3%B3n/1_Introducci%C3%B3n%20a%20la%20programacion/#8-referencias","title":"8. Referencias","text":"<ul> <li>http://www.larevistainformatica.com/clasificacion-de-los-lenguajes-de-programacion.html</li> <li>https://programas.cuaed.unam.mx/repositorio/moodle/pluginfile.php/1023/mod_resource/content/1/contenido/index.html#:~:text=Un%20lenguaje%20de%20bajo%20nivel,programas%20de%20una%20manera%20sencilla.</li> <li>https://profile.es/blog/que-son-los-paradigmas-de-programacion/#:~:text=Un%20paradigma%20de%20programaci%C3%B3n%20es,resultados%20que%20necesitan%20los%20programadores.</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/","title":"Programaci\u00f3n - 02 Programaci\u00f3n Estructurada y Modular","text":"<p>UD2 Programaci\u00f3n Estructurada y Modular. 1DAM/DAW. Curso 2025/2026.</p>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#1-tipos-y-operaciones","title":"1. Tipos y Operaciones","text":"<p>Los tipos de datos nos sirven para clasificar nuestra informaci\u00f3n de entrada y salida y trabajar con ellos. Un tipo lo define en base al valor que puede almacenar y las operaciones que se pueden realizar con \u00e9l.</p> <ul> <li> <p>Tipos simples: Se llama tipo de dato a una clase concreta de objetos o valores: N\u00fameros, Caracter, L\u00f3gicos, etc.</p> </li> <li> <p>Tipos compuestos: arrays, listas, etc, que los veremos m\u00e1s adelante.</p> </li> </ul> kotlinJavaPython <pre><code>// Tipos de datos\n// Tipos simples\n// N\u00fameros\nvar numero: Int = 1\nvar numero: Double = 1.0\nvar numero: Float = 1.0f\nvar numero: Long = 1L\nvar numero: Short = 1\nvar numero: Byte = 1\n// Caracteres\nvar caracter: Char = 'a'\n// L\u00f3gicos\nvar logico: Boolean = true\n// Cadenas\nvar cadena: String = \"Hola\"\n// Tipos compuestos\n// Arrays\nvar array: Array&lt;Int&gt; = arrayOf(1, 2, 3)\nvar array: IntArray = intArrayOf(1, 2, 3)\nvar array: Array&lt;String&gt; = arrayOf(\"Hola\", \"Adi\u00f3s\")\nvar array: Array&lt;Boolean&gt; = arrayOf(true, false)\n// Matrices\nvar matriz: Array&lt;Array&lt;Int&gt;&gt; = arrayOf(arrayOf(1, 2, 3), arrayOf(4, 5, 6))\nvar matriz: Array&lt;IntArray&gt; = arrayOf(intArrayOf(1, 2, 3), intArrayOf(4, 5, 6))\n</code></pre> <pre><code>// Tipos de datos\n// Tipos simples\n// N\u00fameros\nint entero = 1;             // Entero (32 bits)\ndouble doble = 1.0;          // Punto flotante doble precisi\u00f3n (64 bits)\nfloat flotante = 1.0f;       // Punto flotante simple precisi\u00f3n (32 bits)\nlong largo = 1L;             // Entero largo (64 bits)\nshort corto = 1;             // Entero corto (16 bits)\nbyte byteValor = 1;          // Byte (8 bits)\n// Caracteres\nchar caracter = 'a';         // Car\u00e1cter Unicode (16 bits)\n// L\u00f3gicos\nboolean logico = true;       // Valor booleano (true/false)\n// Cadenas\nString cadena = \"Hola\";      // Cadena de caracteres (objeto inmutable)\n// Tipos compuestos\n// Arrays\nInteger[] arrayInteger = {1, 2, 3};          // Array de objetos Integer\nint[] arrayInt = {1, 2, 3};                  // Array de primitivos int\nString[] arrayString = {\"Hola\", \"Adi\u00f3s\"};    // Array de String\nboolean[] arrayBoolean = {true, false};      // Array de boolean\n// Matrices\nint[][] matriz = {{1, 2, 3}, {4, 5, 6}};     // Matriz de int\nInteger[][] matrizObjetos = {{1, 2, 3}, {4, 5, 6}}; // Matriz de Integer\n</code></pre> <pre><code># Tipos de datos en Python\nentero = 1                  # Equivalente a Int (enteros de precisi\u00f3n arbitraria)\nflotante = 1.0              # Equivalente a Double (float en Python)\nflotante_precision = 1.0    # Python solo tiene un tipo de flotante (64 bits)\nlargo = 1                   # En Python 3, todos los enteros son de largo alcance\n# No hay equivalente exacto a Short o Byte en Python b\u00e1sico\ncaracter = 'a'              # En Python, es un string de longitud 1\nlogico = True               # Bool (True o False)\ncadena = \"Hola\"             # String (cadena de caracteres)\n\nlista_enteros = [1, 2, 3]                   # Lista de enteros\nlista_strings = [\"Hola\", \"Adi\u00f3s\"]            # Lista de strings\nlista_booleanos = [True, False]              # Lista de booleanos\ntupla_enteros = (1, 2, 3)                   # Tupla de enteros\nmatriz = [[1, 2, 3], [4, 5, 6]]             # Matriz como lista de listas\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#11-lenguajes-tipados-y-no-tipados","title":"1.1. Lenguajes tipados y no tipados","text":"<ul> <li>Lenguajes tipados: Los lenguajes tipados son aquellos que requieren que el programador declare el tipo de dato que se va a utilizar en cada variable. En estos lenguajes, el compilador o int\u00e9rprete comprueba que el tipo de dato de cada variable coincida con el tipo de dato que se ha declarado. </li> <li>Lenguajes d\u00e9bilmente tipados y/o tipado din\u00e1mico: Los lenguajes debilmente tipados son aquellos que no requieren que el programador declare el tipo de dato que se va a utilizar en cada variable. El compilador o int\u00e9rprete deduce el tipo de dato de cada variable en tiempo de ejecuci\u00f3n.</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#12-operaciones","title":"1.2. Operaciones","text":"KotlinJavaPython <pre><code>// Aritm\u00e9ticos\nvar a = 5 + 3   // Suma: 8\na = 5 - 3       // Resta: 2\na = 5 * 3       // Multiplicaci\u00f3n: 15\na = 5 / 3       // Divisi\u00f3n entera: 1\nval b = 5.0 / 3 // Divisi\u00f3n flotante: 1.666...\nval c = 5 % 3   // M\u00f3dulo: 2\na++             // Incremento (postfijo)\n++a             // Incremento (prefijo)\na--             // Decremento (postfijo)\n--a             // Decremento (prefijo)\n\n// Relacionales\nval d = (5 == 3)  // Igualdad: false\nval e = (5 != 3)  // Desigualdad: true\nval f = (5 &gt; 3)   // Mayor que: true\nval g = (5 &lt; 3)   // Menor que: false\nval h = (5 &gt;= 3)  // Mayor o igual: true\nval i = (5 &lt;= 3)  // Menor o igual: false\n\n// L\u00f3gicos\nval j = true &amp;&amp; false  // AND: false\nval k = true || false  // OR: true\nval l = !true          // NOT: false\n\n// Asignaci\u00f3n\nvar m = 5       // Asignaci\u00f3n simple\nm += 3          // Suma y asignaci\u00f3n (m = m + 3)\nm -= 2          // Resta y asignaci\u00f3n\nm *= 2          // Multiplicaci\u00f3n y asignaci\u00f3n\nm /= 3          // Divisi\u00f3n y asignaci\u00f3n\nm %= 3          // M\u00f3dulo y asignaci\u00f3n\n</code></pre> <pre><code>// Aritm\u00e9ticos\nint a = 5 + 3;   // Suma: 8\na = 5 - 3;       // Resta: 2\na = 5 * 3;       // Multiplicaci\u00f3n: 15\na = 5 / 3;       // Divisi\u00f3n entera: 1\ndouble b = 5.0 / 3; // Divisi\u00f3n flotante: 1.666...\nint c = 5 % 3;   // M\u00f3dulo: 2\na++;             // Incremento (postfijo)\n++a;             // Incremento (prefijo)\na--;             // Decremento (postfijo)\n--a;             // Decremento (prefijo)\n\n// Relacionales\nboolean d = (5 == 3);  // Igualdad: false\nboolean e = (5 != 3);  // Desigualdad: true\nboolean f = (5 &gt; 3);   // Mayor que: true\nboolean g = (5 &lt; 3);   // Menor que: false\nboolean h = (5 &gt;= 3);  // Mayor o igual: true\nboolean i = (5 &lt;= 3);  // Menor o igual: false\n\n// L\u00f3gicos\nboolean j = true &amp;&amp; false;  // AND: false\nboolean k = true || false;  // OR: true\nboolean l = !true;          // NOT: false\n\n// Asignaci\u00f3n\nint m = 5;       // Asignaci\u00f3n simple\nm += 3;          // Suma y asignaci\u00f3n (m = m + 3)\nm -= 2;          // Resta y asignaci\u00f3n\nm *= 2;          // Multiplicaci\u00f3n y asignaci\u00f3n\nm /= 3;          // Divisi\u00f3n y asignaci\u00f3n\nm %= 3;          // M\u00f3dulo y asignaci\u00f3n\n</code></pre> <pre><code># Aritm\u00e9ticos\na = 5 + 3   # Suma: 8\na = 5 - 3   # Resta: 2\na = 5 * 3   # Multiplicaci\u00f3n: 15\na = 5 / 3   # Divisi\u00f3n flotante: 1.666...\na = 5 // 3  # Divisi\u00f3n entera: 1\na = 5 % 3   # M\u00f3dulo: 2\na = 5 ** 3  # Potencia: 125\n# Python no tiene ++ o --\na += 1      # Incremento alternativo\na -= 1      # Decremento alternativo\n\n# Relacionales\nd = (5 == 3)  # Igualdad: False\ne = (5 != 3)  # Desigualdad: True\nf = (5 &gt; 3)   # Mayor que: True\ng = (5 &lt; 3)   # Menor que: False\nh = (5 &gt;= 3)  # Mayor o igual: True\ni = (5 &lt;= 3)  # Menor o igual: False\n\n# L\u00f3gicos\nj = True and False  # AND: False\nk = True or False   # OR: True\nl = not True        # NOT: False\n\n# Asignaci\u00f3n\nm = 5       # Asignaci\u00f3n simple\nm += 3      # Suma y asignaci\u00f3n (m = m + 3)\nm -= 2      # Resta y asignaci\u00f3n\nm *= 2      # Multiplicaci\u00f3n y asignaci\u00f3n\nm /= 3      # Divisi\u00f3n y asignaci\u00f3n\nm %= 3      # M\u00f3dulo y asignaci\u00f3n\nm **= 2     # Potencia y asignaci\u00f3n\nm //= 2     # Divisi\u00f3n entera y asignaci\u00f3n\n</code></pre> Diferencias clave: <ul> <li> <p>Python usa and, or, not en lugar de &amp;&amp;, ||, !</p> </li> <li> <p>Python no tiene operadores de incremento/decremento (++, --)</p> </li> <li> <p>Python tiene operador de potencia (**) y divisi\u00f3n entera (//)</p> </li> <li> <p>Java/Kotlin requieren punto y coma y declaraciones de tipo expl\u00edcitas</p> </li> <li> <p>Kotlin usa === para igualdad referencial</p> </li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#13-precedencia-de-operadores-kotlin-vs-java-vs-python","title":"1.3. Precedencia de Operadores (Kotlin vs Java vs Python)","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#tabla-de-precedencia-completa","title":"Tabla de Precedencia Completa","text":"Nivel Categor\u00eda Kotlin/Java Python 1 Agrupaci\u00f3n <code>()</code> <code>()</code> 2 Acceso/Member <code>.</code>, <code>?.</code>, <code>[]</code>, <code>()</code> <code>.</code>, <code>[]</code>, <code>()</code> 3 Sufijo <code>++</code>, <code>--</code> (sufijo) N/A 4 Prefijo/Unario <code>-</code>, <code>+</code>, <code>!</code>, <code>++</code>, <code>--</code> (prefijo) <code>-</code>, <code>+</code>, <code>~</code>, <code>not</code> 5 Multiplicativo <code>*</code>, <code>/</code>, <code>%</code> <code>*</code>, <code>/</code>, <code>//</code>, <code>%</code>, <code>@</code> 6 Aditivo <code>+</code>, <code>-</code> <code>+</code>, <code>-</code> 7 Rangos <code>..</code>, <code>in</code>, <code>!in</code> N/A 8 Desplazamiento <code>shl</code>, <code>shr</code>, <code>ushr</code> <code>&lt;&lt;</code>, <code>&gt;&gt;</code> 9 AND bit a bit <code>and</code> (Kotlin), <code>&amp;</code> (Java) <code>&amp;</code> 10 XOR bit a bit <code>xor</code> (Kotlin), <code>^</code> (Java) <code>^</code> 11 OR bit a bit <code>or</code> (Kotlin), <code>\\|</code> (Java) <code>\\|</code> 12 Comparaci\u00f3n <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>==</code>, <code>!=</code>, <code>is</code>, <code>is not</code>, <code>in</code>, <code>not in</code> 13 Igualdad <code>==</code>, <code>!=</code>, <code>===</code>, <code>!==</code> <code>==</code>, <code>!=</code> 14 Conjunci\u00f3n l\u00f3gica <code>&amp;&amp;</code> <code>and</code> 15 Disyunci\u00f3n l\u00f3gica <code>\\|\\|</code> <code>or</code> 16 Elvis/Asignaci\u00f3n <code>?:</code>, <code>=</code>, <code>+=</code>, etc. <code>:=</code> (walrus), <code>=</code>, <code>+=</code>, etc."},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#diferencias-clave","title":"Diferencias Clave","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#1-operadores-bit-a-bit","title":"1. Operadores Bit a Bit","text":"<pre><code>// Kotlin usa palabras clave\nval a = 0b1010 and 0b1100  // 0b1000\nval b = 0b1010 or 0b1100   // 0b1110\n</code></pre> <pre><code>// Java usa s\u00edmbolos\nint a = 0b1010 &amp; 0b1100;  // 0b1000\nint b = 0b1010 | 0b1100;   // 0b1110\n</code></pre> <pre><code># Python usa s\u00edmbolos como Java\na = 0b1010 &amp; 0b1100  # 0b1000\nb = 0b1010 | 0b1100   # 0b1110\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#2-operadores-logicos","title":"2. Operadores L\u00f3gicos","text":"<pre><code>// Kotlin usa s\u00edmbolos\nif (a &gt; 5 &amp;&amp; b &lt; 10 || c == 0) { ... }\n</code></pre> <pre><code># Python usa palabras\nif a &gt; 5 and b &lt; 10 or c == 0: ...\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#3-operador-walrus-python-38","title":"3. Operador Walrus (Python 3.8+)","text":"<pre><code># Python tiene operador de asignaci\u00f3n en expresiones\nif (n := len(a)) &gt; 10:\n    print(f\"Lista larga con {n} elementos\")\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#ejemplos-practicos","title":"Ejemplos Pr\u00e1cticos","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#expresion-completa","title":"Expresi\u00f3n Completa","text":"KotlinJavaPython <pre><code>val result = 5 + 3 * 2 &lt; 15 &amp;&amp; (10 % 3 == 1 || 2 shl 3 &gt; 10)\n// Paso a paso:\n// 1. 3*2=6\n// 2. 5+6=11\n// 3. 10%3=1\n// 4. 2 shl 3=16\n// 5. 1==1 \u2192 true\n// 6. 16&gt;10 \u2192 true\n// 7. true||true \u2192 true\n// 8. 11&lt;15 \u2192 true\n// 9. true&amp;&amp;true \u2192 true\n</code></pre> <pre><code>boolean result = 5 + 3 * 2 &lt; 15 &amp;&amp; (10 % 3 == 1 || 2 &lt;&lt; 3 &gt; 10);\n// Mismo orden que Kotlin\n</code></pre> <pre><code>result = 5 + 3 * 2 &lt; 15 and (10 % 3 == 1 or 2 &lt;&lt; 3 &gt; 10)\n# Orden similar pero con palabras clave\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#reglas-mnemotecnicas","title":"Reglas Mnemot\u00e9cnicas","text":"<ol> <li>PEMDAS (Para matem\u00e1ticas b\u00e1sicas):</li> <li>Par\u00e9ntesis</li> <li>Exponentes (<code>**</code> en Python)</li> <li>Multiplicaci\u00f3n/Divisi\u00f3n</li> <li> <p>Adici\u00f3n/Sustracci\u00f3n</p> </li> <li> <p>Bit a Bit:</p> </li> <li>Kotlin: <code>and</code>/<code>or</code>/<code>xor</code> antes que comparaciones</li> <li> <p>Java/Python: <code>&amp;</code>/<code>|</code> antes que <code>==</code></p> </li> <li> <p>L\u00f3gicos:</p> </li> <li><code>not</code>/<code>!</code> antes que <code>and</code>/<code>&amp;&amp;</code></li> <li><code>and</code>/<code>&amp;&amp;</code> antes que <code>or</code>/<code>||</code></li> </ol>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#casos-peligrosos","title":"Casos Peligrosos","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#kotlinjava-vs-python","title":"Kotlin/Java vs Python","text":"<pre><code>// Kotlin/Java\nval a = true &amp;&amp; false || true  // true (&amp;&amp; tiene mayor precedencia)\n// Equivale a: (true &amp;&amp; false) || true\n</code></pre> <pre><code># Python\na = True and False or True  # True (and tiene mayor precedencia)\n# Equivale a: (True and False) or True\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#operador-walrus","title":"Operador Walrus","text":"<pre><code># Correcto\nif (x := 5 + 3) &gt; 7: ...\n\n# Peligroso (diferente significado)\nif x := 5 + 3 &gt; 7: ...  # x ser\u00e1 True/False, no 8\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#recomendaciones","title":"Recomendaciones","text":"<ol> <li>Usar par\u00e9ntesis cuando:</li> <li>Combines operadores l\u00f3gicos y aritm\u00e9ticos</li> <li>Tengas dudas sobre el orden</li> <li> <p>Mejore la legibilidad</p> </li> <li> <p>Consistencia:</p> </li> <li>En Kotlin/Java preferir <code>&amp;&amp;</code>/<code>||</code></li> <li> <p>En Python usar <code>and</code>/<code>or</code></p> </li> <li> <p>Espaciado:    <pre><code>// \u274c Confuso\nval x=a+b*c-d\n\n// \u2705 Claro\nval x = a + b * c - d\n</code></pre></p> </li> </ol>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#14-casting-y-conversion-de-tipos","title":"1.4. Casting y Conversi\u00f3n de Tipos","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#conceptos-clave","title":"Conceptos Clave","text":"<pre><code>graph TD\n    A[Conversi\u00f3n] --&gt; B[Impl\u00edcita]\n    A --&gt; C[Expl\u00edcita]\n    B --&gt; D[Autom\u00e1tica]\n    C --&gt; E[Manual]</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#tabla-comparativa","title":"Tabla Comparativa","text":"Operaci\u00f3n Kotlin Java Python Conversi\u00f3n impl\u00edcita Limitada (solo promoci\u00f3n) Autom\u00e1tica (primitivos) Din\u00e1mica Conversi\u00f3n expl\u00edcita <code>.toXxx()</code> <code>(tipo)</code> <code>tipo()</code> Comprobaci\u00f3n de tipo <code>is</code> <code>instanceof</code> <code>isinstance()</code> Casting seguro <code>as?</code> - - String a n\u00famero <code>.toInt()</code> <code>Integer.parseInt()</code> <code>int()</code> N\u00famero a String <code>toString()</code> <code>String.valueOf()</code> <code>str()</code>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#kotlin","title":"Kotlin","text":"Kotlin <pre><code>fun main() {\n    // Conversi\u00f3n expl\u00edcita (no hay impl\u00edcita entre tipos diferentes)\n    val doubleVal: Double = 3.14\n    val intVal: Int = doubleVal.toInt() // 3\n\n    // Casting entre tipos (seguro con as?)\n    val obj: Any = \"Hola\"\n    val str: String? = obj as? String // Safe cast\n\n    // Comprobaci\u00f3n de tipo\n    if (obj is String) {\n        println(obj.length) // Smart cast autom\u00e1tico\n    }\n\n    // String a n\u00famero\n    val num = \"123\".toInt()\n}\n</code></pre> <p>Caracter\u00edsticas: - No hay conversi\u00f3n impl\u00edcita que cause p\u00e9rdida de precisi\u00f3n - M\u00e9todos <code>toXxx()</code> para conversiones - Smart casting autom\u00e1tico despu\u00e9s de comprobaciones</p>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#java","title":"Java","text":"Java <pre><code>public class Main {\n    public static void main(String[] args) {\n        // Conversi\u00f3n impl\u00edcita (promoci\u00f3n)\n        int intVal = 5;\n        double doubleVal = intVal; // 5.0\n\n        // Conversi\u00f3n expl\u00edcita (casting)\n        doubleVal = 3.14;\n        intVal = (int) doubleVal; // 3\n\n        // Comprobaci\u00f3n de tipo\n        Object obj = \"Hola\";\n        if (obj instanceof String) {\n            String str = (String) obj;\n            System.out.println(str.length());\n        }\n\n        // String a n\u00famero\n        int num = Integer.parseInt(\"123\");\n    }\n}\n</code></pre> <p>Particularidades: - Casting cl\u00e1sico con <code>(tipo)</code> - <code>instanceof</code> para comprobaci\u00f3n - Autoboxing entre primitivos y wrappers</p>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#python","title":"Python","text":"Python <pre><code>if __name__ == \"__main__\":\n    # Conversi\u00f3n impl\u00edcita din\u00e1mica\n    result = 3 + 2.5  # 5.5 (int -&gt; float)\n\n    # Conversi\u00f3n expl\u00edcita\n    int_val = int(3.14)  # 3\n    float_val = float(\"3.14\")\n\n    # Comprobaci\u00f3n de tipo\n    obj = \"Hola\"\n    if isinstance(obj, str):\n        print(len(obj))\n\n    # Casting entre objetos\n    class Padre: pass\n    class Hijo(Padre): pass\n\n    hijo = Hijo()\n    padre = Padre()\n    cast_hijo = hijo  # No necesita casting expl\u00edcito\n}\n</code></pre> <p>Caracter\u00edsticas: - Duck typing (m\u00e1s importante que el tipo) - Conversiones con constructores (<code>int()</code>, <code>str()</code>, etc.) - No hay casting expl\u00edcito entre objetos</p>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#conversiones-comunes","title":"Conversiones Comunes","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#1-numero-a-string","title":"1. N\u00famero a String","text":"<pre><code>// Kotlin\nval str = 123.toString()\n</code></pre> <pre><code>// Java\nString str = Integer.toString(123);\n</code></pre> <pre><code># Python\nstr_val = str(123)\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#2-string-a-numero","title":"2. String a N\u00famero","text":"<pre><code>// Kotlin\nval num = \"123\".toIntOrNull() ?: 0\n</code></pre> <pre><code>// Java\nint num = Integer.parseInt(\"123\");\n</code></pre> <pre><code># Python\nnum = int(\"123\")  # ValueError si falla\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#3-casting-entre-tipos-de-objetos","title":"3. Casting entre Tipos de Objetos","text":"<pre><code>// Kotlin (safe cast)\nval obj: Any = \"Hola\"\nval str: String? = obj as? String\n</code></pre> <pre><code>// Java (con comprobaci\u00f3n)\nObject obj = \"Hola\";\nif (obj instanceof String) {\n    String str = (String) obj;\n}\n</code></pre> <pre><code># Python (no necesario normalmente)\nobj = \"Hola\"\nif isinstance(obj, str):\n    str_val = obj  # No necesita casting\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#buenas-practicas","title":"Buenas Pr\u00e1cticas","text":"<ol> <li>En Kotlin:</li> <li>Prefiere <code>as?</code> sobre <code>as</code> para evitar <code>ClassCastException</code></li> <li> <p>Usa <code>toXxxOrNull()</code> para conversiones seguras</p> </li> <li> <p>En Java:</p> </li> <li>Siempre verificar con <code>instanceof</code> antes de casting</li> <li> <p>Usar <code>Integer.parseInt()</code> con try-catch</p> </li> <li> <p>En Python:</p> </li> <li>Prefiere <code>isinstance()</code> sobre type()</li> <li>Maneja <code>ValueError</code> en conversiones</li> </ol>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#rendimiento","title":"Rendimiento","text":"Operaci\u00f3n Kotlin Java Python String a Int ~50ns ~30ns ~100ns Double a Int ~10ns ~5ns ~50ns Comprobaci\u00f3n tipo ~5ns ~7ns ~20ns"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#casos-especiales","title":"Casos Especiales","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#kotlin-smart-cast","title":"Kotlin Smart Cast","text":"<pre><code>when (val response = getData()) {\n    is String -&gt; println(response.length)  // Auto-casted a String\n    is Int -&gt; println(response + 1)       // Auto-casted a Int\n}\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#java-pattern-matching-jdk-16","title":"Java Pattern Matching (JDK 16+)","text":"<pre><code>Object obj = \"Hola\";\nif (obj instanceof String str) {\n    System.out.println(str.length());\n}\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#python-duck-typing","title":"Python Duck Typing","text":"<pre><code>def procesar(item):\n    if hasattr(item, '__len__'):\n        return len(item)\n    return 0\n\nprocesar(\"Hola\")  # 4\nprocesar([1,2,3]) # 3\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#errores-comunes","title":"Errores Comunes","text":"<ol> <li> <p>Kotlin/Java:    <pre><code>val num = \"abc\".toInt()  // NumberFormatException\n</code></pre></p> </li> <li> <p>Java:    <pre><code>double d = 3.14;\nint i = d;  // Error: requiere casting expl\u00edcito\n</code></pre></p> </li> <li> <p>Python:    <pre><code>val = int(\"12a\")  # ValueError\n</code></pre></p> </li> </ol>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#15-variables-y-constantes","title":"1.5. Variables y constantes","text":"<p>A la hora de almacenar datos en memoria, debemos analizar c\u00f3mo vamos a utilizarlos. Si vamos a modificarlos, debemos utilizar variables, si no, debemos utilizar constantes. - Constantes: Son valores que no cambian durante la ejecuci\u00f3n del programa. Se declaran con la palabra reservada const/val. Son inmutables. - Variables: Son valores que cambian durante la ejecuci\u00f3n del programa. Se declaran con la palabra reservada var. Son mutables.</p> <p>Se debe aplicar c\u00f3digo limpio y buenas pr\u00e1cticas de programaci\u00f3n. para nombrarlas.</p> <p>Dependiendo del tipo de lenguaje, si es tipado o no, tendremos posibilidad de definir variables o constantes.</p> KotlinJavaPython <pre><code>// Variables mutables (pueden cambiar)\nvar variableMutable: Int = 10\nvariableMutable = 20  // Correcto\n\n// Variables inmutables (NO pueden cambiar)\nval variableInmutable: Int = 30\n// variableInmutable = 40  // Error de compilaci\u00f3n\n\n// Constantes (en tiempo de compilaci\u00f3n)\nconst val CONSTANTE: Int = 50\n// Deben ser inicializadas con un valor conocido en compilaci\u00f3n\n</code></pre> <pre><code>// Variables mutables\nint variableMutable = 10;\nvariableMutable = 20;  // Correcto\n\n// 'Constantes' (en realidad variables inmutables)\nfinal int variableInmutable = 30;\n// variableInmutable = 40;  // Error de compilaci\u00f3n\n\n// Constantes reales (static final)\nstatic final int CONSTANTE = 50;\n// Convenci\u00f3n: nombres en MAY\u00daSCULAS\n</code></pre> <pre><code># Variables mutables (por defecto todas lo son)\nvariable_mutable = 10\nvariable_mutable = 20  # Correcto\n\n# 'Constantes' (convenci\u00f3n, no realmente inmutables)\nCONSTANTE = 30  # Por convenci\u00f3n se usa MAY\u00daSCULAS\nCONSTANTE = 40  # Funciona, pero no deber\u00eda hacerse\n\n# No hay verdadera inmutabilidad para variables simples\n# Para estructuras complejas, usar:\nfrom typing import Final\nCONSTANTE_REAL: Final[int] = 50  # Python 3.8+\n# Aunque t\u00e9cnicamente puede cambiarse, linters avisan\n</code></pre> Definiciones precisas <ul> <li> Kotlin:<ol> <li>var: Variable mutable (puede reasignarse)</li> <li>val: Variable inmutable (solo asignaci\u00f3n inicial)</li> <li>const val: Constante real (valor conocido en compilaci\u00f3n)</li> </ol> </li> <li> Java:<ol> <li>Variables normales: mutables por defecto</li> <li>final: Hace la variable inmutable (solo para primitivos y referencias)</li> <li>static final: Constante real (compartida por todas las instancias)</li> </ol> </li> <li> Python:<ol> <li>Todas las variables son mutables por defecto</li> <li>No tiene verdaderas constantes, solo convenciones (nombres en MAY\u00daSCULAS)</li> <li>Desde Python 3.8: <code>Final</code> (solo para linters, no impide modificaci\u00f3n)</li> </ol> </li> <li> Importante<ul> <li>En Java no existen verdaderas \"constantes\" como en Kotlin, solo variables inmutables (final). Las constantes se simulan con static final.</li> <li>En Python no hay inmutabilidad real para variables simples, solo convenciones y anotaciones para linters. La inmutabilidad solo existe para algunos tipos como tuplas.</li> </ul> </li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#16-conversiones-de-tipo-kotlin-vs-java-vs-python","title":"1.6. Conversiones de Tipo (Kotlin vs Java vs Python)","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#tabla-comparativa-rapida","title":"Tabla Comparativa R\u00e1pida","text":"Operaci\u00f3n Kotlin Java Python Casting expl\u00edcito <code>as</code>, <code>toXxx()</code> <code>(tipo)</code> <code>tipo()</code> Conversi\u00f3n impl\u00edcita M\u00ednima Primitivos Din\u00e1mica String a n\u00famero <code>toIntOrNull()</code> <code>Integer.parseInt()</code> <code>int()</code> N\u00famero a String <code>toString()</code> <code>String.valueOf()</code> <code>str()</code> Char a c\u00f3digo <code>code</code> Cast a <code>int</code> <code>ord()</code> C\u00f3digo a Char <code>toChar()</code> Cast a <code>char</code> <code>chr()</code> Divisi\u00f3n exacta <code>/</code> (con al menos un float) <code>(double)</code> o <code>* 1.0</code> <code>/</code> (siempre float)"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#1-conversiones-numericas","title":"1. Conversiones Num\u00e9ricas","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#casting-explicito","title":"Casting Expl\u00edcito","text":"KotlinJavaPython <pre><code>val bigNum = 65633\nval c: Char = bigNum.toChar()  // 'a' (truncamiento)\nval f = 97.53f\nval c2 = f.toChar()  // 'a' (sin decimales)\nval pi = 3.14159f\nval i = pi.toInt()  // 3 (truncamiento)\n</code></pre> <pre><code>int bigNum = 65633;\nchar c = (char) bigNum;  // 'a'\nfloat f = 97.53f;\nchar c2 = (char) f;  // 'a'\nfloat pi = 3.14159f;\nint i = (int) pi;  // 3\n</code></pre> <pre><code>big_num = 65633\nc = chr(big_num)  # '\u1f81' (no hay truncamiento autom\u00e1tico)\nf = 97.53\nc2 = chr(int(f))  # 'a' (requiere int expl\u00edcito)\npi = 3.14159\ni = int(pi)  # 3\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#division-de-enteros","title":"Divisi\u00f3n de Enteros","text":"KotlinJavaPython <pre><code>val wrong = 5 / 2      // 2 (divisi\u00f3n entera)\nval correct = 5 / 2.0  // 2.5 (al menos un double)\n</code></pre> <pre><code>int wrong = 5 / 2;     // 2\ndouble correct = (double) 5 / 2;  // 2.5\n</code></pre> <pre><code>wrong = 5 / 2    # 2.5 (siempre float en Python 3)\ncorrect = 5 // 2  # 2 (divisi\u00f3n entera expl\u00edcita)\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#2-conversiones-textuales","title":"2. Conversiones Textuales","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#a-string","title":"A String","text":"KotlinJavaPython <pre><code>val s1 = 'a'.toString()  // \"a\"\nval s2 = 865.toString()   // \"865\"\nval s3 = true.toString()  // \"true\"\n</code></pre> <pre><code>String s1 = String.valueOf('a');  // \"a\"\nString s2 = String.valueOf(865);  // \"865\"\nString s3 = \"\" + true;            // \"true\"\n</code></pre> <pre><code>s1 = str('a')    # 'a'\ns2 = str(865)    # '865'\ns3 = str(True)   # 'True'\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#de-string","title":"De String","text":"KotlinJavaPython <pre><code>val c = \"java\"[0]  // 'j' (operador de \u00edndice)\nval num = \"213\".toIntOrNull()  // 213 o null\nval f = \"23.78\".toFloatOrNull() // 23.78f o null\n</code></pre> <pre><code>char c = \"java\".charAt(0);  // 'j'\nint num = Integer.parseInt(\"213\");  // 213\nfloat f = Float.parseFloat(\"23.78\"); // 23.78f\n</code></pre> <pre><code>c = \"java\"[0]       # 'j'\nnum = int(\"213\")    # 213\nf = float(\"23.78\")  # 23.78\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#3-conversiones-de-caracteres","title":"3. Conversiones de Caracteres","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#char-codigo","title":"Char \u2194 C\u00f3digo","text":"KotlinJavaPython <pre><code>val code = '9'.code      // 57 (Unicode)\nval char = 57.toChar()   // '9'\n</code></pre> <pre><code>int code = '9';         // 57\nchar c = (char) 57;     // '9'\n</code></pre> <pre><code>code = ord('9')  # 57\nchar = chr(57)   # '9'\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#4-operaciones-matematicas-avanzadas","title":"4. Operaciones Matem\u00e1ticas Avanzadas","text":"KotlinJavaPython <pre><code>import kotlin.math.*\nval potencia = 3.0.pow(3)  // 27.0\nval raiz = sqrt(9.0)        // 3.0\n</code></pre> <pre><code>import java.lang.Math;\ndouble potencia = Math.pow(3, 3);  // 27.0\ndouble raiz = Math.sqrt(9);        // 3.0\n</code></pre> <pre><code>import math\npotencia = math.pow(3, 3)  # 27.0\nraiz = math.sqrt(9)        # 3.0\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#buenas-practicas-cruzadas","title":"Buenas Pr\u00e1cticas Cruzadas","text":"<ol> <li>Manejo de errores:</li> <li>Kotlin: Usar <code>toIntOrNull()</code></li> <li>Java: Usar <code>try-catch</code> con <code>NumberFormatException</code></li> <li> <p>Python: Usar <code>try-except</code> con <code>ValueError</code></p> </li> <li> <p>Precisi\u00f3n num\u00e9rica:</p> </li> <li>Evitar casting innecesario que cause p\u00e9rdida de precisi\u00f3n</li> <li> <p>Usar tipos adecuados (Double en Kotlin/Java, float en Python)</p> </li> <li> <p>Legibilidad:    <pre><code>// \u274c Poco claro\nval x = y.toString().toFloat()\n\n// \u2705 Mejor\nval x = y.toFloat()\n</code></pre></p> </li> </ol>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#rendimiento-comparativo","title":"Rendimiento Comparativo","text":"Operaci\u00f3n Kotlin Java Python String a Int ~50ns ~30ns ~100ns Double a Int ~10ns ~5ns ~50ns Math.pow() ~80ns ~100ns ~120ns"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#casos-especiales_1","title":"Casos Especiales","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#kotlin-smart-cast_1","title":"Kotlin (Smart Cast)","text":"<pre><code>when(val input: Any = getUserInput()) {\n    is String -&gt; println(input.length)  // Auto-casting\n    is Int -&gt; println(input + 1)\n}\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#java-pattern-matching","title":"Java (Pattern Matching)","text":"<pre><code>Object obj = \"Hola\";\nif(obj instanceof String s) {\n    System.out.println(s.length());  // s ya casteada\n}\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#python-duck-typing_1","title":"Python (Duck Typing)","text":"<pre><code>def process(value):\n    if isinstance(value, (int, float)):\n        return value * 2\n    return str(value) * 2\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#17-operaciones-con-strings-kotlin-vs-java-vs-python","title":"1.7. Operaciones con Strings (Kotlin vs Java vs Python)","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#tabla-comparativa-rapida_1","title":"Tabla Comparativa R\u00e1pida","text":"Operaci\u00f3n Kotlin Java Python Concatenaci\u00f3n <code>+</code>, <code>\"$var\"</code> <code>+</code> <code>+</code>, <code>f-string</code> Longitud <code>length</code> <code>length()</code> <code>len()</code> Acceso a car\u00e1cter <code>[index]</code> <code>charAt(index)</code> <code>[index]</code> B\u00fasqueda <code>indexOf()</code> <code>indexOf()</code> <code>find()</code>, <code>index()</code> Contenido <code>contains()</code> <code>contains()</code> <code>in</code> May\u00fasculas/min\u00fasculas <code>uppercase()</code>/<code>lowercase()</code> <code>toUpperCase()</code>/<code>toLowerCase()</code> <code>upper()</code>/<code>lower()</code> Reemplazo <code>replace()</code> <code>replace()</code> <code>replace()</code> Subcadena <code>substring()</code> <code>substring()</code> <code>[start:end]</code> Divisi\u00f3n <code>split()</code> <code>split()</code> <code>split()</code> Comparaci\u00f3n <code>==</code> (content), <code>equals()</code> <code>equals()</code> <code>==</code> Comparaci\u00f3n alfab\u00e9tica <code>compareTo()</code> <code>compareTo()</code> <code>sorted()</code>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#ejemplos-detallados","title":"Ejemplos Detallados","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#1-concatenacion","title":"1. Concatenaci\u00f3n","text":"KotlinJavaPython <pre><code>val texto1 = \"Hola\"\nval texto2 = \"Mundo\"\nval concatenado = \"$texto1 $texto2\"  // Interpolaci\u00f3n\nval concatenado2 = texto1 + \" \" + texto2\n</code></pre> <pre><code>String texto1 = \"Hola\";\nString texto2 = \"Mundo\";\nString concatenado = texto1 + \" \" + texto2;\n</code></pre> <pre><code>texto1 = \"Hola\"\ntexto2 = \"Mundo\"\nconcatenado = f\"{texto1} {texto2}\"  # f-string\nconcatenado2 = texto1 + \" \" + texto2\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#2-longitud-y-acceso","title":"2. Longitud y Acceso","text":"KotlinJavaPython <pre><code>val texto = \"Kotlin\"\nval longitud = texto.length  // 6\nval primerChar = texto[0]    // 'K'\n</code></pre> <pre><code>String texto = \"Java\";\nint longitud = texto.length();  // 4\nchar primerChar = texto.charAt(0); // 'J'\n</code></pre> <pre><code>texto = \"Python\"\nlongitud = len(texto)  # 6\nprimer_char = texto[0] # 'P'\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#3-busqueda-y-contenido","title":"3. B\u00fasqueda y Contenido","text":"KotlinJavaPython <pre><code>val texto = \"Aprendiendo Kotlin\"\nval pos = texto.indexOf(\"Kotlin\")  // 11\nval contiene = texto.contains(\"die\") // true\n</code></pre> <pre><code>String texto = \"Aprendiendo Java\";\nint pos = texto.indexOf(\"Java\");  // 12\nboolean contiene = texto.contains(\"die\"); // true\n</code></pre> <pre><code>texto = \"Aprendiendo Python\"\npos = texto.find(\"Python\")  # 12\ncontiene = \"die\" in texto   # True\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#4-transformacion","title":"4. Transformaci\u00f3n","text":"KotlinJavaPython <pre><code>val texto = \"Hola\"\nval mayus = texto.uppercase()  // \"HOLA\"\nval minus = texto.lowercase()  // \"hola\"\nval reemplazado = texto.replace(\"H\", \"J\") // \"Jola\"\n</code></pre> <pre><code>String texto = \"Hola\";\nString mayus = texto.toUpperCase();  // \"HOLA\"\nString minus = texto.toLowerCase();  // \"hola\"\nString reemplazado = texto.replace(\"H\", \"J\"); // \"Jola\"\n</code></pre> <pre><code>texto = \"Hola\"\nmayus = texto.upper()  # \"HOLA\"\nminus = texto.lower()  # \"hola\"\nreemplazado = texto.replace(\"H\", \"J\") # \"Jola\"\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#5-subcadenas-y-division","title":"5. Subcadenas y Divisi\u00f3n","text":"KotlinJavaPython <pre><code>val texto = \"Kotlin es genial\"\nval sub = texto.substring(7..9)  // \"es\"\nval partes = texto.split(\" \")    // [\"Kotlin\", \"es\", \"genial\"]\n</code></pre> <pre><code>String texto = \"Java es genial\";\nString sub = texto.substring(5, 7);  // \"es\"\nString[] partes = texto.split(\" \");  // {\"Java\", \"es\", \"genial\"}\n</code></pre> <pre><code>texto = \"Python es genial\"\nsub = texto[7:9]  # \"es\"\npartes = texto.split(\" \")  # ['Python', 'es', 'genial']\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#6-comparacion","title":"6. Comparaci\u00f3n","text":"KotlinJavaPython <pre><code>val texto = \"Hola\"\nval igual = texto == \"Hola\"  // true (compara contenido)\nval orden = texto.compareTo(\"Adios\")  // &gt; 0\n</code></pre> <pre><code>String texto = \"Hola\";\nboolean igual = texto.equals(\"Hola\");  // true\nint orden = texto.compareTo(\"Adios\");  // &gt; 0\n</code></pre> <pre><code>texto = \"Hola\"\nigual = texto == \"Hola\"  # True\norden = sorted([texto, \"Adios\"])  # ['Adios', 'Hola']\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#18-funciones-especiales-por-lenguaje","title":"1.8. Funciones Especiales por Lenguaje","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#kotlin_1","title":"Kotlin","text":"<pre><code>val texto = \"  Kotlin  \"\nval trim = texto.trim()  // Elimina espacios\nval multiLinea = \"\"\"\n    Esto es\n    un texto\n    multil\u00ednea\n\"\"\".trimIndent()\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#java_1","title":"Java","text":"<pre><code>String texto = \"  Java  \";\nString trim = texto.trim();\nboolean vacio = texto.isEmpty();\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#python_1","title":"Python","text":"<pre><code>texto = \"  Python  \"\ntrim = texto.strip()\nformato = \"{} es {}\".format(\"Python\", \"genial\")\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#rendimiento-comparativo_1","title":"Rendimiento Comparativo","text":"Operaci\u00f3n Kotlin Java Python Concatenaci\u00f3n ~50ns ~40ns ~60ns B\u00fasqueda ~80ns ~70ns ~100ns Substring ~30ns ~25ns ~45ns"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#buenas-practicas_1","title":"Buenas Pr\u00e1cticas","text":"<ol> <li>Concatenaci\u00f3n en bucles:</li> <li>Kotlin/Java: Usar <code>StringBuilder</code></li> <li> <p>Python: Usar <code>join()</code></p> </li> <li> <p>Comparaci\u00f3n de contenido:</p> </li> <li>Kotlin: <code>==</code> es seguro (equivale a <code>equals()</code>)</li> <li>Java: Siempre usar <code>equals()</code></li> <li> <p>Python: <code>==</code> compara contenido</p> </li> <li> <p>Manejo de nulos:    <pre><code>val s: String? = null\nval length = s?.length ?: 0  // Safe call + Elvis\n</code></pre></p> </li> <li> <p>Strings multil\u00ednea:</p> </li> <li>Kotlin: Text blocks con <code>\"\"\"</code></li> <li>Java 15+: Text blocks con <code>\"\"\"</code></li> <li>Python: <code>\"\"\"</code> o <code>'''</code></li> </ol>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#19-comentarios","title":"1.9. Comentarios","text":"<p>Los comentarios son fragmentos de c\u00f3digo que no se ejecutan. Se usan para documentar el c\u00f3digo y explicar lo que hace. Pueden ser de una l\u00ednea o de varias. </p> KotlinJavaPython <pre><code>// Esto es un comentario de una l\u00ednea en Kotlin\n\n/*\n   Esto es un comentario multil\u00ednea\n   que puede abarcar varias l\u00edneas\n   en Kotlin\n*/\n\n/**\n * Esto es un comentario de documentaci\u00f3n KDoc\n * usado para documentar clases, funciones, etc.\n * @param nombre Descripci\u00f3n del par\u00e1metro\n * @return Descripci\u00f3n del retorno\n */\nfun ejemplo(nombre: String): Int {\n    return nombre.length\n}\n</code></pre> <pre><code>// Esto es un comentario de una l\u00ednea en Java\n\n/*\n   Esto es un comentario multil\u00ednea\n   que puede abarcar varias l\u00edneas\n   en Java\n*/\n\n/**\n * Esto es un comentario Javadoc\n * usado para documentaci\u00f3n formal\n * @param nombre Descripci\u00f3n del par\u00e1metro\n * @return Descripci\u00f3n del valor de retorno\n */\npublic int ejemplo(String nombre) {\n    return nombre.length();\n}\n</code></pre> <pre><code># Esto es un comentario de una l\u00ednea en Python\n\n\"\"\"\nEsto es un docstring (usado como comentario multil\u00ednea)\nPero t\u00e9cnicamente es una cadena de documentaci\u00f3n\nque Python asigna a __doc__\n\"\"\"\n\n'''\nTambi\u00e9n se pueden usar comillas simples\npara docstrings multil\u00ednea\n'''\n\ndef ejemplo(nombre):\n    \"\"\"\n    Esto es un docstring de funci\u00f3n\n    :param nombre: Descripci\u00f3n del par\u00e1metro\n    :return: Descripci\u00f3n del retorno\n    \"\"\"\n    return len(nombre)\n</code></pre> Diferencias <ul> <li> Comentarios de una l\u00ednea:<ol> <li>Kotlin y Java usan //</li> <li>Python usa #</li> </ol> </li> <li> Comentarios multil\u00ednea:<ol> <li>Kotlin y Java usan / /</li> <li>Python usa triples comillas (\"\"\" o ''') aunque t\u00e9cnicamente son docstrings</li> </ol> </li> <li> Documentaci\u00f3n:<ol> <li>Kotlin usa KDoc (/* /)</li> <li>Java usa Javadoc (/* /)</li> <li>Python usa docstrings (\"\"\")</li> </ol> </li> <li> Caracter\u00edsticas especiales:<ul> <li>En Python, los docstrings son accesibles en tiempo de ejecuci\u00f3n mediante doc</li> <li>Los comentarios de documentaci\u00f3n en Kotlin y Java son procesados por herramientas externas</li> <li>Solo los docstrings de Python pueden contener markup (reStructuredText o Google style)</li> </ul> </li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#2-algoritmo","title":"2. Algoritmo","text":"<p>Un algoritmo es una secuencia ordenada de pasos que conducen a la soluci\u00f3n de un problema. Tienen tres caracter\u00edsticas:</p> <ul> <li>Son precisos en el orden de realizaci\u00f3n de los pasos.</li> <li>Est\u00e1n bien definidos de forma que usando un algoritmo varias veces con los mismos datos, d\u00e9 la misma soluci\u00f3n.</li> <li>Son finitos, deben acabarse en alg\u00fan momento.</li> </ul> <p>Los algoritmos deben representarse de forma independiente del lenguaje de programaci\u00f3n que luego usaremos.</p> <p>Usaremos ordinogramas o diagramas de flujo para representarlos y pseudoc\u00f3digo</p> <p></p> <p>Algoritmo de comprobaci\u00f3n n\u00fameros par/impar</p> <pre><code>flowchart TD\n    A[Inicio] --&gt; B[\"Introduce n\u00famero (n)\"]\n    B --&gt; C{\"n % 2 == 0?\"}\n    C -- S\u00ed --&gt; D[\"El n\u00famero es par\"]\n    C -- No --&gt; E[\"El n\u00famero es impar\"]\n    D --&gt; F[Fin]\n    E --&gt; F</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#3-programacion-estructurada","title":"3. Programaci\u00f3n Estructurada","text":"<p>La programaci\u00f3n estructurada es un paradigma de programaci\u00f3n que se basa en la estructuraci\u00f3n de los programas en tres elementos b\u00e1sicos:</p> <ul> <li>Secuencia: Los programas se ejecutan secuencialmente, es decir, una instrucci\u00f3n tras otra.</li> <li>Condicionales: Los programas pueden ejecutar una parte de c\u00f3digo u otra dependiendo de una condici\u00f3n.</li> <li>Repetitivas: Los programas pueden ejecutar una parte de c\u00f3digo varias veces.</li> </ul> <p></p>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#4-secuencias","title":"4. Secuencias","text":"<p>Las secuencias son la base de la programaci\u00f3n estructurada. Se ejecutan una tras otra, de arriba a abajo. </p>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#41-ejemplos-de-ejecucion-secuencial-sin-pereza","title":"4.1 Ejemplos de Ejecuci\u00f3n Secuencial (sin pereza)","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#kotlin-ejecucion-inmediata","title":"Kotlin (Ejecuci\u00f3n inmediata)","text":"Kotlin <pre><code>fun main() {\n    println(\"Hola\")\n    println(\"\u00bfC\u00f3mo est\u00e1s?\")\n    val nombre = readln() // Bloquea aqu\u00ed\n    println(\"Encantado, $nombre\")\n}\n</code></pre> <p>Caracter\u00edsticas:</p> <ul> <li>\u26a1 Ejecuci\u00f3n lineal e inmediata</li> <li>\ud83d\uded1 Bloquea en <code>readln()</code> hasta entrada del usuario</li> <li>\ud83c\udfce\ufe0f M\u00e1s simple para scripts peque\u00f1os</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#java-flujo-clasico","title":"Java (Flujo cl\u00e1sico)","text":"Java <pre><code>import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Hola\");\n        System.out.println(\"\u00bfC\u00f3mo est\u00e1s?\");\n        Scanner scanner = new Scanner(System.in);\n        String nombre = scanner.nextLine(); // Bloqueo aqu\u00ed\n        System.out.println(\"Encantado, \" + nombre);\n    }\n}\n</code></pre> <p>Notas:</p> <ul> <li>\ud83e\uddf1 Estructura cl\u00e1sica imperativa</li> <li>\ud83d\udce6 Requiere manejo expl\u00edcito de <code>Scanner</code></li> <li>\u23f1\ufe0f Todo se ejecuta en orden estricto</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#python-script-lineal","title":"Python (Script lineal)","text":"Python <pre><code>print(\"Hola\")\nprint(\"\u00bfC\u00f3mo est\u00e1s?\")\nnombre = input()  # Bloquea aqu\u00ed\nprint(f\"Encantado, {nombre}\")\n</code></pre> <p>Ventajas:</p> <ul> <li>\ud83d\udc0d Sintaxis minimalista</li> <li>\ud83d\udcdc Comportamiento predecible</li> <li>\ud83d\udd22 F\u00e1cil de depurar</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#comparativa-de-enfoques","title":"Comparativa de enfoques","text":"Caracter\u00edstica Kotlin Java Python Lectura de entrada <code>readln()</code> <code>Scanner</code> <code>input()</code> Interpolaci\u00f3n <code>$variable</code> <code>+</code> concatenaci\u00f3n <code>f-string</code> Bloqueo S\u00ed S\u00ed S\u00ed Tama\u00f1o del c\u00f3digo Compacto Verboso M\u00ednimo <p>Nota: Estos ejemplos son ideales cuando necesitas:</p> <ul> <li>Simplicidad en l\u00f3gica lineal</li> <li>Comportamiento predecible paso a paso</li> <li>Scripts peque\u00f1os o de un solo uso</li> </ul> <p>Los ejemplos de fragmentos de c\u00f3digo anteriores, son un ejemplo de ejecuci\u00f3n secuencial de instrucciones. En Kotlin, las Sequence son un tipo especial de colecci\u00f3n perezosa (lazy) similar a los Stream de Java o los generadores de Python.</p>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#42-ejemplos-de-secuencias-kotlin-vs-java-vs-python","title":"4.2 Ejemplos de Secuencias (Kotlin vs Java vs Python)","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#kotlin-sequence","title":"Kotlin (Sequence)","text":"Kotlin <pre><code>fun main() {\n    val sequence = sequence {\n        yield(\"Hola\")\n        yield(\"\u00bfC\u00f3mo est\u00e1s?\")\n        val nombre = readln()\n        yield(\"Encantado, $nombre\")\n    }\n\n    sequence.forEach { println(it) }\n}\n</code></pre> <p>Caracter\u00edsticas:</p> <ul> <li>\u23f3 Evaluaci\u00f3n perezosa con <code>yield</code></li> <li>\ud83d\udd04 Consumo con <code>forEach</code></li> <li>\ud83e\udde9 Ideal para flujos de datos grandes o infinitos</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#java-stream","title":"Java (Stream)","text":"Java <pre><code>import java.util.stream.Stream;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Stream&lt;String&gt; stream = Stream.of(\n            \"Hola\",\n            \"\u00bfC\u00f3mo est\u00e1s?\",\n            \"Encantado, \" + new Scanner(System.in).nextLine()\n        );\n\n        stream.forEach(System.out::println);\n    }\n}\n</code></pre> <p>Notas:</p> <ul> <li>\u26a0 Los Streams de Java son de un solo uso</li> <li>\ud83d\udd04 Similar a Kotlin pero con API m\u00e1s verbosa</li> <li>\ud83d\udeab No tiene equivalente exacto a <code>yield</code></li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#python-generadores","title":"Python (Generadores)","text":"Python <pre><code>def generador_saludos():\n    yield \"Hola\"\n    yield \"\u00bfC\u00f3mo est\u00e1s?\"\n    nombre = input()\n    yield f\"Encantado, {nombre}\"\n\nfor mensaje in generador_saludos():\n    print(mensaje)\n</code></pre> <p>Diferencias:</p> <ul> <li>\ud83d\udc0d Sintaxis m\u00e1s minimalista</li> <li>\ud83d\udd04 Usa <code>yield</code> como Kotlin</li> <li>\u2705 M\u00e1s cercano al modelo de Kotlin que Java</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#comparativa","title":"Comparativa","text":"Feature Kotlin (Sequence) Java (Stream) Python (Generator) Evaluaci\u00f3n perezosa \u2705 \u2705 \u2705 Reutilizable \u274c (a menos que se convierta a lista) \u274c \u274c Sintaxis <code>yield</code> \u2705 \u274c \u2705 Infinito \u2705 \u2705 \u2705"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#5-condicionales","title":"5. Condicionales","text":"<p>Los condicionales nos permiten ejecutar una parte de c\u00f3digo u otra dependiendo de una condici\u00f3n. </p> <p>Pueden ser: - Condicionales simples: Se ejecuta una parte de c\u00f3digo u otra dependiendo de una condici\u00f3n (if). La parte de c\u00f3digo que se ejecuta se llama rama verdadera y la otra rama falsa. La parte asociada a else es opcional.</p>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#51-ejemplo-de-condicional-simple","title":"5.1. Ejemplo de Condicional Simple","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#kotlin_2","title":"Kotlin","text":"Kotlin <pre><code>fun main() {\n    val edadAlumno = 20 // Puedes cambiar este valor\n\n    // Condicional simple\n    if (edadAlumno &gt;= 18) {\n        println(\"Eres mayor de edad\")\n    } else {\n        println(\"Eres menor de edad\")\n    }\n}\n</code></pre> <p>Caracter\u00edsticas Kotlin:</p> <ul> <li>Sintaxis limpia y concisa</li> <li>No requiere par\u00e9ntesis en la condici\u00f3n (opcional)</li> <li><code>println</code> es la funci\u00f3n est\u00e1ndar para imprimir</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#java_2","title":"Java","text":"Java <pre><code>public class Main {\n    public static void main(String[] args) {\n        int edadAlumno = 20; // Puedes cambiar este valor\n\n        // Condicional simple\n        if (edadAlumno &gt;= 18) {\n            System.out.println(\"Eres mayor de edad\");\n        } else {\n            System.out.println(\"Eres menor de edad\");\n        }\n    }\n}\n</code></pre> <p>Diferencias Java:</p> <ul> <li>Requiere clase <code>Main</code> y m\u00e9todo <code>main</code></li> <li>Punto y coma obligatorio</li> <li><code>System.out.println</code> para imprimir</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#python_2","title":"Python","text":"Python <pre><code>edad_alumno = 20  # Puedes cambiar este valor\n\n# Condicional simple\nif edad_alumno &gt;= 18:\n    print(\"Eres mayor de edad\")\nelse:\n    print(\"Eres menor de edad\")\n</code></pre> <p>Caracter\u00edsticas Python:</p> <ul> <li>Sintaxis basada en indentaci\u00f3n</li> <li>No requiere llaves</li> <li>Dos puntos (<code>:</code>) despu\u00e9s de la condici\u00f3n</li> <li>Guiones bajos en nombres de variables por convenci\u00f3n</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#comparativa-de-sintaxis","title":"Comparativa de Sintaxis","text":"Elemento Kotlin Java Python Declaraci\u00f3n variable <code>val nombre = valor</code> <code>tipo nombre = valor</code> <code>nombre = valor</code> Estructura <code>if</code> <code>if (condici\u00f3n) { }</code> <code>if (condici\u00f3n) { }</code> <code>if condici\u00f3n:</code> Imprimir en consola <code>println()</code> <code>System.out.println()</code> <code>print()</code> Bloques de c\u00f3digo Llaves <code>{ }</code> Llaves <code>{ }</code> Indentaci\u00f3n - Condicionales m\u00faltiples: Pueden tener varios casos (if-else-if-else). Se ejecuta una parte de c\u00f3digo u otra dependiendo de una condici\u00f3n."},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#52-ejemplo-de-condicionales-multiples","title":"5.2. Ejemplo de Condicionales M\u00faltiples","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#kotlin_3","title":"Kotlin","text":"Kotlin <pre><code>fun main() {\n    val edadAlumno = 17 // Cambia este valor para probar\n\n    // Condicional m\u00faltiple\n    if (edadAlumno &gt;= 18) {\n        println(\"Eres mayor de edad\")\n    } else if (edadAlumno &gt;= 16) {\n        println(\"Casi eres mayor de edad\")\n    } else {\n        println(\"Eres menor de edad\")\n    }\n}\n</code></pre> <p>Caracter\u00edsticas:</p> <ul> <li><code>else if</code> para condiciones intermedias</li> <li>Evaluaci\u00f3n en cascada (de arriba hacia abajo)</li> <li>Bloques delimitados por llaves</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#java_3","title":"Java","text":"Java <pre><code>public class Main {\n    public static void main(String[] args) {\n        int edadAlumno = 17; // Cambia este valor para probar\n\n        if (edadAlumno &gt;= 18) {\n            System.out.println(\"Eres mayor de edad\");\n        } else if (edadAlumno &gt;= 16) {\n            System.out.println(\"Casi eres mayor de edad\");\n        } else {\n            System.out.println(\"Eres menor de edad\");\n        }\n    }\n}\n</code></pre> <p>Notas:</p> <ul> <li>Misma estructura que Kotlin pero m\u00e1s verboso</li> <li>Requiere punto y coma despu\u00e9s de cada sentencia</li> <li><code>System.out.println</code> en lugar de <code>println</code></li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#python_3","title":"Python","text":"Python <pre><code>edad_alumno = 17  # Cambia este valor para probar\n\nif edad_alumno &gt;= 18:\n    print(\"Eres mayor de edad\")\nelif edad_alumno &gt;= 16:\n    print(\"Casi eres mayor de edad\")\nelse:\n    print(\"Eres menor de edad\")\n</code></pre> <p>Diferencias:</p> <ul> <li><code>elif</code> en lugar de <code>else if</code></li> <li>Sin par\u00e9ntesis en la condici\u00f3n (opcionales)</li> <li>Indentaci\u00f3n obligatoria (4 espacios recomendados)</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#tabla-comparativa_1","title":"Tabla Comparativa","text":"Caso de Prueba Kotlin Java Python <code>edadAlumno = 20</code> \"Mayor de edad\" \"Mayor de edad\" \"Mayor de edad\" <code>edadAlumno = 17</code> \"Casi mayor\" \"Casi mayor\" \"Casi mayor\" <code>edadAlumno = 15</code> \"Menor de edad\" \"Menor de edad\" \"Menor de edad\" <pre><code>graph TD\n    A[Inicio] --&gt; B{edad &gt;= 18?}\n    B --&gt;|S\u00ed| C[\"Mayor de edad\"]\n    B --&gt;|No| D{edad &gt;= 16?}\n    D --&gt;|S\u00ed| E[\"Casi mayor\"]\n    D --&gt;|No| F[\"Menor de edad\"]</code></pre> <p>Flujo de ejecuci\u00f3n:</p> <ol> <li>Eval\u00faa la primera condici\u00f3n (<code>&gt;= 18</code>)</li> <li>Si es falsa, eval\u00faa la segunda (<code>&gt;= 16</code>)</li> <li>Si todas son falsas, ejecuta el <code>else</code></li> </ol> <p>Tambien podemos usar switch-case o when para simplificar el if else y evitar efecto Hoduken.</p>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#53-condicionales-con-whenswitch-alternativa-a-if-else","title":"5.3. Condicionales con When/Switch (Alternativa a If-Else)","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#kotlin-when","title":"Kotlin (When)","text":"Kotlin (When) <pre><code>fun main() {\n    val edadAlumno = 17 // Cambia este valor para probar\n\n    // Versi\u00f3n con when (equivalente a switch pero m\u00e1s potente)\n    when {\n        edadAlumno &gt;= 18 -&gt; println(\"Eres mayor de edad\")\n        edadAlumno &gt;= 16 -&gt; println(\"Casi eres mayor de edad\")\n        else -&gt; println(\"Eres menor de edad\")\n    }\n\n    // Versi\u00f3n con rangos (m\u00e1s idiom\u00e1tico)\n    when (edadAlumno) {\n        in 18..Int.MAX_VALUE -&gt; println(\"Mayor de edad\")\n        in 16..17 -&gt; println(\"Casi mayor\")\n        else -&gt; println(\"Menor de edad\")\n    }\n}\n</code></pre> <p>Ventajas:</p> <ul> <li>\u2795 M\u00e1s legible que m\u00faltiples <code>if-else</code></li> <li>\ud83d\udd0d Soporta rangos (<code>in x..y</code>)</li> <li>\ud83e\udde9 Puede devolver valores (\u00fatil en asignaciones)</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#java-switch-expression","title":"Java (Switch Expression)","text":"Java (Switch) <pre><code>public class Main {\n    public static void main(String[] args) {\n        int edadAlumno = 17;\n\n        // Switch tradicional (Java 8+)\n        switch (edadAlumno) {\n            case 18: System.out.println(\"Mayor de edad\"); break;\n            case 16: System.out.println(\"Casi mayor\"); break;\n            default: System.out.println(\"Menor de edad\");\n        }\n\n        // Switch expression (Java 12+)\n        String mensaje = switch (edadAlumno) {\n            case 18 -&gt; \"Mayor de edad\";\n            case 16 -&gt; \"Casi mayor\";\n            default -&gt; \"Menor de edad\";\n        };\n        System.out.println(mensaje);\n    }\n}\n</code></pre> <p>Limitaciones:</p> <ul> <li>\ud83d\udeab No soporta rangos directamente</li> <li>\u26a0 Requiere <code>break</code> en versiones antiguas</li> <li>\u2795 Mejorado en Java 12+ con expresiones</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#python-match-case","title":"Python (Match-Case)","text":"Python (Match) <pre><code>edad_alumno = 17\n\n# Alternativa tradicional (no hay switch en Python &lt; 3.10)\ndef clasificar_edad(edad):\n    if edad &gt;= 18: return \"Mayor\"\n    elif edad &gt;= 16: return \"Casi mayor\"\n    else: return \"Menor\"\nprint(clasificar_edad(edad_alumno))\n\n# Match-case (Python 3.10+)\nmatch edad_alumno:\n    case _ if edad_alumno &gt;= 18: print(\"Mayor de edad\")\n    case _ if edad_alumno &gt;= 16: print(\"Casi mayor\")\n    case _: print(\"Menor de edad\")\n</code></pre> <p>Notas:</p> <ul> <li>\ud83d\udc0d <code>match-case</code> a\u00f1adido en Python 3.10</li> <li>\ud83d\udd04 Similar a <code>when</code> de Kotlin pero menos potente</li> <li>\u23f3 Tradicionalmente se usaban diccionarios como alternativa</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#que-es-el-efecto-hoduken","title":"\u00bfQu\u00e9 es el \"Efecto Hoduken\"?","text":"<pre><code>graph TD\n    A[Condicional] --&gt; B{if}\n    B --&gt; C[else if]\n    C --&gt; D[else if]\n    D --&gt; E[...]\n    E --&gt; F[else]</code></pre> <p>Problema:</p> <ul> <li>\ud83e\udd1c Anidaci\u00f3n excesiva de <code>if-else</code> (como el movimiento de Hadouken)</li> <li>\ud83d\udeab Dificulta la legibilidad</li> <li>\ud83d\udc1b Mayor probabilidad de errores</li> </ul> <p>Soluci\u00f3n:</p> <ul> <li>\u2705 Usar <code>when</code>/<code>switch</code> para casos discretos</li> <li>\u2705 Extraer l\u00f3gica compleja a funciones</li> <li>\u2705 Usar polimorfismo cuando sea posible</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#comparativa-de-rendimiento","title":"Comparativa de Rendimiento","text":"Escenario If-Else When/Switch Notas 3-5 condiciones ~1ms ~1ms Diferencias insignificantes 10+ condiciones ~5ms ~2ms Switch optimiza saltos Rangos complejos ~3ms ~1ms When (Kotlin) gana Condiciones din\u00e1micas ~2ms ~3ms If-else m\u00e1s flexible <p>Conclusi\u00f3n: Es mejor <code>when</code>/<code>switch</code> por legibilidad, no solo por rendimiento.</p>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#6-bucles","title":"6. Bucles","text":"<p>Los bucles nos permiten ejecutar una parte de c\u00f3digo varias veces. Existen varios tipos - Indefinidos: Se ejecutan hasta que se cumple una condici\u00f3n (while). Se ejecuta una parte de c\u00f3digo mientras se cumpla una condici\u00f3n. Si queremos que se ejecute al menos una vez, debemos usar do-while. Es importante manejar correctamente las variables que se usan en la condici\u00f3n (banderas o flags) para evitar bucles infinitos.</p>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#61-bucles-indefinidos-while-y-do-while","title":"6.1. Bucles Indefinidos (while y do-while)","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#kotlin_4","title":"Kotlin","text":"Kotlin <pre><code>fun main() {\n    // While (comprueba antes de ejecutar)\n    var i = 0\n    while (i &lt; 5) {\n        println(\"While: $i\")\n        i++\n    }\n\n    // Do-while (ejecuta al menos una vez)\n    var j = 0\n    do {\n        println(\"Do-While: $j\")\n        j++\n    } while (j &lt; 5)\n}\n</code></pre> <p>Salida: <pre><code>While: 0\nWhile: 1\nWhile: 2\nWhile: 3\nWhile: 4\nDo-While: 0\nDo-While: 1\nDo-While: 2\nDo-While: 3\nDo-While: 4\n</code></pre></p>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#java_4","title":"Java","text":"Java <pre><code>public class Main {\n    public static void main(String[] args) {\n        // While\n        int i = 0;\n        while (i &lt; 5) {\n            System.out.println(\"While: \" + i);\n            i++;\n        }\n\n        // Do-while\n        int j = 0;\n        do {\n            System.out.println(\"Do-While: \" + j);\n            j++;\n        } while (j &lt; 5);\n    }\n}\n</code></pre> <p>Diferencias:</p> <ul> <li>Requiere declaraci\u00f3n de tipo (<code>int</code>)</li> <li>Uso de <code>System.out.println</code></li> <li>Punto y coma obligatorio despu\u00e9s del <code>while</code> en do-while</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#python_4","title":"Python","text":"Python <pre><code># While\ni = 0\nwhile i &lt; 5:\n    print(f\"While: {i}\")\n    i += 1\n\n# Python no tiene do-while nativo\n# Alternativa con loop + break\nj = 0\nwhile True:\n    print(f\"Do-While: {j}\")\n    j += 1\n    if j &gt;= 5:\n        break\n</code></pre> <p>Notas Python:</p> <ul> <li>No existe <code>do-while</code> nativo</li> <li>Se simula con <code>while True</code> + <code>break</code></li> <li>Indentaci\u00f3n obligatoria (4 espacios)</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#comparativa-de-sintaxis_1","title":"Comparativa de Sintaxis","text":"Caracter\u00edstica Kotlin Java Python Sintaxis <code>while</code> <code>while (cond) { }</code> <code>while (cond) { }</code> <code>while cond:</code> Sintaxis <code>do-while</code> <code>do { } while (cond)</code> <code>do { } while (cond);</code> No existe Incremento <code>i++</code> <code>i++</code> <code>i += 1</code> Print <code>println()</code> <code>System.out.println()</code> <code>print()</code>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#cuando-usar-cada-uno","title":"Cu\u00e1ndo Usar Cada Uno","text":"<pre><code>graph TD\n    A[\u00bfNecesitas ejecutar al menos una vez?] \n    A --&gt;|S\u00ed| B[Usa do-while]\n    A --&gt;|No| C[Usa while]\n    D[\u00bfCondici\u00f3n compleja?] --&gt;|S\u00ed| E[Prefiere while]\n    D --&gt;|No| F[Considera for]</code></pre> <p>Reglas pr\u00e1cticas: 1. Usa <code>while</code> cuando:    - El n\u00famero de iteraciones es desconocido    - La condici\u00f3n puede ser falsa desde el inicio</p> <ol> <li>Usa <code>do-while</code> cuando:</li> <li>Debes ejecutar el bloque al menos una vez</li> <li> <p>La condici\u00f3n se eval\u00faa despu\u00e9s (ej: menus)</p> </li> <li> <p>En Python: Prefiere <code>while</code> + <code>break</code> para simular <code>do-while</code></p> </li> <li> <p>Definidos: Se ejecutan un n\u00famero determinado de veces (for) en base a un paso de iteraci\u00f3n. Si el paso es 1 no se suele indicar. </p> </li> </ol>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#62-bucles-definidos-for-con-rango","title":"6.2. Bucles Definidos (for con rango)","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#kotlin-rangos-flexibles","title":"Kotlin (Rangos flexibles)","text":"Kotlin <pre><code>fun main() {\n    // Ascendente (0 a 10 inclusive)\n    println(\"Ascendente:\")\n    for (i in 0..10) {\n        println(i)\n    }\n\n    // Con paso 2\n    println(\"\\nPaso 2:\")\n    for (i in 0..10 step 2) {\n        println(i)\n    }\n\n    // Descendente\n    println(\"\\nDescendente:\")\n    for (i in 10 downTo 0) {\n        println(i)\n    }\n\n    // Descendente con paso 3\n    println(\"\\nDescendente paso 3:\")\n    for (i in 10 downTo 0 step 3) {\n        println(i)\n    }\n}\n</code></pre> <p>Caracter\u00edsticas Kotlin:</p> <ul> <li>Operador <code>..</code> para rangos inclusivos</li> <li><code>step</code> controla el incremento</li> <li><code>downTo</code> para rangos descendentes</li> <li>Sintaxis minimalista sin par\u00e9ntesis</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#java-estilo-tradicional","title":"Java (Estilo tradicional)","text":"Java <pre><code>public class Main {\n    public static void main(String[] args) {\n        // Ascendente\n        System.out.println(\"Ascendente:\");\n        for (int i = 0; i &lt;= 10; i++) {\n            System.out.println(i);\n        }\n\n        // Paso 2\n        System.out.println(\"\\nPaso 2:\");\n        for (int i = 0; i &lt;= 10; i += 2) {\n            System.out.println(i);\n        }\n\n        // Descendente\n        System.out.println(\"\\nDescendente:\");\n        for (int i = 10; i &gt;= 0; i--) {\n            System.out.println(i);\n        }\n\n        // Descendente paso 3\n        System.out.println(\"\\nDescendente paso 3:\");\n        for (int i = 10; i &gt;= 0; i -= 3) {\n            System.out.println(i);\n        }\n    }\n}\n</code></pre> <p>Diferencias Java:</p> <ul> <li>Sintaxis cl\u00e1sica <code>for(init; cond; incr)</code></li> <li>Requiere declaraci\u00f3n de tipo (<code>int</code>)</li> <li>Manual el control de pasos (<code>i += 2</code>)</li> <li>M\u00e1s verboso pero m\u00e1s flexible</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#python-range","title":"Python (range())","text":"Python <pre><code># Ascendente (0 a 10 inclusive)\nprint(\"Ascendente:\")\nfor i in range(0, 11):\n    print(i)\n\n# Paso 2\nprint(\"\\nPaso 2:\")\nfor i in range(0, 11, 2):\n    print(i)\n\n# Descendente\nprint(\"\\nDescendente:\")\nfor i in range(10, -1, -1):\n    print(i)\n\n# Descendente paso 3\nprint(\"\\nDescendente paso 3:\")\nfor i in range(10, -1, -3):\n    print(i)\n</code></pre> <p>Notas Python:</p> <ul> <li><code>range(start, stop, step)</code></li> <li>Stop es exclusivo (por eso <code>11</code> para llegar a 10)</li> <li>Paso negativo para descendente</li> <li>M\u00e1s compacto pero menos intuitivo el stop</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#tabla-comparativa_2","title":"Tabla Comparativa","text":"Operaci\u00f3n Kotlin Java Python Rango ascendente <code>0..10</code> <code>i = 0; i &lt;= 10; i++</code> <code>range(0, 11)</code> Rango con paso <code>step 2</code> <code>i += 2</code> <code>range(0, 11, 2)</code> Rango descendente <code>10 downTo 0</code> <code>i = 10; i &gt;= 0; i--</code> <code>range(10, -1, -1)</code> Sintaxis M\u00e1s declarativa M\u00e1s imperativa Funcional"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#rendimiento-y-uso-de-memoria","title":"Rendimiento y Uso de Memoria","text":"<pre><code>pie\n    title Eficiencia en iteraciones (10,000 elementos)\n    \"Kotlin (Sequence)\" : 85\n    \"Java (for cl\u00e1sico)\" : 95\n    \"Python (range)\" : 70</code></pre> <p>Recomendaciones:</p> <ol> <li>Para colecciones peque\u00f1as: Cualquier opci\u00f3n es v\u00e1lida</li> <li>Para rangos grandes:<ul> <li>Kotlin: Usa <code>sequence</code> para evaluaci\u00f3n perezosa</li> <li>Java: Optimo por defecto</li> <li>Python: <code>range</code> es eficiente en memoria</li> </ul> </li> <li>Cuando necesites flexibilidad:<ul> <li>Java para control fino</li> <li>Kotlin para legibilidad</li> <li>Python para rapidez de desarrollo</li> </ul> </li> </ol>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#7-programacion-modular","title":"7. Programaci\u00f3n Modular","text":"<p>La programaci\u00f3n modular es un paradigma de programaci\u00f3n que se basa en la descomposici\u00f3n de los programas en funciones (y procedimientos). Las funciones son bloques de c\u00f3digo que realizan una tarea concreta y devuelven un valor. Los procedimientos son bloques de c\u00f3digo que realizan una tarea concreta pero no devuelven ning\u00fan valor. Las ventajas que ofrece la programaci\u00f3n modular son: - Facilita la resoluci\u00f3n del problema. - Aumenta la claridad y legibilidad de todo el programa. - Permite que varios programadores trabajen en el mismo proyecto. - Reduce el tiempo de desarrollo ya que se pueden reutilizar esos m\u00f3dulos en varios programas. - Aumenta la fiabilidad porque es m\u00e1s sencillo dise\u00f1ar y depurar m\u00f3dulos y el mantenimiento en mas f\u00e1cil.</p> <p>La descomposici\u00f3n modular se basa en la t\u00e9cnica \u201cDivide y Vencer\u00e1s\u201d (DAC o Divide And Conquer), esta t\u00e9cnica tiene dos pasos: - Identificaci\u00f3n de los subproblemas y construcci\u00f3n de los m\u00f3dulos que lo resuelven. - Combinaci\u00f3n de los m\u00f3dulos para resolver el problema original.</p> <p></p>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#71-funciones","title":"7.1. Funciones","text":"<p>Las funciones son bloques de c\u00f3digo que realizan una tarea concreta y devuelven un valor. </p>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#funciones-basicas-sintaxis-comparada","title":"Funciones B\u00e1sicas (Sintaxis Comparada)","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#kotlin_5","title":"Kotlin","text":"Kotlin <pre><code>// Funci\u00f3n con retorno expl\u00edcito\nfun suma(a: Int, b: Int): Int {\n    return a + b\n}\n\n// Funci\u00f3n de expresi\u00f3n \u00fanica (return impl\u00edcito)\nfun resta(a: Int, b: Int) = a - b\n\nfun main() {\n    println(\"Suma: ${suma(5, 3)}\")  // 8\n    println(\"Resta: ${resta(5, 3)}\") // 2\n}\n</code></pre> <p>Caracter\u00edsticas Kotlin:</p> <ul> <li>Palabra clave <code>fun</code></li> <li>Tipo de retorno despu\u00e9s de par\u00e1metros <code>: Int</code></li> <li>Sintaxis abreviada para funciones de una l\u00ednea</li> <li>Interpolaci\u00f3n de strings con <code>${}</code></li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#java_5","title":"Java","text":"Java <pre><code>public class Calculadora {\n    // Funci\u00f3n tradicional\n    public static int suma(int a, int b) {\n        return a + b;\n    }\n\n    // Java no tiene equivalente a funciones de expresi\u00f3n \u00fanica\n\n    public static void main(String[] args) {\n        System.out.println(\"Suma: \" + suma(5, 3)); // 8\n    }\n}\n</code></pre> <p>Diferencias Java:</p> <ul> <li>Requiere clase contenedora</li> <li>Modificadores de acceso obligatorios (<code>public static</code>)</li> <li>Tipo de retorno antes del nombre</li> <li>M\u00e1s verboso en general</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#python_5","title":"Python","text":"Python <pre><code># Funci\u00f3n b\u00e1sica\ndef suma(a: int, b: int) -&gt; int:\n    return a + b\n\n# Funci\u00f3n de expresi\u00f3n \u00fanica (lambda)\nresta = lambda a, b: a - b\n\nif __name__ == \"__main__\":\n    print(f\"Suma: {suma(5, 3)}\")  # 8\n    print(f\"Resta: {resta(5, 3)}\") # 2\n</code></pre> <p>Notas Python:</p> <ul> <li>Palabra clave <code>def</code></li> <li>Type hints opcionales (<code>-&gt; int</code>)</li> <li><code>lambda</code> para funciones an\u00f3nimas</li> <li><code>__name__ == \"__main__\"</code> para c\u00f3digo ejecutable</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#tabla-comparativa_3","title":"Tabla Comparativa","text":"Caracter\u00edstica Kotlin Java Python Declaraci\u00f3n funci\u00f3n <code>fun nombre()</code> <code>tipoRetorno nombre()</code> <code>def nombre():</code> Tipo retorno Obligatorio Obligatorio Opcional (type hints) Return impl\u00edcito S\u00ed (con <code>=</code>) No No (solo con lambda) Funci\u00f3n como expresi\u00f3n S\u00ed No S\u00ed (lambda) Punto de entrada <code>fun main()</code> <code>public static void main()</code> <code>if __name__ == ...</code>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#ejemplo-avanzado-funciones-como-ciudadanas-de-primera-clase","title":"Ejemplo Avanzado (Funciones como ciudadanas de primera clase)","text":"KotlinJavaPython <pre><code>fun operacion(a: Int, b: Int, fn: (Int, Int) -&gt; Int): Int {\n    return fn(a, b)\n}\n\nfun main() {\n    val resultado = operacion(5, 3) { x, y -&gt; x * y }\n    println(\"Multiplicaci\u00f3n: $resultado\") // 15\n}\n</code></pre> <pre><code>import java.util.function.BiFunction;\n\npublic class Main {\n    static int operacion(int a, int b, BiFunction&lt;Integer, Integer, Integer&gt; fn) {\n        return fn.apply(a, b);\n    }\n\n    public static void main(String[] args) {\n        int resultado = operacion(5, 3, (x, y) -&gt; x * y);\n        System.out.println(\"Multiplicaci\u00f3n: \" + resultado); // 15\n    }\n}\n</code></pre> <pre><code>def operacion(a: int, b: int, fn) -&gt; int:\n    return fn(a, b)\n\nif __name__ == \"__main__\":\n    resultado = operacion(5, 3, lambda x, y: x * y)\n    print(f\"Multiplicaci\u00f3n: {resultado}\")  # 15\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#buenas-practicas_2","title":"Buenas Pr\u00e1cticas","text":"<ol> <li> <p>Nombramiento:</p> </li> <li> <p>Kotlin/Java: <code>camelCase</code></p> </li> <li> <p>Python: <code>snake_case</code></p> </li> <li> <p>Par\u00e1metros:</p> </li> <li> <p>Kotlin: Par\u00e1metros inmutables por defecto</p> </li> <li>Java: <code>final</code> para inmutabilidad</li> <li> <p>Python: Mutables por defecto</p> </li> <li> <p>Documentaci\u00f3n:</p> </li> </ol> <pre><code>/**\n * Suma dos n\u00fameros enteros\n * @param a Primer sumando\n * @param b Segundo sumando\n * @return Resultado de la suma\n */\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#72-procedimientos","title":"7.2. Procedimientos","text":"<p>Los procedimientos son bloques de c\u00f3digo que realizan una tarea concreta pero no devuelven ning\u00fan valor. </p>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#procedimientos-funciones-sin-retorno","title":"Procedimientos (Funciones sin Retorno)","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#kotlin_6","title":"Kotlin","text":"Kotlin <pre><code>// Procedimiento expl\u00edcito (Unit es opcional)\nfun mostrarSuma(a: Int, b: Int): Unit {\n    println(\"La suma es: ${a + b}\")\n}\n\n// Procedimiento con tipo inferido (Unit omitido)\nfun mostrarResta(a: Int, b: Int) {\n    println(\"La resta es: ${a - b}\")\n}\n\nfun main() {\n    mostrarSuma(5, 3)  // La suma es: 8\n    mostrarResta(5, 3) // La resta es: 2\n}\n</code></pre> <p>Caracter\u00edsticas Kotlin:</p> <ul> <li><code>Unit</code> equivale a <code>void</code> en Java (se puede omitir)</li> <li>Sintaxis consistente con funciones</li> <li>Puede usar interpolaci\u00f3n de strings</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#java_6","title":"Java","text":"Java <pre><code>public class Procedimientos {\n    // Void indica que no retorna valor\n    static void mostrarSuma(int a, int b) {\n        System.out.println(\"La suma es: \" + (a + b));\n    }\n\n    // Tambi\u00e9n puede no tener par\u00e1metros\n    static void saludar() {\n        System.out.println(\"Hola Mundo\");\n    }\n\n    public static void main(String[] args) {\n        mostrarSuma(5, 3);  // La suma es: 8\n        saludar();          // Hola Mundo\n    }\n}\n</code></pre> <p>Diferencias Java:</p> <ul> <li>Obligatorio usar <code>void</code></li> <li>Requiere clase contenedora</li> <li>M\u00e1s verboso en impresi\u00f3n</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#python_6","title":"Python","text":"Python <pre><code># Procedimiento (sin return o con return None)\ndef mostrar_suma(a: int, b: int) -&gt; None:\n    print(f\"La suma es: {a + b}\")\n\n# Sin anotaciones de tipo (equivalente)\ndef saludar():\n    print(\"Hola Mundo\")\n\nif __name__ == \"__main__\":\n    mostrar_suma(5, 3)  # La suma es: 8\n    saludar()          # Hola Mundo\n</code></pre> <p>Notas Python:</p> <ul> <li><code>None</code> es el equivalente a <code>Unit</code>/<code>void</code></li> <li>Anotaciones de tipo opcionales</li> <li>Sintaxis minimalista</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#tabla-comparativa_4","title":"Tabla Comparativa","text":"Caracter\u00edstica Kotlin Java Python Tipo de retorno <code>Unit</code> (opcional) <code>void</code> <code>None</code> (impl\u00edcito) Sintaxis declaraci\u00f3n <code>fun nombre()</code> <code>void nombre()</code> <code>def nombre():</code> Ejecuci\u00f3n Llamada directa Llamada est\u00e1tica Llamada directa Punto de entrada <code>fun main()</code> <code>public static void main()</code> <code>if __name__ == ...</code>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#ejemplo-avanzado-efectos-secundarios","title":"Ejemplo Avanzado (Efectos Secundarios)","text":"KotlinJavaPython <pre><code>var contador = 0\n\nfun incrementar() {\n    contador++\n    println(\"Contador: $contador\")\n}\n\nfun main() {\n    repeat(3) { incrementar() }\n}\n</code></pre> <pre><code>public class Contador {\n    static int contador = 0;\n\n    static void incrementar() {\n        contador++;\n        System.out.println(\"Contador: \" + contador);\n    }\n\n    public static void main(String[] args) {\n        for(int i = 0; i &lt; 3; i++) {\n            incrementar();\n        }\n    }\n}\n</code></pre> <pre><code>contador = 0\n\ndef incrementar():\n    global contador\n    contador += 1\n    print(f\"Contador: {contador}\")\n\nif __name__ == \"__main__\":\n    for _ in range(3):\n        incrementar()\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#buenas-practicas_3","title":"Buenas Pr\u00e1cticas","text":"<ol> <li>Nombramiento:</li> <li> <p>Usar verbos para indicar acci\u00f3n (<code>mostrar...</code>, <code>imprimir...</code>, <code>actualizar...</code>)</p> </li> <li> <p>Efectos secundarios:</p> </li> <li>Limitar su uso en lo posible</li> <li> <p>Documentar claramente cuando modifican estado externo</p> </li> <li> <p>Tama\u00f1o:    <pre><code>// \u274c Demasiado largo\nfun procesarYMostrarYGuardar() { /* ... */ }\n\n// \u2705 Mejor separado\nfun procesar() { /* ... */ }\nfun mostrar() { /* ... */ }\nfun guardar() { /* ... */ }\n</code></pre></p> </li> <li> <p>Documentaci\u00f3n:    <pre><code>/**\n * Muestra el resultado de una suma en consola\n * @param a Primer sumando\n * @param b Segundo sumando\n */\n</code></pre></p> </li> </ol>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#8-parametros","title":"8. Par\u00e1metros","text":"<p>Los par\u00e1metros son variables que se pasan a una funci\u00f3n o procedimiento. Con ellos podemos modificar el comportamiento de la funci\u00f3n o procedimiento y devolver un resultado diferente. Desde el lugar donde llamamos a la funci\u00f3n se les asigna los valores a estos par\u00e1metros</p> <pre><code>// Par\u00e1metros son a y b\nfun suma(a: Int, b: Int): Int {\n    return a + b\n}\n\nfun main() {\n    // Los valores 2 y 3 se asignan a los par\u00e1metros a y b\n    println(suma(2, 3))\n}\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#81-paso-por-valor-copia-y-paso-por-referencia","title":"8.1. Paso por valor, copia y paso por referencia","text":"<ul> <li>Paso por valor:</li> </ul> <p>Se crea una copia del valor del par\u00e1metro y se pasa a la funci\u00f3n. Si se modifica el valor del par\u00e1metro dentro de la funci\u00f3n, no se modifica el valor original. Es el modelo que hemos estado utilizando hasta ahora y significa que las variables del algoritmo principal que le pasamos al subalgoritmo, no pueden ser modificadas en su valor por dicho subalgoritmo.</p>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#parametros-en-funciones","title":"Par\u00e1metros en Funciones","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#conceptos-clave_1","title":"Conceptos Clave","text":"<pre><code>graph LR\n    A[Llamada a funci\u00f3n] --&gt; B[Paso de par\u00e1metros]\n    B --&gt; C[Ejecuci\u00f3n con valores]\n    C --&gt; D[Retorno de resultado]</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#kotlin_7","title":"Kotlin","text":"Kotlin <pre><code>// Par\u00e1metros con tipo expl\u00edcito\nfun potencia(base: Int, exponente: Int): Int {\n    return Math.pow(base.toDouble(), exponente.toDouble()).toInt()\n}\n\n// Par\u00e1metro con valor por defecto\nfun saludar(nombre: String = \"Invitado\") {\n    println(\"Hola, $nombre!\")\n}\n\nfun main() {\n    // Paso posicional\n    println(\"Potencia: ${potencia(2, 3)}\") // 8\n\n    // Paso nominal (named parameters)\n    println(\"Potencia: ${potencia(base = 5, exponente = 2)}\") // 25\n\n    // Usando valor por defecto\n    saludar() // Hola, Invitado!\n}\n</code></pre> <p>Caracter\u00edsticas Kotlin:</p> <ul> <li>Tipado est\u00e1tico obligatorio</li> <li>Par\u00e1metros nombrados (<code>nombre = valor</code>)</li> <li>Valores por defecto</li> <li>Inmutables por defecto (no se pueden reasignar)</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#java_7","title":"Java","text":"Java <pre><code>public class Calculadora {\n    // Par\u00e1metros tradicionales\n    static int potencia(int base, int exponente) {\n        return (int) Math.pow(base, exponente);\n    }\n\n    // Java no soporta par\u00e1metros nombrados directamente\n    // Ni valores por defecto (se necesitan overloads)\n\n    static void saludar() {\n        saludar(\"Invitado\");\n    }\n\n    static void saludar(String nombre) {\n        System.out.println(\"Hola, \" + nombre + \"!\");\n    }\n\n    public static void main(String[] args) {\n        // Solo paso posicional\n        System.out.println(\"Potencia: \" + potencia(2, 3)); // 8\n\n        // Alternativa para par\u00e1metros nombrados (Builder Pattern)\n        saludar(); // Hola, Invitado!\n    }\n}\n</code></pre> <p>Limitaciones Java:</p> <ul> <li>No soporta par\u00e1metros nombrados nativamente</li> <li>No tiene valores por defecto</li> <li>Requiere overloads para simular funcionalidades avanzadas</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#python_7","title":"Python","text":"Python <pre><code># Par\u00e1metros con type hints (opcionales)\ndef potencia(base: int, exponente: int) -&gt; int:\n    return base ** exponente\n\n# Par\u00e1metros con valor por defecto\ndef saludar(nombre: str = \"Invitado\") -&gt; None:\n    print(f\"Hola, {nombre}!\")\n\nif __name__ == \"__main__\":\n    # Paso posicional\n    print(f\"Potencia: {potencia(2, 3)}\")  # 8\n\n    # Paso nominal\n    print(f\"Potencia: {potencia(exponente=2, base=5)}\")  # 25\n\n    # Usando valor por defecto\n    saludar()  # Hola, Invitado!\n</code></pre> <p>Ventajas Python:</p> <ul> <li>Par\u00e1metros nombrados</li> <li>Valores por defecto</li> <li>Flexibilidad en tipos (aunque hay type hints)</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#tabla-comparativa_5","title":"Tabla Comparativa","text":"Caracter\u00edstica Kotlin Java Python Tipado Est\u00e1tico (obligatorio) Est\u00e1tico (obligatorio) Din\u00e1mico (type hints opcionales) Par\u00e1metros nombrados S\u00ed No (sin librer\u00edas) S\u00ed Valores por defecto S\u00ed No S\u00ed Inmutabilidad S\u00ed (por defecto) No No"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#ejemplo-avanzado-parametros-variables","title":"Ejemplo Avanzado (Par\u00e1metros Variables)","text":"KotlinJavaPython <pre><code>fun sumar(vararg numeros: Int): Int {\n    return numeros.sum()\n}\n\nfun main() {\n    println(\"Suma: ${sumar(1, 2, 3, 4)}\") // 10\n}\n</code></pre> <pre><code>public class Calculadora {\n    static int sumar(int... numeros) {\n        int total = 0;\n        for(int n : numeros) total += n;\n        return total;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"Suma: \" + sumar(1, 2, 3, 4)); // 10\n    }\n}\n</code></pre> <pre><code>def sumar(*numeros: int) -&gt; int:\n    return sum(numeros)\n\nif __name__ == \"__main__\":\n    print(f\"Suma: {sumar(1, 2, 3, 4)}\")  # 10\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#buenas-practicas_4","title":"Buenas Pr\u00e1cticas","text":"<ol> <li> <p>Orden de par\u00e1metros:    <pre><code>// \u274c Confuso\nfun crearUsuario(edad: Int, nombre: String, esAdmin: Boolean)\n\n// \u2705 Mejor\nfun crearUsuario(nombre: String, edad: Int, esAdmin: Boolean)\n</code></pre></p> </li> <li> <p>N\u00famero de par\u00e1metros:</p> </li> <li>Ideal: 3 o menos</li> <li> <p>M\u00e1ximo aceptable: 5 (considerar usar Data Class/objeto)</p> </li> <li> <p>Documentaci\u00f3n:    <pre><code>/**\n * Calcula la potencia entre dos n\u00fameros\n * @param base N\u00famero base\n * @param exponente Potencia a elevar\n * @return Resultado de la operaci\u00f3n\n */\n</code></pre></p> </li> <li> <p>Evitar par\u00e1metros booleanos:    <pre><code>// \u274c Poco claro\nfun renderizar(modo: Boolean)\n\n// \u2705 Mejor\nfun renderizar(modo: ModoRenderizado)\n</code></pre></p> </li> <li> <p>Paso por referencia: </p> </li> </ol> <p>Se pasa la direcci\u00f3n de memoria, por lo tanto si modificamos el par\u00e1metro dentro de la funci\u00f3n, se modifica el valor original. El par\u00e1metro del subalgoritmo, es decir, las modificaciones que sufra el par\u00e1metro, se reflejan en la variable que usamos en la llamada. En pseudoc\u00f3digo reflejaremos esta situaci\u00f3n con la palabra \u201cRef\u201d. En los lenguajes actuales los tipos de datos simples pasan siempre por valor y los tipos compuestos pueden pasar por referencia. El paso por referencia se usa sobre todo cuando el subalgoritmo tiene que devolver m\u00e1s de un valor o trabajamos con objetos o estructuras de almacenamiento o colecciones, donde no es necesario indicar el Ref (lo veremos m\u00e1s adelante). OJO, en Kotlin o Java no existe Ref para indicar que un paso de par\u00e1metros se pasa por referencia, es solo una ilustraci\u00f3n did\u00e1ctica de c\u00f3mo podr\u00eda indicarse. Como se ha indicado los tipos simples pasan por valor y los compuestos (arrays, colecciones u objetos) por referencia.</p>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#paso-por-referencia-vs-valor","title":"Paso por Referencia vs Valor","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#concepto-clave","title":"Concepto Clave","text":"<pre><code>graph TD\n    A[Paso por Valor] --&gt; B[Copia del valor]\n    A --&gt; C[Modificaciones no se reflejan]\n    D[Paso por Referencia] --&gt; E[Direcci\u00f3n de memoria]\n    D --&gt; F[Modificaciones afectan original]</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#kotlin_8","title":"Kotlin","text":"Kotlin <pre><code>// Tipos simples (Int, Double, Boolean, etc.) -&gt; Paso por VALOR\nfun modificarNumero(num: Int) {\n    // num += 1  // Error: num es inmutable (siempre en Kotlin)\n    val nuevoNum = num + 1  // Solo afecta al \u00e1mbito local\n}\n\n// Tipos compuestos (Array, List, objetos) -&gt; Paso por REFERENCIA\nfun modificarArray(arr: Array&lt;Int&gt;) {\n    arr[0] = 100  // Modifica el original\n}\n\nfun main() {\n    val numero = 5\n    modificarNumero(numero)\n    println(numero)  // Sigue siendo 5\n\n    val array = arrayOf(1, 2, 3)\n    modificarArray(array)\n    println(array.contentToString())  // [100, 2, 3]\n}\n</code></pre> <p>Comportamiento en Kotlin:</p> <ul> <li>Todos los par\u00e1metros son inmutables por defecto</li> <li>Tipos primitivos: Siempre paso por valor</li> <li>Objetos y colecciones: Paso por referencia (pero la referencia es inmutable)</li> <li>Para \"simular\" paso por referencia: usar clases wrapper</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#java_8","title":"Java","text":"Java <pre><code>public class Main {\n    // Paso por valor (siempre en Java)\n    static void modificarPrimitivo(int num) {\n        num += 1;  // Solo afecta localmente\n    }\n\n    // Objetos: se pasa referencia pero es copiada\n    static void modificarArray(int[] arr) {\n        arr[0] = 100;  // Modifica el original\n    }\n\n    public static void main(String[] args) {\n        int numero = 5;\n        modificarPrimitivo(numero);\n        System.out.println(numero);  // 5\n\n        int[] array = {1, 2, 3};\n        modificarArray(array);\n        System.out.println(Arrays.toString(array));  // [100, 2, 3]\n    }\n}\n</code></pre> <p>En Java:</p> <ul> <li>Todo es paso por valor (pero las referencias a objetos se copian)</li> <li>Efecto similar a paso por referencia con objetos</li> <li>No se puede cambiar la referencia original de un objeto</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#python_8","title":"Python","text":"Python <pre><code>def modificar_primitivo(num: int):\n    num += 1  # No afecta al original\n    return num\n\ndef modificar_lista(lst: list):\n    lst[0] = 100  # Modifica el original\n\nif __name__ == \"__main__\":\n    numero = 5\n    modificar_primitivo(numero)\n    print(numero)  # 5\n\n    lista = [1, 2, 3]\n    modificar_lista(lista)\n    print(lista)  # [100, 2, 3]\n</code></pre> <p>Comportamiento Python:</p> <ul> <li>Similar a Java (todo es paso por valor de referencia)</li> <li>Tipos mutables (listas, dicts) pueden modificarse</li> <li>Tipos inmutables (int, str, tuples) no pueden modificarse</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#tabla-comparativa_6","title":"Tabla Comparativa","text":"Lenguaje Tipos Primitivos Objetos/Colecciones \u00bfMutable? Kotlin Por valor Por referencia Inmutable por defecto Java Por valor Valor de referencia Depende del tipo Python Por valor Valor de referencia Depende del tipo"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#como-simular-paso-por-referencia","title":"C\u00f3mo Simular Paso por Referencia","text":"KotlinJavaPython <pre><code>class Ref&lt;T&gt;(var value: T)\n\nfun modificar(ref: Ref&lt;Int&gt;) {\n    ref.value += 10\n}\n\nfun main() {\n    val referencia = Ref(5)\n    modificar(referencia)\n    println(referencia.value)  // 15\n}\n</code></pre> <pre><code>class MutableInt {\n    int value;\n    MutableInt(int value) { this.value = value; }\n}\n\npublic class Main {\n    static void modificar(MutableInt num) {\n        num.value += 10;\n    }\n\n    public static void main(String[] args) {\n        MutableInt num = new MutableInt(5);\n        modificar(num);\n        System.out.println(num.value);  // 15\n    }\n}\n</code></pre> <pre><code>def modificar(num):\n    num[0] += 10\n\nif __name__ == \"__main__\":\n    num = [5]  # Usamos lista como contenedor\n    modificar(num)\n    print(num[0])  # 15\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#buenas-practicas_5","title":"Buenas Pr\u00e1cticas","text":"<ol> <li>Evitar modificar par\u00e1metros:</li> <li> <p>Preferir retornar nuevos valores en lugar de modificar entradas</p> </li> <li> <p>Documentar efectos secundarios:    <pre><code>/**\n * Ordena la lista IN-PLACE (modifica el original)\n * @param lista Lista a modificar\n */\n</code></pre></p> </li> <li> <p>Usar tipos inmutables cuando sea posible:    <pre><code>fun procesar(lista: List&lt;Int&gt;): List&lt;Int&gt; { // List es interfaz inmutable\n    return lista.map { it * 2 }\n}\n</code></pre></p> </li> <li> <p>Para m\u00faltiples retornos:</p> </li> <li>Usar data classes (Kotlin)</li> <li>Tuplas (Python)</li> <li>Clases wrapper (Java)</li> </ol>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#9-ambito-de-variables","title":"9. \u00c1mbito de variables","text":"<p>El \u00e1mbito de una variable es el lugar donde se puede utilizar. Las variables pueden tener \u00e1mbito local o global. Las variables locales solo se pueden utilizar dentro de la funci\u00f3n o procedimiento donde se han declarado. Las variables globales se pueden utilizar en cualquier parte del programa. Se deben intentar no abusar de las variables globales ya que pueden provocar errores en el programa.</p>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#91-ambito-de-variables-scope","title":"9.1. \u00c1mbito de Variables (Scope)","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#conceptos-clave_2","title":"Conceptos Clave","text":"<pre><code>graph TD\n    A[\u00c1mbito] --&gt; B[Global]\n    A --&gt; C[Local]\n    C --&gt; D[Funci\u00f3n]\n    C --&gt; E[Bloque]</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#kotlin_9","title":"Kotlin","text":"Kotlin <pre><code>// Variable global (evitar en lo posible)\nvar contadorGlobal = 0\n\nfun ejemploScope() {\n    // Variable local a la funci\u00f3n\n    val localFuncion = 10\n\n    if (true) {\n        // Variable local al bloque\n        val localBloque = 20\n        println(localBloque)\n        println(localFuncion)\n        contadorGlobal++\n    }\n\n    // println(localBloque) // Error: fuera de \u00e1mbito\n}\n\nfun main() {\n    ejemploScope()\n    println(contadorGlobal) // Acceso a global\n    // println(localFuncion) // Error: no visible\n}\n</code></pre> <p>Caracter\u00edsticas Kotlin:</p> <ul> <li><code>val</code>: Inmutable (recomendado)</li> <li><code>var</code>: Mutable</li> <li>\u00c1mbito de bloque (if, when, for, etc.)</li> <li>Globales: Accesibles desde cualquier funci\u00f3n en el mismo archivo</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#java_9","title":"Java","text":"Java <pre><code>public class Ambito {\n    // Variable global (static para este ejemplo)\n    static int contadorGlobal = 0;\n\n    static void ejemploScope() {\n        int localFuncion = 10;\n\n        if (true) {\n            int localBloque = 20;\n            System.out.println(localBloque);\n            contadorGlobal++;\n        }\n\n        // System.out.println(localBloque); // Error\n    }\n\n    public static void main(String[] args) {\n        ejemploScope();\n        System.out.println(contadorGlobal);\n    }\n}\n</code></pre> <p>Diferencias Java:</p> <ul> <li>Variables deben declararse con tipo</li> <li><code>final</code> para constantes (equivalente a <code>val</code>)</li> <li>Globales deben ser <code>static</code> para este ejemplo</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#python_9","title":"Python","text":"Python <pre><code># Variable global\ncontador_global = 0\n\ndef ejemplo_scope():\n    local_funcion = 10\n\n    if True:\n        local_bloque = 20\n        print(local_bloque)\n        global contador_global\n        contador_global += 1\n\n    # print(local_bloque)  # Error si se descomenta\n\nif __name__ == \"__main__\":\n    ejemplo_scope()\n    print(contador_global)\n</code></pre> <p>Notas Python:</p> <ul> <li><code>global</code> necesario para modificar variables globales</li> <li>No hay declaraci\u00f3n de tipo por defecto</li> <li>\u00c1mbito de bloque menos estricto que Kotlin/Java</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#tabla-comparativa_7","title":"Tabla Comparativa","text":"Caracter\u00edstica Kotlin Java Python Variables globales Nivel archivo <code>static</code> en clases Nivel m\u00f3dulo Constantes <code>val</code> <code>final</code> Convenci\u00f3n (MAY\u00daSCULAS) Modificar globales Directo Directo Requiere <code>global</code> \u00c1mbito de bloque Estricto Estricto Menos estricto"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#buenas-practicas_6","title":"Buenas Pr\u00e1cticas","text":"<ol> <li> <p>Minimizar variables globales:    <pre><code>// \u274c\nvar config = loadConfig()\n\n// \u2705 Mejor\nclass ConfigProvider {\n    private val config = loadConfig()\n    fun getConfig() = config\n}\n</code></pre></p> </li> <li> <p>\u00c1mbito m\u00ednimo necesario:    <pre><code>// \u274c Demasiado amplio\nfun procesar() {\n    val db = Database()\n    // 100 l\u00edneas de c\u00f3digo...\n}\n\n// \u2705 Mejor\nfun procesar(db: Database) {\n    // Usar db\n}\n</code></pre></p> </li> <li> <p>Constantes bien definidas:    <pre><code>// \u2705\nconst val MAX_INTENTOS = 3\nprivate val PI = 3.1416\n</code></pre></p> </li> <li> <p>Evitar shadowing:    <pre><code>// \u274c Confuso\nval x = 10\nfun ejemplo() {\n    val x = 20 // Shadowing\n}\n</code></pre></p> </li> </ol>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#ejemplo-avanzado-ambito-de-extension","title":"Ejemplo Avanzado (\u00c1mbito de Extensi\u00f3n)","text":"KotlinJavaPython <pre><code>fun String.miExtension() {\n    println(this) // this est\u00e1 en \u00e1mbito aqu\u00ed\n}\n\nfun main() {\n    \"Hola\".miExtension()\n}\n</code></pre> <pre><code>public class StringUtil {\n    public static void miMetodo(String str) {\n        System.out.println(str);\n    }\n}\n</code></pre> <pre><code>class String(str):\n    def mi_metodo(self):\n        print(self)\n\ndef usar():\n    s = String(\"Hola\")\n    s.mi_metodo()\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#riesgos-comunes","title":"Riesgos Comunes","text":"<ol> <li> <p>Accidental global:    <pre><code># \u274c Python\ndef suma(a, b):\n    global resultado  # Innecesario y peligroso\n    resultado = a + b\n    return resultado\n</code></pre></p> </li> <li> <p>Contaminaci\u00f3n de \u00e1mbito:    <pre><code>// \u274c\nfun ejemplo() {\n    val lista = mutableListOf&lt;Int&gt;()\n    // ... mucha l\u00f3gica ...\n    // lista sigue en \u00e1mbito cuando ya no se necesita\n}\n</code></pre></p> </li> <li> <p>Mutable global state:    <pre><code>// \u274c Java\npublic class Config {\n    public static String ENVIRONMENT; // Peligroso\n}\n</code></pre></p> </li> </ol>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#10-recursividad","title":"10. Recursividad","text":"<p>La recursividad es una t\u00e9cnica que consiste en llamar a una funci\u00f3n o procedimiento dentro de s\u00ed mismo. La funci\u00f3n o procedimiento se llama a s\u00ed misma hasta que se cumple una condici\u00f3n que hace que la funci\u00f3n o procedimiento deje de llamarse a s\u00ed misma (condici\u00f3n de parada o salida). Es importante siempre mostrar la condici\u00f3n de parada. Muchos problemas son mucho m\u00e1s sencillos de resolver con recursividad que con iteraci\u00f3n. Por ejemplo, el c\u00e1lculo de un factorial es mucho m\u00e1s sencillo de resolver con recursividad que con iteraci\u00f3n.</p>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#101-recursividad-vs-iteracion","title":"10.1 Recursividad vs Iteraci\u00f3n","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#concepto-clave_1","title":"Concepto Clave","text":"<pre><code>graph TD\n    A[Recursividad] --&gt; B[Caso Base]\n    A --&gt; C[Llamada Recursiva]\n    D[Iteraci\u00f3n] --&gt; E[Bucles]\n    D --&gt; F[Acumuladores]</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#kotlin_10","title":"Kotlin","text":"Kotlin <pre><code>// Versi\u00f3n recursiva\nfun factorialRec(n: Int): Int {\n    require(n &gt;= 0) { \"n debe ser positivo\" }\n    return if (n &lt;= 1) 1 else n * factorialRec(n - 1)\n}\n\n// Versi\u00f3n iterativa (tailrec optimizado)\ntailrec fun factorialTailRec(n: Int, acc: Int = 1): Int {\n    return if (n &lt;= 1) acc else factorialTailRec(n - 1, acc * n)\n}\n\nfun main() {\n    println(\"Recursivo: ${factorialRec(5)}\") // 120\n    println(\"TailRec: ${factorialTailRec(5)}\") // 120\n}\n</code></pre> <p>Ventajas Kotlin:</p> <ul> <li><code>tailrec</code> optimiza recursi\u00f3n a iteraci\u00f3n (evita StackOverflow)</li> <li>Expresividad en funciones recursivas</li> <li>Chequeo de par\u00e1metros con <code>require</code></li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#java_10","title":"Java","text":"Java <pre><code>public class Factorial {\n    // Recursivo cl\u00e1sico\n    static int factorialRec(int n) {\n        if (n &lt; 0) throw new IllegalArgumentException(\"n debe ser positivo\");\n        return (n &lt;= 1) ? 1 : n * factorialRec(n - 1);\n    }\n\n    // Iterativo\n    static int factorialIter(int n) {\n        int result = 1;\n        for (int i = 2; i &lt;= n; i++) {\n            result *= i;\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"Recursivo: \" + factorialRec(5)); // 120\n        System.out.println(\"Iterativo: \" + factorialIter(5)); // 120\n    }\n}\n</code></pre> <p>Limitaciones Java:</p> <ul> <li>No tiene optimizaci\u00f3n autom\u00e1tica de tail recursion</li> <li>M\u00e1s propenso a StackOverflowError</li> <li>Sintaxis m\u00e1s verbosa</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#python_10","title":"Python","text":"Python <pre><code># Recursivo\ndef factorial_rec(n: int) -&gt; int:\n    if n &lt; 0:\n        raise ValueError(\"n debe ser positivo\")\n    return 1 if n &lt;= 1 else n * factorial_rec(n - 1)\n\n# Iterativo\ndef factorial_iter(n: int) -&gt; int:\n    result = 1\n    for i in range(2, n + 1):\n        result *= i\n    return result\n\nif __name__ == \"__main__\":\n    print(f\"Recursivo: {factorial_rec(5)}\")  # 120\n    print(f\"Iterativo: {factorial_iter(5)}\")  # 120\n</code></pre> <p>Notas Python:</p> <ul> <li>L\u00edmite de recursi\u00f3n bajo (~1000 por defecto)</li> <li>No hay optimizaci\u00f3n de tail recursion</li> <li>Sintaxis muy legible para algoritmos recursivos</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#comparacion-de-rendimiento","title":"Comparaci\u00f3n de Rendimiento","text":"Escenario Recursi\u00f3n Cl\u00e1sica Tail Recursion Iteraci\u00f3n n = 5 ~0.1ms ~0.05ms ~0.01ms n = 1000 StackOverflow ~1.2ms ~0.8ms Memoria O(n) O(1) O(1) Legibilidad Alta Media Baja"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#ejemplo-avanzado-fibonacci","title":"Ejemplo Avanzado (Fibonacci)","text":"KotlinJavaPython <pre><code>// Versi\u00f3n ineficiente (O(2^n))\nfun fibRec(n: Int): Int = when (n) {\n    0, 1 -&gt; n\n    else -&gt; fibRec(n - 1) + fibRec(n - 2)\n}\n\n// Versi\u00f3n eficiente (O(n))\ntailrec fun fibTailRec(n: Int, a: Int = 0, b: Int = 1): Int {\n    return if (n == 0) a else fibTailRec(n - 1, b, a + b)\n}\n</code></pre> <pre><code>// Versi\u00f3n ineficiente\nstatic int fibRec(int n) {\n    if (n &lt;= 1) return n;\n    return fibRec(n-1) + fibRec(n-2);\n}\n\n// Versi\u00f3n iterativa\nstatic int fibIter(int n) {\n    int a = 0, b = 1, c;\n    for (int i = 0; i &lt; n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return a;\n}\n</code></pre> <pre><code># Versi\u00f3n ineficiente\ndef fib_rec(n):\n    if n &lt;= 1:\n        return n\n    return fib_rec(n-1) + fib_rec(n-2)\n\n# Versi\u00f3n eficiente con memoization\nfrom functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef fib_memo(n):\n    if n &lt;= 1:\n        return n\n    return fib_memo(n-1) + fib_memo(n-2)\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#cuando-usar-recursion","title":"Cu\u00e1ndo Usar Recursi\u00f3n","text":"<ol> <li>Problemas recursivos por naturaleza:</li> <li>Algoritmos de divide y vencer\u00e1s</li> <li> <p>Estructuras de datos recursivas (\u00e1rboles, grafos)</p> </li> <li> <p>Ventajas:</p> </li> <li>C\u00f3digo m\u00e1s legible y expresivo</li> <li> <p>M\u00e1s f\u00e1cil de probar matem\u00e1ticamente</p> </li> <li> <p>Precauciones:</p> </li> <li>Siempre definir caso base</li> <li>Asegurar convergencia al caso base</li> <li>Para recursi\u00f3n m\u00faltiple, considerar memoization</li> </ol> <pre><code>flowchart TD\n    A[\u00bfEl problema es recursivo?] --&gt;|S\u00ed| B[Considera recursi\u00f3n]\n    A --&gt;|No| C[Usa iteraci\u00f3n]\n    B --&gt; D[\u00bfPuede ser tail recursion?]\n    D --&gt;|S\u00ed| E[Optimiza con tailrec]\n    D --&gt;|No| F[Considera l\u00edmite de stack]</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#buenas-practicas_7","title":"Buenas Pr\u00e1cticas","text":"<ol> <li>Documentar el caso base:</li> </ol> <pre><code>/**\n * Calcula factorial recursivo\n * @param n N\u00famero positivo (caso base n &lt;= 1 retorna 1)\n */\n</code></pre> <ol> <li>Validar par\u00e1metros:</li> </ol> <pre><code>require(n &gt;= 0) { \"n debe ser positivo\" }\n</code></pre> <ol> <li>Para recursi\u00f3n m\u00faltiple:</li> </ol> <pre><code>@lru_cache  # Python\nmemo = mutableMapOf&lt;Int, Int&gt;()  # Kotlin\n</code></pre> <ol> <li> <p>Alternativas:</p> </li> <li> <p>Usar iteraci\u00f3n para problemas lineales simples</p> </li> <li>Considerar tail recursion cuando sea posible</li> <li>Para problemas complejos: dividir en subproblemas</li> </ol>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#11-paquete-o-modulo","title":"11. Paquete o m\u00f3dulo","text":"<p>Un paquete o m\u00f3dulo es un conjunto de funciones y procedimientos que realizan una tarea concreta. Por ejemplo, un paquete de funciones matem\u00e1ticas, un paquete de funciones de entrada y salida, un paquete de funciones de gesti\u00f3n de arrays, etc. Usamos estos paquetes para agrupar funciones y procedimientos que realizan una tarea concreta y que podemos reutilizar en otros programas o en otras partes del mismo. Es una forma de ordenar nuestro c\u00f3digo por funcionalidades.</p>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#111-paquetes-y-modulos","title":"11.1 Paquetes y M\u00f3dulos","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#concepto-clave_2","title":"Concepto Clave","text":"<pre><code>graph TD\n    A[Organizaci\u00f3n de c\u00f3digo] --&gt; B[Paquetes]\n    A --&gt; C[M\u00f3dulos]\n    B --&gt; D[Agrupar funcionalidades relacionadas]\n    C --&gt; E[Unidades independientes de c\u00f3digo]</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#kotlin_11","title":"Kotlin","text":"Kotlin <pre><code>// Definici\u00f3n de paquete (opcional, al inicio del archivo)\npackage com.ejemplo.matematicas\n\n// Funci\u00f3n p\u00fablica (visible fuera del paquete)\nfun suma(a: Int, b: Int): Int = a + b\n\n// Funci\u00f3n interna (solo visible dentro del m\u00f3dulo)\ninternal fun resta(a: Int, b: Int): Int = a - b\n\n// Uso desde otro archivo\n/*\nimport com.ejemplo.matematicas.suma\n\nfun main() {\n    println(suma(2, 3))\n}\n*/\n</code></pre> <p>Caracter\u00edsticas Kotlin:</p> <ul> <li>Estructura jer\u00e1rquica de paquetes</li> <li>Control de visibilidad (<code>public</code>, <code>internal</code>, <code>private</code>)</li> <li>Paquetes pueden no coincidir con estructura de directorios</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#java_11","title":"Java","text":"Java <pre><code>// Definici\u00f3n de paquete (debe coincidir con estructura de directorios)\npackage com.ejemplo.matematicas;\n\npublic class Calculadora {\n    // M\u00e9todo p\u00fablico\n    public static int suma(int a, int b) {\n        return a + b;\n    }\n\n    // M\u00e9todo package-private (visible solo en el paquete)\n    static int resta(int a, int b) {\n        return a - b;\n    }\n}\n\n// Uso desde otra clase\n/*\nimport com.ejemplo.matematicas.Calculadora;\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(Calculadora.suma(2, 3));\n    }\n}\n*/\n</code></pre> <p>Diferencias Java:</p> <ul> <li>Paquetes deben coincidir con estructura de directorios</li> <li>Clases como unidades b\u00e1sicas de organizaci\u00f3n</li> <li>Visibilidad m\u00e1s granular (<code>public</code>, <code>protected</code>, <code>package-private</code>, <code>private</code>)</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#python_11","title":"Python","text":"Python <pre><code># m\u00f3dulo/matematicas.py\ndef suma(a: int, b: int) -&gt; int:\n    return a + b\n\ndef _resta(a: int, b: int) -&gt; int:  # Convenci\u00f3n para \"privado\"\n    return a - b\n\n# Uso desde otro archivo\n\"\"\"\nfrom modulo.matematicas import suma\n\nif __name__ == \"__main__\":\n    print(suma(2, 3))\n\"\"\"\n</code></pre> <p>Notas Python:</p> <ul> <li>Sistema de m\u00f3dulos basado en archivos</li> <li>Convenciones (<code>_nombre</code> para \"privado\")</li> <li>Paquetes con <code>__init__.py</code></li> <li>Importaci\u00f3n m\u00e1s flexible</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#comparativa-de-caracteristicas","title":"Comparativa de Caracter\u00edsticas","text":"Caracter\u00edstica Kotlin Java Python Unidad b\u00e1sica Archivo Clase Archivo Estructura directorios Recomendada Obligatoria Obligatoria para paquetes Visibilidad <code>public</code>, <code>internal</code>, <code>private</code> 4 niveles Convenci\u00f3n (<code>_nombre</code>) Importaci\u00f3n Flexible Estricta Muy flexible Paquetes est\u00e1ndar <code>kotlin.math</code>, etc. <code>java.util</code>, etc. <code>math</code>, <code>os</code>, etc."},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#ejemplo-de-estructura","title":"Ejemplo de Estructura","text":"Estructura de Proyecto <pre><code>proyecto/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 main/\n\u2502   \u2502   \u251c\u2500\u2500 kotlin/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 com/\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 ejemplo/\n\u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 matematicas.kt\n\u2502   \u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 util.kt\n\u2502   \u251c\u2500\u2500 java/\n\u2502   \u2502   \u251c\u2500\u2500 com/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 ejemplo/\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Calculadora.java\n\u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 Main.java\n\u2502   \u251c\u2500\u2500 python/\n\u2502   \u2502   \u251c\u2500\u2500 modulo/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 matematicas.py\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 main.py\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#buenas-practicas_8","title":"Buenas Pr\u00e1cticas","text":"<ol> <li>Nombrado de paquetes:</li> <li>Kotlin/Java: Dominio inverso (<code>com.ejemplo.miprojecto</code>)</li> <li> <p>Python: Min\u00fasculas sin espacios (<code>mi_paquete</code>)</p> </li> <li> <p>Organizaci\u00f3n:    <pre><code>// \u274c Demasiado amplio\npackage utils\n\n// \u2705 Espec\u00edfico\npackage com.ejemplo.utils.validacion\n</code></pre></p> </li> <li> <p>Visibilidad adecuada:    <pre><code>// \u274c Todo p\u00fablico\npublic class Utils { /* ... */ }\n\n// \u2705 Solo lo necesario p\u00fablico\nclass StringUtils { /* ... */ }\n</code></pre></p> </li> <li> <p>Documentaci\u00f3n:    <pre><code>/**\n * Paquete para operaciones matem\u00e1ticas b\u00e1sicas\n * Incluye funciones para c\u00e1lculo aritm\u00e9tico\n */\npackage com.ejemplo.matematicas\n</code></pre></p> </li> </ol>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#ejemplo-avanzado-multiplataforma","title":"Ejemplo Avanzado (Multiplataforma)","text":"Kotlin MultiplatformJava Modules (JPMS)Python Subpaquetes <pre><code>// commonMain/kotlin/com/ejemplo/core/\nexpect class Platform() {\n    val name: String\n}\n\n// jsMain/kotlin/com/ejemplo/core/\nactual class Platform actual constructor() {\n    actual val name = \"JavaScript\"\n}\n</code></pre> <pre><code>module com.ejemplo.matematicas {\n    exports com.ejemplo.matematicas;\n    requires java.base;\n}\n</code></pre> <pre><code># proyecto/paquete/subpaquete/__init__.py\nfrom .modulo import Clase\n\n__all__ = ['Clase']\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#gestion-de-dependencias","title":"Gesti\u00f3n de Dependencias","text":"Lenguaje Herramienta Archivo de configuraci\u00f3n Kotlin Gradle/Maven <code>build.gradle.kts</code> Java Gradle/Maven <code>pom.xml</code> Python pip/Poetry <code>requirements.txt</code>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#12-referencias","title":"12. Referencias","text":"<ul> <li>https://es.wikipedia.org/wiki/Tipo_de_dato</li> <li>https://es.wikipedia.org/wiki/Programaci%C3%B3n_estructurada</li> <li>https://es.wikipedia.org/wiki/Programaci%C3%B3n_modular</li> <li>https://es.stackoverflow.com/questions/1493/cu%C3%A1l-es-la-diferencia-entre-paso-de-variables-por-valor-y-por-referencia</li> <li>https://es.wikipedia.org/wiki/Recursi%C3%B3n</li> </ul>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/","title":"Programaci\u00f3n - 03 Aplicaci\u00f3n de Estructuras de Almacenamiento","text":"<p>Tema 03 Aplicaci\u00f3n de Estructuras de Almacenamiento. 1DAM. Curso 2025/2026.</p>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#1-arrays-unidimensionales","title":"1. Arrays unidimensionales","text":""},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#definicion","title":"\ud83d\udd0d Definici\u00f3n","text":"<p>Un array es una estructura de datos que permite almacenar un conjunto de datos contiguos del mismo tipo. Se caracterizan por tener un tama\u00f1o fijo, es decir, una vez definido el array no se puede modificar su tama\u00f1o y que su acceso de lectura y escritura se realiza mediante un \u00edndice.</p> <p>Si una variable es como un caj\u00f3n de un tama\u00f1o del tipo de dato (es decir, el identificador apunta a la zona de memoria donde se almacena el valor), un array puede verse como un conjunto de cajones (una cajonera) del mismo tama\u00f1o del tipo de dato, donde cada caj\u00f3n tiene un \u00edndice que nos permite acceder a \u00e9l. Por tanto, un array es una estructura de datos que nos permite almacenar un conjunto de datos del mismo tipo.</p> <p>En Kotlin y Java, el primer \u00edndice es el 0. Esto se debe a la forma de redireccionar de memoria que han ido heredando los lenguajes y compiladores (como en C), el primer elemento de un array se almacena en la posici\u00f3n 0. Por tanto, si tenemos un array de 10 elementos, el \u00faltimo elemento se almacena en la posici\u00f3n 9. Si nos salimos del l\u00edmite obtendremos una excepci\u00f3n (tanto si consultamos como \u00edndice un n\u00famero negativo, como si consultamos un \u00edndice mayor o igual al tama\u00f1o del array). Esta excepci\u00f3n es <code>ArrayIndexOutOfBoundsException</code>.</p> Value 7 11 6 55 98 45 16 96 46 Index 0 1 2 3 4 5 6 7 8 <p>Lower Bound = 0 Array Length = 9</p>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#definicion-de-arrays","title":"\ud83d\udcdd Definici\u00f3n de arrays","text":"KotlinJavaPython <pre><code>// Array de 10 enteros\nvar arrayEnteros = IntArray(10) // valor inicial 0\nvar arrayEnteros = intArrayOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\nvar arrayEnteros = IntArray(10) { 0 } // array de 10 enteros inicializados a 0\nvar arrayCaracteres = CharArray(10)\nvar arrayBooleanos = BooleanArray(10)\n\n// Otros tipos de arrays\nvar arrayCadenas = arrayOf(\"Hola\", \"mundo\")\nvar arrayEnteros = arrayOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n// Usando Array&lt;Tipo&gt;\nvar arrayEnteros = Array&lt;Int&gt;(10) { 0 }\nvar arrayCadenas = Array&lt;String&gt;(10) { \"\" }\n</code></pre> <pre><code>// Array de 10 enteros\nint[] arrayEnteros = new int[10]; // valor inicial 0\nint[] arrayEnteros = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\nint[] arrayEnteros = new int[10]; // todos inicializados a 0\nchar[] arrayCaracteres = new char[10];\nboolean[] arrayBooleanos = new boolean[10];\n\n// Arrays de objetos\nString[] arrayCadenas = {\"Hola\", \"mundo\"};\nString[] arrayCadenas = new String[10]; // inicializados a null\n</code></pre> <pre><code># Lista en Python (equivalente a array)\narray_enteros = [0] * 10  # lista de 10 ceros\narray_enteros = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\narray_cadenas = [\"Hola\", \"mundo\"]\n\n# Usando array module para arrays tipados\nimport array\narray_enteros = array.array('i', [1, 2, 3, 4, 5])\n</code></pre>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#recorrido","title":"\ud83d\udd04 Recorrido","text":"<p>Para recorrer un array y trabajar con \u00e9l, el \u00edndice ser\u00e1 clave. Para ello, podemos utilizar un bucle for o for-each o while, que nos permitir\u00e1 recorrer el array de principio a fin.</p> KotlinJavaPython <pre><code>fun main() {\n    val array = arrayOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n\n    // Recorrido con for indices\n    for (i in array.indices) {\n        println(array[i])\n    }\n\n    // Con reversed con indices\n    for (i in array.indices.reversed()) {\n        println(array[i])\n    }\n\n    // Con for each\n    for (i in array) {\n        println(i)\n    }\n\n    // Saltando posiciones\n    for (i in array.indices step 2) {\n        println(array[i])\n    }\n\n    // Con while\n    var i = 0\n    while (i &lt; array.size) {\n        println(array[i])\n        i++\n    }\n\n    // With index, para obtener el \u00edndice y el valor\n    for ((index, value) in array.withIndex()) {\n        println(\"El elemento $value est\u00e1 en la posici\u00f3n $index\")\n    }\n}\n</code></pre> <pre><code>public class Main {\n    public static void main(String[] args) {\n        int[] array = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\n        // Recorrido con for tradicional\n        for (int i = 0; i &lt; array.length; i++) {\n            System.out.println(array[i]);\n        }\n\n        // Recorrido inverso\n        for (int i = array.length - 1; i &gt;= 0; i--) {\n            System.out.println(array[i]);\n        }\n\n        // For-each\n        for (int elemento : array) {\n            System.out.println(elemento);\n        }\n\n        // Saltando posiciones\n        for (int i = 0; i &lt; array.length; i += 2) {\n            System.out.println(array[i]);\n        }\n\n        // Con while\n        int i = 0;\n        while (i &lt; array.length) {\n            System.out.println(array[i]);\n            i++;\n        }\n    }\n}\n</code></pre> <pre><code>def main():\n    array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n    # Recorrido con for tradicional\n    for i in range(len(array)):\n        print(array[i])\n\n    # Recorrido inverso\n    for i in range(len(array)-1, -1, -1):\n        print(array[i])\n\n    # For-each\n    for elemento in array:\n        print(elemento)\n\n    # Saltando posiciones\n    for i in range(0, len(array), 2):\n        print(array[i])\n\n    # Con while\n    i = 0\n    while i &lt; len(array):\n        print(array[i])\n        i += 1\n\n    # Con enumerate (\u00edndice y valor)\n    for indice, valor in enumerate(array):\n        print(f\"El elemento {valor} est\u00e1 en la posici\u00f3n {indice}\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#paso-por-referencia","title":"\ud83d\udce4 Paso por referencia","text":"<p>Los arrays siempre pasan por referencia en las funciones, esto quiere decir, que si modificamos un array en una funci\u00f3n, este cambio ser\u00e1 visible despu\u00e9s de ejecutar la funci\u00f3n.</p> KotlinJavaPython <pre><code>fun main() {\n    val array = arrayOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n    println(\"Array original: ${array.contentToString()}\")\n    // Modificamos el array\n    modificarArray(array)\n    println(\"Array modificado: ${array.contentToString()}\")\n}\n\nfun modificarArray(array: IntArray) {\n    array[0] = 100\n    array[1] = 200\n    array[2] = 300\n}\n</code></pre> <pre><code>public class Main {\n    public static void main(String[] args) {\n        int[] array = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n        System.out.println(\"Array original: \" + java.util.Arrays.toString(array));\n        // Modificamos el array\n        modificarArray(array);\n        System.out.println(\"Array modificado: \" + java.util.Arrays.toString(array));\n    }\n\n    public static void modificarArray(int[] array) {\n        array[0] = 100;\n        array[1] = 200;\n        array[2] = 300;\n    }\n}\n</code></pre> <pre><code>def modificar_array(array):\n    array[0] = 100\n    array[1] = 200\n    array[2] = 300\n\ndef main():\n    array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print(f\"Array original: {array}\")\n    # Modificamos el array\n    modificar_array(array)\n    print(f\"Array modificado: {array}\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#devolucion-de-arrays","title":"\ud83d\udd19 Devoluci\u00f3n de arrays","text":"<p>Para devolver un array, podemos utilizar la palabra reservada return, pero en este caso, no devolveremos el array, sino que devolveremos la referencia a la posici\u00f3n de memoria donde se encuentra el array.</p> KotlinJavaPython <pre><code>fun main() {\n    val array = arrayOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n    println(\"Array original: ${array.contentToString()}\")\n    // Modificamos el array\n    val array2 = modificarArray(array)\n    println(\"Array modified: ${array.contentToString()}\")\n    println(\"Array2 modified: ${array2.contentToString()}\")\n}\n\nfun modificarArray(array: IntArray): IntArray {\n    array[0] = 100\n    array[1] = 200\n    array[2] = 300\n    return array\n}\n</code></pre> <pre><code>public class Main {\n    public static void main(String[] args) {\n        int[] array = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n        System.out.println(\"Array original: \" + java.util.Arrays.toString(array));\n        // Modificamos el array\n        int[] array2 = modificarArray(array);\n        System.out.println(\"Array modified: \" + java.util.Arrays.toString(array));\n        System.out.println(\"Array2 modified: \" + java.util.Arrays.toString(array2));\n    }\n\n    public static int[] modificarArray(int[] array) {\n        array[0] = 100;\n        array[1] = 200;\n        array[2] = 300;\n        return array;\n    }\n}\n</code></pre> <pre><code>def modificar_array(array):\n    array[0] = 100\n    array[1] = 200\n    array[2] = 300\n    return array\n\ndef main():\n    array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print(f\"Array original: {array}\")\n    # Modificamos el array\n    array2 = modificar_array(array)\n    print(f\"Array modified: {array}\")\n    print(f\"Array2 modified: {array2}\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#identidad-vs-igualdad","title":"\u2696\ufe0f Identidad vs Igualdad","text":"<p>Uno de los problemas fundamentales en la programaci\u00f3n es la identidad y la igualdad.</p> <ul> <li>Se dice que dos objetos son id\u00e9nticos si apuntan a la misma posici\u00f3n de memoria, es decir, si son el mismo objeto.</li> <li>Se dice que dos objetos son iguales si tienen el mismo contenido, es decir, si tienen el mismo valor.</li> </ul> KotlinJavaPython <pre><code>fun main() {\n    val arrayA = arrayOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n    val arrayB = arrayOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n\n    println(\"Array A: ${arrayA.contentToString()}\")\n    println(\"Array B: ${arrayB.contentToString()}\")\n\n    // Igualdad\n    println(\"Son iguales: ${igualdad(arrayA, arrayB)}\")\n    // ==\n    println(\"Son iguales: ${arrayA == arrayB}\")\n    // contentEquals\n    println(\"Son iguales: ${arrayA.contentEquals(arrayB)}\")\n    // Identidad\n    println(\"Son id\u00e9nticos: ${arrayA === arrayB}\")\n}\n\nfun igualdad(origin: IntArray, destino: IntArray): Boolean {\n    // Early exit\n    if (origin.size != destino.size) {\n        return false\n    }\n    for (i in origin.indices) {\n        if (origin[i] != destino[i]) {\n            return false\n        }\n    }\n    return true\n}\n</code></pre> <pre><code>import java.util.Arrays;\n\npublic class Main {\n    public static void main(String[] args) {\n        int[] arrayA = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n        int[] arrayB = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\n        System.out.println(\"Array A: \" + Arrays.toString(arrayA));\n        System.out.println(\"Array B: \" + Arrays.toString(arrayB));\n\n        // Igualdad\n        System.out.println(\"Son iguales: \" + igualdad(arrayA, arrayB));\n        // Arrays.equals\n        System.out.println(\"Son iguales: \" + Arrays.equals(arrayA, arrayB));\n        // Identidad\n        System.out.println(\"Son id\u00e9nticos: \" + (arrayA == arrayB));\n    }\n\n    public static boolean igualdad(int[] origin, int[] destino) {\n        // Early exit\n        if (origin.length != destino.length) {\n            return false;\n        }\n        for (int i = 0; i &lt; origin.length; i++) {\n            if (origin[i] != destino[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n</code></pre> <pre><code>def igualdad(origin, destino):\n    # Early exit\n    if len(origin) != len(destino):\n        return False\n    for i in range(len(origin)):\n        if origin[i] != destino[i]:\n            return False\n    return True\n\ndef main():\n    arrayA = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    arrayB = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n    print(f\"Array A: {arrayA}\")\n    print(f\"Array B: {arrayB}\")\n\n    # Igualdad\n    print(f\"Son iguales: {igualdad(arrayA, arrayB)}\")\n    # ==\n    print(f\"Son iguales: {arrayA == arrayB}\")\n    # Identidad\n    print(f\"Son id\u00e9nticos: {arrayA is arrayB}\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#metodos-y-propiedades","title":"\ud83d\udccb M\u00e9todos y propiedades","text":"<p>Algunos m\u00e9todos interesantes para trabajar con arrays:</p> KotlinJavaPython <pre><code>val numeros = arrayOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n\n// tama\u00f1o\nprintln(\"Tama\u00f1o: ${numeros.size}\")\n// primer elemento\nprintln(\"Primer elemento: ${numeros.first()}\")\n// \u00faltimo elemento\nprintln(\"\u00daltimo elemento: ${numeros.last()}\")\n// a string\nprintln(\"Array a string: ${numeros.contentToString()}\")\n// a string con separador\nprintln(\"Array a string con separador: ${numeros.joinToString(\" - \")}\")\n// saber si existe en qu\u00e9 \u00edndice esta\nprintln(\"\u00cdndice del elemento 5: ${numeros.indexOf(5)}\")\n// Subarray\nprintln(\"Subarray: ${numeros.sliceArray(0..4).contentToString()}\")\n</code></pre> <pre><code>import java.util.Arrays;\n\npublic class Main {\n    public static void main(String[] args) {\n        int[] numeros = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\n        // tama\u00f1o\n        System.out.println(\"Tama\u00f1o: \" + numeros.length);\n        // primer elemento\n        System.out.println(\"Primer elemento: \" + numeros[0]);\n        // \u00faltimo elemento\n        System.out.println(\"\u00daltimo elemento: \" + numeros[numeros.length - 1]);\n        // a string\n        System.out.println(\"Array a string: \" + Arrays.toString(numeros));\n        // saber si existe en qu\u00e9 \u00edndice esta\n        int index = -1;\n        for (int i = 0; i &lt; numeros.length; i++) {\n            if (numeros[i] == 5) {\n                index = i;\n                break;\n            }\n        }\n        System.out.println(\"\u00cdndice del elemento 5: \" + index);\n        // Subarray\n        int[] subarray = Arrays.copyOfRange(numeros, 0, 5);\n        System.out.println(\"Subarray: \" + Arrays.toString(subarray));\n    }\n}\n</code></pre> <pre><code>def main():\n    numeros = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n    # tama\u00f1o\n    print(f\"Tama\u00f1o: {len(numeros)}\")\n    # primer elemento\n    print(f\"Primer elemento: {numeros[0]}\")\n    # \u00faltimo elemento\n    print(f\"\u00daltimo elemento: {numeros[-1]}\")\n    # a string\n    print(f\"Array a string: {numeros}\")\n    # a string con separador\n    print(f\"Array a string con separador: {' - '.join(map(str, numeros))}\")\n    # saber si existe en qu\u00e9 \u00edndice esta\n    try:\n        index = numeros.index(5)\n        print(f\"\u00cdndice del elemento 5: {index}\")\n    except ValueError:\n        print(\"Elemento no encontrado\")\n    # Subarray\n    subarray = numeros[0:5]\n    print(f\"Subarray: {subarray}\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#2-arrays-multidimensionales","title":"2. Arrays multidimensionales","text":"<p>Los arrays multidimensionales son arrays que contienen otros arrays, por ejemplo, un array de dos dimensiones es un array donde cada elemento es un array. Es decir, es un array de arrays. Para recorrerlo usaremos tanto \u00edndices como dimensiones tenga.</p>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#estructura","title":"\ud83d\udcca Estructura","text":"<pre><code>Columns\nColumn 1   Column 2   Column 3\n\nRow 1      111        112        113        Array 1    Arrays 6\nRow 2      121        211        212        213        Array 2\nRow 3      131        221        311        312        313        Array 3\n                    231        321        322        323\n                    331        332        333\n</code></pre>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#definicion_1","title":"\ud83d\udcdd Definici\u00f3n","text":"KotlinJavaPython <pre><code>val array = arrayOf(\n    arrayOf(1, 2, 3), \n    arrayOf(4, 5, 6), \n    arrayOf(7, 8, 9)\n)\nval array2 = arrayOfNulls&lt;Array&lt;Int&gt;&gt;(3)\nval array3 = Array(3) { IntArray(3) } // array de 3x3\n</code></pre> <pre><code>int[][] array = {\n    {1, 2, 3},\n    {4, 5, 6},\n    {7, 8, 9}\n};\nint[][] array2 = new int[3][3]; // array de 3x3\nInteger[][] array3 = new Integer[3][3]; // con nulls\n</code></pre> <pre><code># Lista de listas\narray = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\n\n# Crear array 3x3 con ceros\narray2 = [[0] * 3 for _ in range(3)]\n</code></pre>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#recorrido_1","title":"\ud83d\udd04 Recorrido","text":"<p>Necesitaremos tantos \u00edndices como dimensiones, y por lo tanto tantos bucles definidos como dimensiones.</p> KotlinJavaPython <pre><code>fun main() {\n    val array = arrayOf(\n        arrayOf(1, 2, 3),\n        arrayOf(4, 5, 6), \n        arrayOf(7, 8, 9)\n    )\n\n    // Usando \u00edndices\n    for (i in array.indices) {\n        for (j in array[i].indices) {\n            println(\"array[$i][$j] = ${array[i][j]}\")\n        }\n    }\n\n    // Con while\n    var i = 0\n    while (i &lt; array.size) {\n        var j = 0\n        while (j &lt; array[i].size) {\n            println(\"array[$i][$j] = ${array[i][j]}\")\n            j++\n        }\n        i++\n    }\n\n    // Con for each\n    for (fila in array) {\n        for (elemento in fila) {\n            println(\"element = $elemento\")\n        }\n    }\n}\n</code></pre> <pre><code>public class Main {\n    public static void main(String[] args) {\n        int[][] array = {\n            {1, 2, 3},\n            {4, 5, 6},\n            {7, 8, 9}\n        };\n\n        // Usando \u00edndices\n        for (int i = 0; i &lt; array.length; i++) {\n            for (int j = 0; j &lt; array[i].length; j++) {\n                System.out.println(\"array[\" + i + \"][\" + j + \"] = \" + array[i][j]);\n            }\n        }\n\n        // Con while\n        int i = 0;\n        while (i &lt; array.length) {\n            int j = 0;\n            while (j &lt; array[i].length) {\n                System.out.println(\"array[\" + i + \"][\" + j + \"] = \" + array[i][j]);\n                j++;\n            }\n            i++;\n        }\n\n        // Con for-each\n        for (int[] fila : array) {\n            for (int elemento : fila) {\n                System.out.println(\"element = \" + elemento);\n            }\n        }\n    }\n}\n</code></pre> <pre><code>def main():\n    array = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    # Usando \u00edndices\n    for i in range(len(array)):\n        for j in range(len(array[i])):\n            print(f\"array[{i}][{j}] = {array[i][j]}\")\n\n    # Con while\n    i = 0\n    while i &lt; len(array):\n        j = 0\n        while j &lt; len(array[i]):\n            print(f\"array[{i}][{j}] = {array[i][j]}\")\n            j += 1\n        i += 1\n\n    # Con for-each\n    for fila in array:\n        for elemento in fila:\n            print(f\"element = {elemento}\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#3-cadenas-de-caracteres-strings","title":"3. Cadenas de caracteres (Strings)","text":"<p>Una cadena es una secuencia de caracteres, es decir, una cadena es un array de caracteres. En Kotlin y Java, las cadenas son inmutables, es decir, no podemos modificar una cadena, si queremos modificar una cadena, tendremos que crear una nueva cadena.</p>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#definicion_2","title":"\ud83d\udcdd Definici\u00f3n","text":"KotlinJavaPython <pre><code>val cadena = \"Hola mundo\"\nval cadenaVacia = \"\"\nval cadenaNula: String? = null\n</code></pre> <pre><code>String cadena = \"Hola mundo\";\nString cadenaVacia = \"\";\nString cadenaNula = null;\n</code></pre> <pre><code>cadena = \"Hola mundo\"\ncadena_vacia = \"\"\ncadena_nula = None\n</code></pre>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#recorrido_2","title":"\ud83d\udd04 Recorrido","text":"KotlinJavaPython <pre><code>fun main() {\n    val cadena = \"Hola mundo\"\n\n    for (caracter in cadena) {\n        println(\"caracter = $caracter\")\n    }\n\n    // Con indices\n    for (i in cadena.indices) {\n        println(\"cadena[$i] = ${cadena[i]}\")\n    }\n}\n</code></pre> <pre><code>public class Main {\n    public static void main(String[] args) {\n        String cadena = \"Hola mundo\";\n\n        // Con for-each (convertir a char array)\n        for (char caracter : cadena.toCharArray()) {\n            System.out.println(\"caracter = \" + caracter);\n        }\n\n        // Con indices\n        for (int i = 0; i &lt; cadena.length(); i++) {\n            System.out.println(\"cadena[\" + i + \"] = \" + cadena.charAt(i));\n        }\n    }\n}\n</code></pre> <pre><code>def main():\n    cadena = \"Hola mundo\"\n\n    for caracter in cadena:\n        print(f\"caracter = {caracter}\")\n\n    # Con indices\n    for i in range(len(cadena)):\n        print(f\"cadena[{i}] = {cadena[i]}\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#metodos-y-operadores","title":"\ud83d\udee0\ufe0f M\u00e9todos y operadores","text":"KotlinJavaPython <pre><code>val cadena = \"Hola mundo\"\n\n// Longitud\nprintln(\"Longitud: ${cadena.length}\")\n// Obtener un car\u00e1cter\nprintln(\"Car\u00e1cter: ${cadena[0]}\")\n// Obtener un subcadena\nprintln(\"Subcadena: ${cadena.substring(0, 4)}\")\n// Obtener un array de caracteres\nprintln(\"Array de caracteres: ${cadena.toCharArray().contentToString()}\")\n// Obtener un array de cadenas\nprintln(\"Array de cadenas: ${cadena.split(\" \")}\")\n// Concatenaci\u00f3n\nprintln(\"Concatenaci\u00f3n: ${cadena + \"!!\"}\")\n// Comparaci\u00f3n\nprintln(\"Son iguales: ${cadena == \"Hola mundo\"}\")\n// pasar a may\u00fasculas\nprintln(\"May\u00fasculas: ${cadena.uppercase()}\")\n// pasar a min\u00fasculas\nprintln(\"Min\u00fasculas: ${cadena.lowercase()}\")\n// Contiene\nprintln(\"Contiene: ${cadena.contains(\"Hola\")}\")\n// primer elemento\nprintln(\"Primer elemento: ${cadena.first()}\")\n// \u00faltimo elemento\nprintln(\"\u00daltimo elemento: ${cadena.last()}\")\n// Eliminar espacios en blanco\nprintln(\"Eliminar espacios en blanco: ${cadena.trim()}\")\n// saber si existe en qu\u00e9 \u00edndice est\u00e1\nprintln(\"\u00cdndice: ${cadena.indexOf(\"mundo\")}\")\n// Subarray con slice\nprintln(\"Subarray: ${cadena.slice(0..4)}\")\n// reemplazar\nprintln(\"Reemplazar: ${cadena.replace(\"Hola\", \"Adi\u00f3s\")}\")\n</code></pre> <pre><code>public class Main {\n    public static void main(String[] args) {\n        String cadena = \"Hola mundo\";\n\n        // Longitud\n        System.out.println(\"Longitud: \" + cadena.length());\n        // Obtener un car\u00e1cter\n        System.out.println(\"Car\u00e1cter: \" + cadena.charAt(0));\n        // Obtener un subcadena\n        System.out.println(\"Subcadena: \" + cadena.substring(0, 4));\n        // Obtener un array de caracteres\n        System.out.println(\"Array de caracteres: \" + java.util.Arrays.toString(cadena.toCharArray()));\n        // Obtener un array de cadenas\n        System.out.println(\"Array de cadenas: \" + java.util.Arrays.toString(cadena.split(\" \")));\n        // Concatenaci\u00f3n\n        System.out.println(\"Concatenaci\u00f3n: \" + cadena + \"!!\");\n        // Comparaci\u00f3n\n        System.out.println(\"Son iguales: \" + cadena.equals(\"Hola mundo\"));\n        // pasar a may\u00fasculas\n        System.out.println(\"May\u00fasculas: \" + cadena.toUpperCase());\n        // pasar a min\u00fasculas\n        System.out.println(\"Min\u00fasculas: \" + cadena.toLowerCase());\n        // Contiene\n        System.out.println(\"Contiene: \" + cadena.contains(\"Hola\"));\n        // primer elemento\n        System.out.println(\"Primer elemento: \" + cadena.charAt(0));\n        // \u00faltimo elemento\n        System.out.println(\"\u00daltimo elemento: \" + cadena.charAt(cadena.length() - 1));\n        // Eliminar espacios en blanco\n        System.out.println(\"Eliminar espacios en blanco: \" + cadena.trim());\n        // saber si existe en qu\u00e9 \u00edndice est\u00e1\n        System.out.println(\"\u00cdndice: \" + cadena.indexOf(\"mundo\"));\n        // Subarray con substring\n        System.out.println(\"Subarray: \" + cadena.substring(0, 5));\n        // reemplazar\n        System.out.println(\"Reemplazar: \" + cadena.replace(\"Hola\", \"Adi\u00f3s\"));\n    }\n}\n</code></pre> <pre><code>def main():\n    cadena = \"Hola mundo\"\n\n    # Longitud\n    print(f\"Longitud: {len(cadena)}\")\n    # Obtener un car\u00e1cter\n    print(f\"Car\u00e1cter: {cadena[0]}\")\n    # Obtener un subcadena\n    print(f\"Subcadena: {cadena[0:4]}\")\n    # Obtener un array de caracteres\n    print(f\"Array de caracteres: {list(cadena)}\")\n    # Obtener un array de cadenas\n    print(f\"Array de cadenas: {cadena.split(' ')}\")\n    # Concatenaci\u00f3n\n    print(f\"Concatenaci\u00f3n: {cadena + '!!'}\")\n    # Comparaci\u00f3n\n    print(f\"Son iguales: {cadena == 'Hola mundo'}\")\n    # pasar a may\u00fasculas\n    print(f\"May\u00fasculas: {cadena.upper()}\")\n    # pasar a min\u00fasculas\n    print(f\"Min\u00fasculas: {cadena.lower()}\")\n    # Contiene\n    print(f\"Contiene: {'Hola' in cadena}\")\n    # primer elemento\n    print(f\"Primer elemento: {cadena[0]}\")\n    # \u00faltimo elemento\n    print(f\"\u00daltimo elemento: {cadena[-1]}\")\n    # Eliminar espacios en blanco\n    print(f\"Eliminar espacios en blanco: {cadena.strip()}\")\n    # saber si existe en qu\u00e9 \u00edndice est\u00e1\n    print(f\"\u00cdndice: {cadena.find('mundo')}\")\n    # Subarray con slice\n    print(f\"Subarray: {cadena[0:5]}\")\n    # reemplazar\n    print(f\"Reemplazar: {cadena.replace('Hola', 'Adi\u00f3s')}\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#stringbuilder","title":"\ud83d\udd27 StringBuilder","text":"<p>StringBuilder es una clase que nos permite crear cadenas de forma mutable, es decir, podemos modificarlas.</p> KotlinJavaPython <pre><code>val sb = StringBuilder()\nval sb2 = StringBuilder(\"Hola mundo\")\nsb.append(\"Hola mundo\")\nval mensaje = sb2.toString()\n</code></pre> <pre><code>StringBuilder sb = new StringBuilder();\nStringBuilder sb2 = new StringBuilder(\"Hola mundo\");\nsb.append(\"Hola mundo\");\nString mensaje = sb2.toString();\n</code></pre> <pre><code># En Python las cadenas son inmutables, pero podemos usar join o f-strings\n# Para operaciones complejas podemos usar lista y join\npartes = []\npartes.append(\"Hola\")\npartes.append(\"mundo\")\nmensaje = \" \".join(partes)\n\n# O usando f-strings\nnombre = \"mundo\"\nmensaje = f\"Hola {nombre}\"\n</code></pre>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#4-expresiones-regulares","title":"4. Expresiones regulares","text":"<p>Una expresi\u00f3n regular es una secuencia de caracteres que forma un patr\u00f3n de b\u00fasqueda, principalmente utilizada para la b\u00fasqueda de patrones de cadenas de caracteres u operaciones de sustituci\u00f3n.</p>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#definicion_3","title":"\ud83d\udcdd Definici\u00f3n","text":"KotlinJavaPython <pre><code>val regex = Regex(\"Hola\")\nval regex2 = \"\\\\d+\".toRegex()\n</code></pre> <pre><code>import java.util.regex.Pattern;\nimport java.util.regex.Matcher;\n\nPattern regex = Pattern.compile(\"Hola\");\nPattern regex2 = Pattern.compile(\"\\\\d+\");\n</code></pre> <pre><code>import re\n\nregex = re.compile(\"Hola\")\nregex2 = re.compile(r\"\\d+\")\n</code></pre>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#metodos-y-operadores_1","title":"\ud83d\udee0\ufe0f M\u00e9todos y operadores","text":"KotlinJavaPython <pre><code>val regex = Regex(\"Hola\")\n\n// Comprobar si una cadena cumple el patr\u00f3n\nprintln(\"Cumple el patr\u00f3n: ${regex.matches(\"Hola mundo\")}\")\n// Obtener un array de cadenas\nprintln(\"Array de cadenas: ${regex.split(\"Hola mundo\").contentToString()}\")\n// Reemplazar\nprintln(\"Reemplazar: ${regex.replace(\"Hola mundo\", \"Adi\u00f3s mundo\")}\")\n</code></pre> <pre><code>import java.util.regex.Pattern;\nimport java.util.regex.Matcher;\n\npublic class Main {\n    public static void main(String[] args) {\n        Pattern regex = Pattern.compile(\"Hola\");\n\n        // Comprobar si una cadena cumple el patr\u00f3n\n        Matcher matcher = regex.matcher(\"Hola mundo\");\n        System.out.println(\"Cumple el patr\u00f3n: \" + matcher.matches());\n\n        // Obtener un array de cadenas\n        String[] partes = regex.split(\"Hola mundo\");\n        System.out.println(\"Array de cadenas: \" + java.util.Arrays.toString(partes));\n\n        // Reemplazar\n        String resultado = regex.matcher(\"Hola mundo\").replaceAll(\"Adi\u00f3s mundo\");\n        System.out.println(\"Reemplazar: \" + resultado);\n    }\n}\n</code></pre> <pre><code>import re\n\ndef main():\n    regex = re.compile(\"Hola\")\n\n    # Comprobar si una cadena cumple el patr\u00f3n\n    print(f\"Cumple el patr\u00f3n: {bool(regex.match('Hola mundo'))}\")\n    # Obtener un array de cadenas\n    print(f\"Array de cadenas: {regex.split('Hola mundo')}\")\n    # Reemplazar\n    print(f\"Reemplazar: {regex.sub('Adi\u00f3s mundo', 'Hola mundo')}\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#ejemplos","title":"\ud83d\udd0d Ejemplos","text":"KotlinJavaPython <pre><code>fun main() {\n    // Solo n\u00fameros\n    val regexNum = \"\\\\d+\".toRegex()\n    println(\"Solo n\u00fameros: ${regexNum.matches(\"1234567890\")}\")\n\n    // Letras min\u00fasculas\n    val regexMin = \"[a-z]+\".toRegex()\n    println(\"Letras min\u00fasculas: ${regexMin.matches(\"abcdefghijklmn\u00f1opqrstuvwxyz\")}\")\n\n    // Letras may\u00fasculas\n    val regexMay = \"[A-Z]+\".toRegex()\n    println(\"Letras may\u00fasculas: ${regexMay.matches(\"ABCDEFGHIJKLMN\u00d1OPQRSTUVWXYZ\")}\")\n\n    // Letras min\u00fasculas y may\u00fasculas\n    val regexLetras = \"[a-zA-Z]+\".toRegex()\n    println(\"Letras min\u00fasculas y may\u00fasculas: ${regexLetras.matches(\"abcdefghijklmn\u00f1opqrstuvwxyzABCDEFGHIJKLMN\u00d1OPQRSTUVWXYZ\")}\")\n\n    // Tel\u00e9fono\n    val regexTel = \"\\\\d{9}\".toRegex()\n    println(\"Tel\u00e9fono: ${regexTel.matches(\"123456789\")}\")\n\n    // DNI\n    val regexDNI = \"\\\\d{8}[A-Z]\".toRegex()\n    println(\"DNI: ${regexDNI.matches(\"12345678A\")}\")\n\n    // Email\n    val regexEmail = \"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}\".toRegex()\n    println(\"Email: ${regexEmail.matches(\"pepe@pepilandia.com\")}\")\n\n    // URL\n    val regexURL = \"^(http|https)://[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}\".toRegex()\n    println(\"URL: ${regexURL.matches(\"http://pepilandia.com\")}\")\n\n    // Tarjeta de cr\u00e9dito\n    val regexTarjeta = \"\\\\d{4} \\\\d{4} \\\\d{4} \\\\d{4}\".toRegex()\n    println(\"Tarjeta de cr\u00e9dito: ${regexTarjeta.matches(\"1234 5678 9012 3456\")}\")\n\n    // Fecha\n    val regexFecha = \"\\\\d{2}/\\\\d{2}/\\\\d{4}\".toRegex()\n    println(\"Fecha: ${regexFecha.matches(\"01/01/2020\")}\")\n}\n</code></pre> <pre><code>import java.util.regex.Pattern;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Solo n\u00fameros\n        Pattern regexNum = Pattern.compile(\"\\\\d+\");\n        System.out.println(\"Solo n\u00fameros: \" + regexNum.matcher(\"1234567890\").matches());\n\n        // Letras min\u00fasculas\n        Pattern regexMin = Pattern.compile(\"[a-z]+\");\n        System.out.println(\"Letras min\u00fasculas: \" + regexMin.matcher(\"abcdefghijklmn\u00f1opqrstuvwxyz\").matches());\n\n        // Letras may\u00fasculas\n        Pattern regexMay = Pattern.compile(\"[A-Z]+\");\n        System.out.println(\"Letras may\u00fasculas: \" + regexMay.matcher(\"ABCDEFGHIJKLMN\u00d1OPQRSTUVWXYZ\").matches());\n\n        // Tel\u00e9fono\n        Pattern regexTel = Pattern.compile(\"\\\\d{9}\");\n        System.out.println(\"Tel\u00e9fono: \" + regexTel.matcher(\"123456789\").matches());\n\n        // DNI\n        Pattern regexDNI = Pattern.compile(\"\\\\d{8}[A-Z]\");\n        System.out.println(\"DNI: \" + regexDNI.matcher(\"12345678A\").matches());\n\n        // Email\n        Pattern regexEmail = Pattern.compile(\"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}\");\n        System.out.println(\"Email: \" + regexEmail.matcher(\"pepe@pepilandia.com\").matches());\n    }\n}\n</code></pre> <pre><code>import re\n\ndef main():\n    # Solo n\u00fameros\n    regex_num = re.compile(r\"\\d+\")\n    print(f\"Solo n\u00fameros: {bool(regex_num.match('1234567890'))}\")\n\n    # Letras min\u00fasculas\n    regex_min = re.compile(r\"[a-z]+\")\n    print(f\"Letras min\u00fasculas: {bool(regex_min.match('abcdefghijklmn\u00f1opqrstuvwxyz'))}\")\n\n    # Letras may\u00fasculas\n    regex_may = re.compile(r\"[A-Z]+\")\n    print(f\"Letras may\u00fasculas: {bool(regex_may.match('ABCDEFGHIJKLMN\u00d1OPQRSTUVWXYZ'))}\")\n\n    # Tel\u00e9fono\n    regex_tel = re.compile(r\"\\d{9}\")\n    print(f\"Tel\u00e9fono: {bool(regex_tel.match('123456789'))}\")\n\n    # DNI\n    regex_dni = re.compile(r\"\\d{8}[A-Z]\")\n    print(f\"DNI: {bool(regex_dni.match('12345678A'))}\")\n\n    # Email\n    regex_email = re.compile(r\"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}\")\n    print(f\"Email: {bool(regex_email.match('pepe@pepilandia.com'))}\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#5-metodos-de-ordenacion","title":"5. M\u00e9todos de ordenaci\u00f3n","text":"<p>Los m\u00e9todos de ordenaci\u00f3n nos permite ordenar arrays. Pero debemos tener en cuenta que dependiendo del m\u00e9todo de ordenaci\u00f3n as\u00ed ser\u00e1 su eficiencia.</p>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#burbuja","title":"\ud83d\udd34 Burbuja","text":"<p>Es un m\u00e9todo de ordenaci\u00f3n con eficiencia O(n\u00b2). Consiste en ir comparando cada elemento con el siguiente, y si el elemento actual es mayor que el siguiente, se intercambian.</p> <pre><code>6  5  3  1  8  7  2  4\n</code></pre> KotlinJavaPython <pre><code>fun burbuja(array: IntArray) {\n    var aux: Int\n    for (i in 0 until array.size) {\n        for (j in 0 until array.size - 1) {\n            if (array[j] &gt; array[j + 1]) {\n                aux = array[j]\n                array[j] = array[j + 1]\n                array[j + 1] = aux\n            }\n        }\n    }\n}\n</code></pre> <pre><code>public static void burbuja(int[] array) {\n    int aux;\n    for (int i = 0; i &lt; array.length; i++) {\n        for (int j = 0; j &lt; array.length - 1; j++) {\n            if (array[j] &gt; array[j + 1]) {\n                aux = array[j];\n                array[j] = array[j + 1];\n                array[j + 1] = aux;\n            }\n        }\n    }\n}\n</code></pre> <pre><code>def burbuja(array):\n    for i in range(len(array)):\n        for j in range(len(array) - 1):\n            if array[j] &gt; array[j + 1]:\n                array[j], array[j + 1] = array[j + 1], array[j]\n</code></pre>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#seleccion","title":"\ud83d\udd35 Selecci\u00f3n","text":"<p>El algoritmo de selecci\u00f3n tiene eficiencia O(n\u00b2). Consiste en ir buscando el elemento m\u00e1s peque\u00f1o del array y colocarlo en la primera posici\u00f3n, luego el segundo m\u00e1s peque\u00f1o y colocarlo en la segunda posici\u00f3n, y as\u00ed sucesivamente.</p> KotlinJavaPython <pre><code>fun seleccion(array: IntArray) {\n    var aux: Int\n    var min: Int\n    for (i in 0 until array.size) {\n        min = i\n        for (j in i + 1 until array.size) {\n            if (array[j] &lt; array[min]) {\n                min = j\n            }\n        }\n        aux = array[i]\n        array[i] = array[min]\n        array[min] = aux\n    }\n}\n</code></pre> <pre><code>public static void seleccion(int[] array) {\n    int aux, min;\n    for (int i = 0; i &lt; array.length; i++) {\n        min = i;\n        for (int j = i + 1; j &lt; array.length; j++) {\n            if (array[j] &lt; array[min]) {\n                min = j;\n            }\n        }\n        aux = array[i];\n        array[i] = array[min];\n        array[min] = aux;\n    }\n}\n</code></pre> <pre><code>def seleccion(array):\n    for i in range(len(array)):\n        min_idx = i\n        for j in range(i + 1, len(array)):\n            if array[j] &lt; array[min_idx]:\n                min_idx = j\n        array[i], array[min_idx] = array[min_idx], array[i]\n</code></pre>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#insercion","title":"\ud83d\udfe2 Inserci\u00f3n","text":"<p>El algoritmo de inserci\u00f3n tiene eficiencia O(n\u00b2). Inicialmente se tiene un solo elemento, que obviamente es un conjunto ordenado. Despu\u00e9s, cuando hay k elementos ordenados de menor a mayor, se toma el elemento k+1 y se compara con todos los elementos ya ordenados.</p> KotlinJavaPython <pre><code>fun insercion(array: IntArray) {\n    var aux: Int\n    var j: Int\n    for (i in 1 until array.size) {\n        aux = array[i]\n        j = i - 1\n        while (j &gt;= 0 &amp;&amp; array[j] &gt; aux) {\n            array[j + 1] = array[j]\n            j--\n        }\n        array[j + 1] = aux\n    }\n}\n</code></pre> <pre><code>public static void insercion(int[] array) {\n    int aux, j;\n    for (int i = 1; i &lt; array.length; i++) {\n        aux = array[i];\n        j = i - 1;\n        while (j &gt;= 0 &amp;&amp; array[j] &gt; aux) {\n            array[j + 1] = array[j];\n            j--;\n        }\n        array[j + 1] = aux;\n    }\n}\n</code></pre> <pre><code>def insercion(array):\n    for i in range(1, len(array)):\n        aux = array[i]\n        j = i - 1\n        while j &gt;= 0 and array[j] &gt; aux:\n            array[j + 1] = array[j]\n            j -= 1\n        array[j + 1] = aux\n</code></pre>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#shell","title":"\ud83d\udfe1 Shell","text":"<p>El algoritmo de Shell es una mejora del algoritmo de inserci\u00f3n. Su eficiencia es de O(n log n). Este m\u00e9todo consiste en ordenar los elementos de un array de forma que los elementos que est\u00e1n lejos entre s\u00ed se ordenan primero.</p> KotlinJavaPython <pre><code>fun shell(array: IntArray) {\n    var aux: Int\n    var j: Int\n    var intervalo = 1\n    while (intervalo &lt; array.size) {\n        intervalo = intervalo * 3 + 1\n    }\n    while (intervalo &gt; 0) {\n        for (i in intervalo until array.size) {\n            aux = array[i]\n            j = i\n            while (j &gt; intervalo - 1 &amp;&amp; array[j - intervalo] &gt;= aux) {\n                array[j] = array[j - intervalo]\n                j -= intervalo\n            }\n            array[j] = aux\n        }\n        intervalo = (intervalo - 1) / 3\n    }\n}\n</code></pre> <pre><code>public static void shell(int[] array) {\n    int aux, j, intervalo = 1;\n    while (intervalo &lt; array.length) {\n        intervalo = intervalo * 3 + 1;\n    }\n    while (intervalo &gt; 0) {\n        for (int i = intervalo; i &lt; array.length; i++) {\n            aux = array[i];\n            j = i;\n            while (j &gt; intervalo - 1 &amp;&amp; array[j - intervalo] &gt;= aux) {\n                array[j] = array[j - intervalo];\n                j -= intervalo;\n            }\n            array[j] = aux;\n        }\n        intervalo = (intervalo - 1) / 3;\n    }\n}\n</code></pre> <pre><code>def shell(array):\n    n = len(array)\n    intervalo = 1\n    while intervalo &lt; n:\n        intervalo = intervalo * 3 + 1\n\n    while intervalo &gt; 0:\n        for i in range(intervalo, n):\n            aux = array[i]\n            j = i\n            while j &gt;= intervalo and array[j - intervalo] &gt; aux:\n                array[j] = array[j - intervalo]\n                j -= intervalo\n            array[j] = aux\n        intervalo = (intervalo - 1) // 3\n</code></pre>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#quicksort","title":"\ud83d\udfe3 QuickSort","text":"<p>El algoritmo de quicksort es el algoritmo m\u00e1s r\u00e1pido que veremos. Su eficiencia es de O(n log n). Consiste en dividir el array en dos partes, una con los elementos menores que el pivote y otra con los elementos mayores que el pivote.</p> <p>Veamos este ejemplo de Wikipedia</p> <p>En el siguiente ejemplo se marcan el pivote y los \u00edndices i y j con las letras p, i y j respectivamente.</p> <pre><code>Comenzamos con la lista completa. El elemento pivote ser\u00e1 el 4:\n 5 - 3 - 7 - 6 - 2 - 1 - 4\n                         p\nComparamos con el 5 por la izquierda y el 1 por la derecha.\n 5 - 3 - 7 - 6 - 2 - 1 - 4 \n i                   j   p\n5 es mayor que 4 y 1 es menor. Intercambiamos:\n 1 - 3 - 7 - 6 - 2 - 5 - 4\n i                   j   p \nAvanzamos por la izquierda y la derecha:\n 1 - 3 - 7 - 6 - 2 - 5 - 4\n     i           j       p \n3 es menor que 4: avanzamos por la izquierda. 2 es menor que 4: nos mantenemos ah\u00ed.\n 1 - 3 - 7 - 6 - 2 - 5 - 4\n         i       j       p \n7 es mayor que 4 y 2 es menor: intercambiamos.\n 1 - 3 - 2 - 6 - 7 - 5 - 4\n         i       j       p \nAvanzamos por ambos lados:\n 1 - 3 - 2 - 6 - 7 - 5 - 4\n            iyj          p \nEn este momento termina el ciclo principal, porque los \u00edndices se cruzaron. Ahora intercambiamos lista[i] con lista[p] (pasos 16-18):\n 1 - 3 - 2 - 4 - 7 - 5 - 6\n             p \nAplicamos recursivamente a la sublista de la izquierda (\u00edndices 0 - 2). Tenemos lo siguiente:\n 1 - 3 - 2 \n1 es menor que 2: avanzamos por la izquierda. 3 es mayor: avanzamos por la derecha. Como se intercambiaron los \u00edndices termina el ciclo. Se intercambia lista[i] con lista[p]:\n 1 - 2 - 3 \nEl mismo procedimiento se aplicar\u00e1 a la otra sublista. Al finalizar y unir todas las sublistas queda la lista inicial ordenada en forma ascendente.\n 1 - 2 - 3 - 4 - 5 - 6 - 7\n</code></pre> KotlinJava <pre><code>fun pivote(array: IntArray, izq: Int, der: Int): Int {\n    var i = izq\n    var j = der\n    var pivote = array[izq]\n    while (i &lt; j) {\n        while (array[i] &lt;= pivote &amp;&amp; i &lt; j) {\n            i++\n        }\n        while (array[j] &gt; pivote) {\n            j--\n        }\n        if (i &lt; j) {\n            val aux = array[i]\n            array[i] = array[j]\n            array[j] = aux\n        }\n    }\n    array[izq] = array[j]\n    array[j] = pivote\n    return j\n}\n\nfun quicksort(array: IntArray, izq: Int, der: Int) {\n    var piv: Int\n    if (izq &lt; der) {\n        piv = pivote(array, izq, der)\n        quicksort(array, izq, piv - 1)\n        quicksort(array, piv + 1, der)\n    }\n}\n</code></pre> <pre><code>import java.util.Arrays;\npublic class Main {\n\n    public static int pivote(int[] array, int izq, int der) {\n        int i = izq;\n        int j = der;\n        int pivote = array[izq];\n        while (i &lt; j) {\n            while (array[i] &lt;= pivote &amp;&amp; i &lt; j) {\n                i++;\n            }\n            while (array[j] &gt; pivote) {\n                j--;\n            }\n            if (i &lt; j) {\n                int aux = array[i];\n                array[i] = array[j];\n                array[j] = aux;\n            }\n        }\n        array[izq] = array[j];\n        array[j] = pivote;\n        return j;\n    }\n\n    public static void quicksort(int[] array, int izq, int der) {\n        int piv;\n        if (izq &lt; der) {\n            piv = pivote(array, izq, der);\n            quicksort(array, izq, piv - 1);\n            quicksort(array, piv + 1, der);\n        }\n    }\n\n    public static void main(String[] args) {\n       int[] vector = {5, 3, 7, 6, 2, 1, 4};\n        quicksort(vector, 0, vector.length - 1);\n        System.out.println(Arrays.toString(vector));\n\n    }\n}\n</code></pre> Python <pre><code>def pivote(array, izq, der):\n    i = izq\n    j = der\n    pivote = array[izq]\n    while i &lt; j:\n        while array[i] &lt;= pivote and i &lt; j:\n            i += 1\n        while array[j] &gt; pivote:\n            j -= 1\n        if i &lt; j:\n            array[i], array[j] = array[j], array[i]\n    array[izq] = array[j]\n    array[j] = pivote\n    return j\n\ndef quicksort(array, izq, der):\n    if izq &lt; der:\n        piv = pivote(array, izq, der)\n        quicksort(array, izq, piv - 1)\n        quicksort(array, piv + 1, der)\n</code></pre>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#6-metodos-de-busqueda","title":"6. M\u00e9todos de b\u00fasqueda","text":"<p>Los m\u00e9todos de b\u00fasqueda nos servir\u00e1n para encontrar un elemento en un array.</p>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#busqueda-secuencial","title":"\ud83d\udd0d B\u00fasqueda secuencial","text":"<p>La b\u00fasqueda secuencial o lineal consiste en recorrer el vector hasta devolver el elemento buscado. Su eficiencia es de O(n).</p> <pre><code>0  1  2  3  4  5  6  7  8  9  10\n| I | N | F | O | R | M | A | T | I | C | A |\n| M | M | M | M | M | M | M | INDICE=5 |\n</code></pre> KotlinJavaPython <pre><code>fun busquedaSecuencial(array: IntArray, elemento: Int): Int {\n    for (i in array.indices) {\n        if (array[i] == elemento) {\n            return i\n        }\n    }\n    return -1\n}\n</code></pre> <pre><code>public static int busquedaSecuencial(int[] array, int elemento) {\n    for (int i = 0; i &lt; array.length; i++) {\n        if (array[i] == elemento) {\n            return i;\n        }\n    }\n    return -1;\n}\n</code></pre> <pre><code>def busqueda_secuencial(array, elemento):\n    for i in range(len(array)):\n        if array[i] == elemento:\n            return i\n    return -1\n</code></pre>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#busqueda-binaria","title":"\ud83d\udd0e B\u00fasqueda binaria","text":"<p>En la b\u00fasqueda binaria partimos de un array ordenado. Su eficiencia es de O(log n). Se compara el dato buscado con el elemento en el centro del vector.</p> <p>Definici\u00f3n de Wikipedia</p> <p>Elemento buscado: 12</p> <pre><code>izq = 1   medio = 4   der = 7\n(=(izq+der)/2)\n\n12 &gt; v[medio] = 4\n\nCogemos el subvector derecho\nizq = 5   medio = 6   der = 7\n(=medio+1)   (=(izq+der)/2)\n\n12 &lt; v[medio] = 13\n\nCogemos el subvector izquierdo\nizq = 5   medio = 5   der = 5\n(=(izq+der)/2)   (=medio-1)\n(antes de modificar medio)\n\n12 = v[medio] = 12\n\nENCONTRADO\n</code></pre> KotlinJavaPython <pre><code>// Versi\u00f3n Iterativa\nfun busquedaBinariaIterativa(array: IntArray, elemento: Int): Int {\n    var centro: Int\n    var inf = 0\n    var sup = array.size - 1\n    while (inf &lt;= sup) {\n        centro = (sup + inf) / 2\n        if (array[centro] == elemento) {\n            return centro\n        } else if (elemento &lt; array[centro]) {\n            sup = centro - 1\n        } else {\n            inf = centro + 1\n        }\n    }\n    return -1\n}\n\n// Versi\u00f3n recursiva\nfun busquedaBinariaRecursiva(array: IntArray, elemento: Int, inf: Int, sup: Int): Int {\n    if (inf &gt; sup) {\n        return -1\n    }\n    val centro = (sup + inf) / 2\n    return if (array[centro] == elemento) {\n        centro\n    } else if (elemento &lt; array[centro]) {\n        busquedaBinariaRecursiva(array, elemento, inf, centro - 1)\n    } else {\n        busquedaBinariaRecursiva(array, elemento, centro + 1, sup)\n    }\n}\n</code></pre> <pre><code>// Versi\u00f3n Iterativa\npublic static int busquedaBinariaIterativa(int[] array, int elemento) {\n    int centro, inf = 0, sup = array.length - 1;\n    while (inf &lt;= sup) {\n        centro = (sup + inf) / 2;\n        if (array[centro] == elemento) {\n            return centro;\n        } else if (elemento &lt; array[centro]) {\n            sup = centro - 1;\n        } else {\n            inf = centro + 1;\n        }\n    }\n    return -1;\n}\n\n// Versi\u00f3n recursiva\npublic static int busquedaBinariaRecursiva(int[] array, int elemento, int inf, int sup) {\n    if (inf &gt; sup) {\n        return -1;\n    }\n    int centro = (sup + inf) / 2;\n    if (array[centro] == elemento) {\n        return centro;\n    } else if (elemento &lt; array[centro]) {\n        return busquedaBinariaRecursiva(array, elemento, inf, centro - 1);\n    } else {\n        return busquedaBinariaRecursiva(array, elemento, centro + 1, sup);\n    }\n}\n</code></pre> <pre><code># Versi\u00f3n Iterativa\ndef busqueda_binaria_iterativa(array, elemento):\n    inf = 0\n    sup = len(array) - 1\n    while inf &lt;= sup:\n        centro = (sup + inf) // 2\n        if array[centro] == elemento:\n            return centro\n        elif elemento &lt; array[centro]:\n            sup = centro - 1\n        else:\n            inf = centro + 1\n    return -1\n\n# Versi\u00f3n recursiva\ndef busqueda_binaria_recursiva(array, elemento, inf, sup):\n    if inf &gt; sup:\n        return -1\n    centro = (sup + inf) // 2\n    if array[centro] == elemento:\n        return centro\n    elif elemento &lt; array[centro]:\n        return busqueda_binaria_recursiva(array, elemento, inf, centro - 1)\n    else:\n        return busqueda_binaria_recursiva(array, elemento, centro + 1, sup)\n</code></pre>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#7-nulabilidad","title":"7. Nulabilidad","text":"<p>En determinados lenguajes de programaci\u00f3n existe el concepto de variable nula, es decir, una variable que no tiene valor (no apunta a ninguna zona de memoria o dicha zona no tiene valor).</p> KotlinJavaPython <pre><code>// En Kotlin, todas las variables son no nulas por defecto\nvar numero: Int? = null\n\n// Comprobar nulabilidad\nval nombre: String? = null\nprintln(nombre?.length)  // Safe call\n\n// Operador Elvis\nval longitud = nombre?.length ?: 0\n\n// Operador !! (peligroso)\n// val longitud = nombre!!.length  // Lanza excepci\u00f3n si es null\n\n// Ejemplo pr\u00e1ctico\nvar numero: Int? = null\ndo {\n    print(\"Introduce un n\u00famero: \")\n    numero = readln().toIntOrNull()\n} while (numero == null)\nprintln(\"N\u00famero introducido: $numero\")\n\n// Arrays de componentes nulas\nval array = arrayOfNulls&lt;Int&gt;(10)\nval otro: Array&lt;Int?&gt; = arrayOfNulls(10)\n</code></pre> <pre><code>// En Java, los objetos pueden ser null\nInteger numero = null;\nString nombre = null;\n\n// Comprobar nulabilidad\nif (nombre != null) {\n    System.out.println(nombre.length());\n}\n\n// Operador ternario (similar a Elvis)\nint longitud = (nombre != null) ? nombre.length() : 0;\n\n// Ejemplo pr\u00e1ctico\nInteger numero = null;\nScanner scanner = new Scanner(System.in);\ndo {\n    System.out.print(\"Introduce un n\u00famero: \");\n    try {\n        numero = Integer.parseInt(scanner.nextLine());\n    } catch (NumberFormatException e) {\n        numero = null;\n    }\n} while (numero == null);\nSystem.out.println(\"N\u00famero introducido: \" + numero);\n\n// Arrays de objetos (pueden ser null)\nInteger[] array = new Integer[10];  // Todos null inicialmente\nString[] otro = new String[10];     // Todos null inicialmente\n</code></pre> <pre><code># En Python, None es el equivalente a null\nnumero = None\nnombre = None\n\n# Comprobar nulabilidad\nif nombre is not None:\n    print(len(nombre))\n\n# Operador ternario (similar a Elvis)\nlongitud = len(nombre) if nombre is not None else 0\n\n# Ejemplo pr\u00e1ctico\nnumero = None\nwhile numero is None:\n    try:\n        entrada = input(\"Introduce un n\u00famero: \")\n        numero = int(entrada)\n    except ValueError:\n        numero = None\n        print(\"Por favor, introduce un n\u00famero v\u00e1lido\")\nprint(f\"N\u00famero introducido: {numero}\")\n\n# Listas pueden contener None\narray = [None] * 10\notro = [1, None, 3, None, 5]\n</code></pre>"},{"location":"Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28B%C3%A1sico%29/Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Base%20y%20Avanzado%29/","title":"Programaci\u00f3n - 04 y 05 Programaci\u00f3n Orientada a Objetos (Base y Avanzado)","text":""},{"location":"Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28B%C3%A1sico%29/Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Base%20y%20Avanzado%29/#programacion-orientada-a-objetos","title":"Programaci\u00f3n Orientada a Objetos","text":"<p>La programaci\u00f3n orientada a objetos es un paradigma de programaci\u00f3n que se basa en el concepto de objetos, los cuales contienen informaci\u00f3n en forma de campos (atributos o propiedades) y c\u00f3digo en forma de m\u00e9todos.</p> <pre><code>    graph TB\n        A[POO] --&gt; B[Objetos]\n        A --&gt; C[Clases]\n        A --&gt; D[Encapsulaci\u00f3n]\n        A --&gt; E[Herencia]\n        A --&gt; F[Polimorfismo]\n        A --&gt; G[Abstracci\u00f3n]\n\n        B --&gt; B1[Estado]\n        B --&gt; B2[Comportamiento]\n        B --&gt; B3[Identidad]\n\n        C --&gt; C1[Plantilla]\n        C --&gt; C2[Instancias]</code></pre>"},{"location":"Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28B%C3%A1sico%29/Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Base%20y%20Avanzado%29/#clases","title":"Clases","text":"<p>Una clase es un modelo o plantilla para crear objetos. Una clase define el estado en base a propiedades y el comportamiento en base a los m\u00e9todos de un objeto.</p> KotlinJavaPython <pre><code>// Definiendo una clase\nclass Persona {\n// Estado del objeto\nvar nombre: String = \"\"\nvar apellidos: String = \"\"\n\n// Comportamiento del objeto\nfun programar(lenguaje: String) {\n    println(\"Programando en $lenguaje\")\n    }\n}\n</code></pre> <pre><code>// Definiendo una clase\npublic class Persona {\n// Estado del objeto\nprivate String nombre = \"\";\nprivate String apellidos = \"\";\n\n// Comportamiento del objeto\npublic void programar(String lenguaje) {\n    System.out.println(\"Programando en \" + lenguaje);\n}\n\n// Getters y setters\npublic String getNombre() { return nombre; }\npublic void setNombre(String nombre) { this.nombre = nombre; }\npublic String getApellidos() { return apellidos; }\npublic void setApellidos(String apellidos) { this.apellidos = apellidos; \n}\n}\n</code></pre> <pre><code># Definiendo una clase\nclass Persona:\ndef **init**(self):\n# Estado del objeto\nself.nombre = \"\"\nself.apellidos = \"\"\n\n# Comportamiento del objeto\ndef programar(self, lenguaje):\n    print(f\"Programando en {lenguaje}\")\n</code></pre>"},{"location":"Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28B%C3%A1sico%29/Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Base%20y%20Avanzado%29/#objetos","title":"Objetos","text":"<p>Un objeto es una entidad que tiene un estado y un comportamiento. El estado de un objeto es almacenado en campos (atributos) y el comportamiento es mostrado por m\u00e9todos (funciones).</p> KotlinJavaPython <pre><code>// Llamando a un objeto \nval persona = Persona() \npersona.nombre = \"Jos\u00e9 Luis\" \npersona.apellidos = \"Gonz\u00e1lez S\u00e1nchez\" \npersona.programar(lenguaje = \"Kotlin\")\n</code></pre> <pre><code>// Llamando a un objeto \nPersona persona = new Persona(); \npersona.setNombre(\"Jos\u00e9 Luis\"); \npersona.setApellidos(\"Gonz\u00e1lez S\u00e1nchez\"); \npersona.programar(\"Java\")\n</code></pre> <pre><code># Llamando a un objeto \npersona = Persona() \npersona.nombre = \"Jos\u00e9 Luis\" \npersona.apellidos = \"Gonz\u00e1lez S\u00e1nchez\" \npersona.programar(\"Python\")\n</code></pre>"},{"location":"Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28B%C3%A1sico%29/Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Base%20y%20Avanzado%29/#creacion-e-instanciacion-de-objetos","title":"Creaci\u00f3n e Instanciaci\u00f3n de Objetos","text":"<p>La instanciaci\u00f3n de objetos es el proceso de crear un objeto a partir de una clase.</p> KotlinJavaPython <pre><code>// Instanciando un objeto \nval persona = Persona() \npersona.nombre = \"Jos\u00e9 Luis\" \npersona.programar(lenguaje = \"Kotlin\")\n</code></pre> <pre><code>// Instanciando un objeto \nPersona persona = new Persona(); \npersona.setNombre(\"Jos\u00e9 Luis\"); \npersona.programar(\"Java\");\n</code></pre> <pre><code># Instanciando un objeto \npersona = Persona() \npersona.nombre = \"Jos\u00e9 Luis\" \npersona.programar(\"Python\")\n</code></pre>"},{"location":"Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28B%C3%A1sico%29/Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Base%20y%20Avanzado%29/#propiedades-y-metodos","title":"Propiedades y m\u00e9todos","text":"<p>Los atributos definen el estado de un objeto. Los m\u00e9todos definen el comportamiento de un objeto.</p> KotlinJavaPython <pre><code>class Persona {\nvar nombre: String = \"\"\nvar apellidos: String = \"\"\nprivate var experiencia: Int = 99\n\n    fun programar(lenguaje: String) {\n        println(\"Programando en $lenguaje\")\n    }\n\n    private fun dormir() {\n        println(\"Durmiendo...\")\n    }\n}\n</code></pre> <pre><code>public class Persona {\npublic String nombre = \"\";\npublic String apellidos = \"\";\nprivate int experiencia = 99;\n\n\n    public void programar(String lenguaje) {\n        System.out.println(\"Programando en \" + lenguaje);\n    }\n\n    private void dormir() {\n        System.out.println(\"Durmiendo...\");\n    }\n}\n</code></pre> <pre><code>class Persona:\ndef **init**(self):\nself.nombre = \"\"\nself.apellidos = \"\"\nself._experiencia = 99\n\n    def programar(self, lenguaje):\n        print(f\"Programando en {lenguaje}\")\n\n    def _dormir(self):\n        print(\"Durmiendo...\")\n</code></pre>"},{"location":"Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28B%C3%A1sico%29/Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Base%20y%20Avanzado%29/#constructores-e-instanciadores","title":"Constructores e instanciadores","text":""},{"location":"Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28B%C3%A1sico%29/Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Base%20y%20Avanzado%29/#constructores","title":"Constructores","text":"<p>Los constructores son m\u00e9todos especiales que se utilizan para inicializar los objetos.</p> KotlinJavaPython <pre><code>class Persona(val nombre: String, val apellidos: String, var experiencia: Int = 0) {\nvar direccion: String = \"\"\nprivate val nivel: Int = 0\n\n    // Constructor secundario\n    constructor(nombre: String, apellidos: String, experiencia: Int, nivel: Int, direccion: String) : \n            this(nombre, apellidos, experiencia) {\n        this.direccion = direccion\n    }\n\n    init {\n        println(\"Inicializando instancia\")\n    }\n\n    fun programar(lenguaje: String) {\n        println(\"Programando en $lenguaje\")\n    }\n}\n</code></pre> <pre><code>public class Persona {\n    private final String nombre;\n    private final String apellidos;\n    private int experiencia;\n    private String direccion;\n    private final int nivel;\n\n    // Constructor primario\n    public Persona(String nombre, String apellidos, int experiencia) {\n        this.nombre = nombre;\n        this.apellidos = apellidos;\n        this.experiencia = experiencia;\n        this.nivel = 0;\n        this.direccion = \"\";\n        System.out.println(\"Inicializando instancia\");\n    }\n\n    // Constructor secundario\n    public Persona(String nombre, String apellidos, int experiencia, int nivel, String direccion) {\n        this(nombre, apellidos, experiencia);\n        this.nivel = nivel;\n        this.direccion = direccion;\n    }\n\n    public void programar(String lenguaje) {\n        System.out.println(\"Programando en \" + lenguaje);\n    }\n}\n</code></pre> <pre><code>class Persona:\ndef **init**(self, nombre, apellidos, experiencia=0, nivel=0, direccion=\"\"):\nself.nombre = nombre\nself.apellidos = apellidos\nself.experiencia = experiencia\nself.direccion = direccion\nself._nivel = nivel\nprint(\"Inicializando instancia\")\n\n\n    def programar(self, lenguaje):\n        print(f\"Programando en {lenguaje}\")\n</code></pre>"},{"location":"Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28B%C3%A1sico%29/Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Base%20y%20Avanzado%29/#referencia-this","title":"Referencia this","text":"<p>La referencia this es una referencia al objeto actual.</p> KotlinJavaPython <pre><code>class Persona(val nombre: String, val apellidos: String, var experiencia: Int = 0) \n{ \n    fun setExperiencia(experiencia: Int) \n    { \n        this.experiencia = experiencia \n        }\n\n}\n</code></pre> <pre><code>public class Persona {\n    private String nombre;\n    private String apellidos;\n    private int experiencia;\n\n    public Persona(String nombre, String apellidos, int experiencia) {\n        this.nombre = nombre;\n        this.apellidos = apellidos;\n        this.experiencia = experiencia;\n    }\n\n    public void setExperiencia(int experiencia) {\n        this.experiencia = experiencia;\n    }\n}\n</code></pre> <pre><code>class Persona:\ndef **init**(self, nombre, apellidos, experiencia=0):\nself.nombre = nombre\nself.apellidos = apellidos\nself.experiencia = experiencia\n\n    def set_experiencia(self, experiencia):\n        self.experiencia = experiencia\n</code></pre>"},{"location":"Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28B%C3%A1sico%29/Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Base%20y%20Avanzado%29/#getters-y-setters","title":"Getters y Setters","text":"<p>Los getters y setters son m\u00e9todos especiales que se utilizan para acceder/cambiar a los atributos de un objeto.</p> KotlinJavaPython <pre><code>class Persona {\n    var nombre: String = \"\"\n    var apellidos: String = \"\"\n    private var _maxEnergy: Int = 99\n\n    // Campo calculado\n    val nombreCompleto: String\n        get() = \"$nombre $apellidos\"\n\n    // Campo con almacenamiento personalizado\n    var maxEnergy: Int\n        get() = _maxEnergy\n        set(value) {\n            if (value &gt;= 0) {\n                _maxEnergy = value\n            } else {\n                _maxEnergy = 0\n            }\n        }\n}\n</code></pre> <pre><code>public class Persona {\n    private String nombre = \"\";\n    private String apellidos = \"\";\n    private int maxEnergy = 99;\n\n    // Campo calculado\n    public String getNombreCompleto() {\n        return nombre + \" \" + apellidos;\n    }\n\n    public int getMaxEnergy() {\n        return maxEnergy;\n    }\n\n    public void setMaxEnergy(int value) {\n        if (value &gt;= 0) {\n            this.maxEnergy = value;\n        } else {\n            this.maxEnergy = 0;\n        }\n    }\n}\n</code></pre> <pre><code>class Persona:\n    def **init**(self):\n    self.nombre = \"\"\n    self.apellidos = \"\"\n    self._max_energy = 99\n\n    @property\n    def nombre_completo(self):\n        return f\"{self.nombre} {self.apellidos}\"\n\n    @property\n    def max_energy(self):\n        return self._max_energy\n\n    @max_energy.setter\n    def max_energy(self, value):\n        if value &gt;= 0:\n            self._max_energy = value\n        else:\n            self._max_energy = 0\n</code></pre>"},{"location":"Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28B%C3%A1sico%29/Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Base%20y%20Avanzado%29/#igualdad-e-identidad","title":"Igualdad e identidad","text":"<p>Para comparar objetos, debemos utilizar el operador <code>==</code> para comparar el contenido y <code>===</code> para comparar la identidad.</p> KotlinJavaPython <pre><code>data class Persona(val nombre: String, val apellidos: String, var experiencia: Int)\n\nval persona1 = Persona(\"Juan\", \"P\u00e9rez\", 99)\nval persona2 = Persona(\"Juan\", \"P\u00e9rez\", 99)\nval persona3 = persona1\n\nprintln(persona1 == persona2)  // true\nprintln(persona1 === persona2) // false\nprintln(persona1 === persona3) // true\n</code></pre> <pre><code>import java.util.Objects;\n\npublic class Persona {\n    private String nombre;\n    private String apellidos;\n    private int experiencia;\n\n    // Constructor, getters, setters...\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Persona persona = (Persona) o;\n        return experiencia == persona.experiencia &amp;&amp; \n            Objects.equals(nombre, persona.nombre) &amp;&amp; \n            Objects.equals(apellidos, persona.apellidos);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(nombre, apellidos, experiencia);\n    }\n}\n\n// Uso\nPersona persona1 = new Persona(\"Juan\", \"P\u00e9rez\", 99);\nPersona persona2 = new Persona(\"Juan\", \"P\u00e9rez\", 99);\nPersona persona3 = persona1;\n\nSystem.out.println(persona1.equals(persona2)); // true\nSystem.out.println(persona1 == persona2);      // false\nSystem.out.println(persona1 == persona3);      // true\n</code></pre> <pre><code>class Persona:\ndef **init**(self, nombre, apellidos, experiencia):\nself.nombre = nombre\nself.apellidos = apellidos\nself.experiencia = experiencia\n\n    def __eq__(self, other):\n        if not isinstance(other, Persona):\n            return False\n        return (self.nombre == other.nombre and \n                self.apellidos == other.apellidos and \n                self.experiencia == other.experiencia)\n\n    def __hash__(self):\n        return hash((self.nombre, self.apellidos, self.experiencia))\n\n# Uso\npersona1 = Persona(\"Juan\", \"P\u00e9rez\", 99)\npersona2 = Persona(\"Juan\", \"P\u00e9rez\", 99)\npersona3 = persona1\n\nprint(persona1 == persona2)  # True\nprint(persona1 is persona2)  # False\nprint(persona1 is persona3)  # True\n</code></pre>"},{"location":"Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28B%C3%A1sico%29/Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Base%20y%20Avanzado%29/#representacion-de-objetos-como-cadenas","title":"Representaci\u00f3n de objetos como cadenas","text":"<p>El m\u00e9todo <code>toString</code> se utiliza para representar un objeto como una cadena.</p> KotlinJavaPython <pre><code>class Persona(val nombre: String, val apellidos: String, var experiencia: Int) {\noverride fun toString(): String {\nreturn \"Persona(nombre=$nombre, apellidos=$apellidos, experiencia=$experiencia)\"\n}\n}\n\nval persona = Persona(\"Juan\", \"P\u00e9rez\", 10)\nprintln(persona) // Persona(nombre=Juan, apellidos=P\u00e9rez, experiencia=10)\n</code></pre> <pre><code>public class Persona {\nprivate String nombre;\nprivate String apellidos;\nprivate int experiencia;\n\n// Constructor, getters, setters...\n\n    @Override\n    public String toString() {\n        return \"Persona{\" +\n            \"nombre='\" + nombre + '\\'' +\n            \", apellidos='\" + apellidos + '\\'' +\n            \", experiencia=\" + experiencia +\n            '}';\n    }\n}\n\nPersona persona = new Persona(\"Juan\", \"P\u00e9rez\", 10);\nSystem.out.println(persona); // Persona{nombre='Juan', apellidos='P\u00e9rez', experiencia=10}\n</code></pre> <pre><code>class Persona:\ndef **init**(self, nombre, apellidos, experiencia):\nself.nombre = nombre\nself.apellidos = apellidos\nself.experiencia = experiencia\n\n    def __str__(self):\n        return f\"Persona(nombre={self.nombre}, apellidos={self.apellidos}, experiencia={self.experiencia})\"\n\n    def __repr__(self):\n        return self.__str__()\n\npersona = Persona(\"Juan\", \"P\u00e9rez\", 10)\nprint(persona)  # Persona(nombre=Juan, apellidos=P\u00e9rez, experiencia=10)\n</code></pre>"},{"location":"Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28B%C3%A1sico%29/Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Base%20y%20Avanzado%29/#introduccion-a-las-excepciones","title":"Introducci\u00f3n a las Excepciones","text":"<p>Las excepciones son errores que se producen durante la ejecuci\u00f3n de un programa.</p> KotlinJavaPython <pre><code>// Manejo de excepciones\ntry {\nval resultado = 10 / 0\n} catch (e: ArithmeticException) {\nprintln(\"Error: ${e.message}\")\n} finally {\nprintln(\"Bloque finally\")\n}\n\n// Lanzar excepciones\nfun dividir(a: Int, b: Int): Int {\n    require(b != 0) { \"No se puede dividir por cero\" }\n    return a / b\n}\n\n// Validar estado\nfun validarEstado(energia: Int) {\n    check(energia &gt;= 0) { \"La energ\u00eda no puede ser negativa\" }\n}\n</code></pre> <pre><code>// Manejo de excepciones\ntry {\nint resultado = 10 / 0;\n} catch (ArithmeticException e) {\nSystem.out.println(\"Error: \" + e.getMessage());\n} finally {\nSystem.out.println(\"Bloque finally\");\n}\n\n// Lanzar excepciones\npublic int dividir(int a, int b) {\n    if (b == 0) {\n        throw new IllegalArgumentException(\"No se puede dividir por cero\");\n    }\n    return a / b;\n}\n\n// Validar argumentos\npublic void setEnergia(int energia) {\n    if (energia &lt; 0) {\n        throw new IllegalStateException(\"La energ\u00eda no puede ser negativa\");\n    }\n    this.energia = energia;\n}\n</code></pre> <pre><code># Manejo de excepciones\ntry:\nresultado = 10 / 0\nexcept ZeroDivisionError as e:\nprint(f\"Error: {e}\")\nfinally:\nprint(\"Bloque finally\")\n\n# Lanzar excepciones\ndef dividir(a, b):\n    if b == 0:\n        raise ValueError(\"No se puede dividir por cero\")\n    return a / b\n\n# Validar argumentos\ndef set_energia(self, energia):\n    if energia &lt; 0:\n        raise ValueError(\"La energ\u00eda no puede ser negativa\")\n    self._energia = energia\n</code></pre>"},{"location":"Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28B%C3%A1sico%29/Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Base%20y%20Avanzado%29/#data-classes-pojos-y-pokos","title":"Data classes: POJOS y POKOS","text":"<p>Los POJOS (Plain Old Java Objects) y POKOS (Plain Old Kotlin Objects) son objetos simples que no tienen l\u00f3gica de negocio compleja.</p> KotlinJavaPython <pre><code>data class Persona(val nombre: String, val apellidos: String, var experiencia: Int)\n\nval persona1 = Persona(\"Juan\", \"P\u00e9rez\", 99)\nval persona2 = persona1.copy(nombre = \"Pepe\")\n\n// Desestructuraci\u00f3n\nval (nombre, apellidos, experiencia) = persona1\nprintln(\"$nombre $apellidos tiene $experiencia a\u00f1os de experiencia\")\n</code></pre> <pre><code>// Java 14+ Records\npublic record Persona(String nombre, String apellidos, int experiencia) {}\n\n// O con clase tradicional\npublic class Persona {\n    private final String nombre;\n    private final String apellidos;\n    private final int experiencia;\n\n    public Persona(String nombre, String apellidos, int experiencia) {\n        this.nombre = nombre;\n        this.apellidos = apellidos;\n        this.experiencia = experiencia;\n    }\n\n    // Getters, equals, hashCode, toString...\n}\n\nPersona persona1 = new Persona(\"Juan\", \"P\u00e9rez\", 99);\n</code></pre> <pre><code>from dataclasses import dataclass\nfrom typing import Any\n\n@dataclass\nclass Persona:\n    nombre: str\n    apellidos: str\n    experiencia: int\n\npersona1 = Persona(\"Juan\", \"P\u00e9rez\", 99)\npersona2 = Persona(\"Juan\", \"P\u00e9rez\", 99)\n\n# Desestructuraci\u00f3n (Python 3.7+)\nnombre, apellidos, experiencia = persona1.nombre, persona1.apellidos, persona1.experiencia\nprint(f\"{nombre} {apellidos} tiene {experiencia} a\u00f1os de experiencia\")\n</code></pre>"},{"location":"Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28B%C3%A1sico%29/Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Base%20y%20Avanzado%29/#atributos-y-metodos-de-clase","title":"Atributos y m\u00e9todos de clase","text":"<p>Los atributos y m\u00e9todos de clase se asocian a la clase misma, no a las instancias.</p> KotlinJavaPython <pre><code>class Persona(val nombre: String, val apellidos: String, var experiencia: Int) {\nval id = Persona.nextId()\n\n    companion object {\n        private var contador = 0\n\n        private fun nextId(): Int {\n            return contador++\n        }\n\n        fun gritar() {\n            println(\"\u00a1Gritando!\")\n        }\n    }\n}\n\nPersona.gritar()\n</code></pre> <pre><code>public class Persona {\nprivate static int contador = 0;\nprivate final int id;\nprivate String nombre;\nprivate String apellidos;\nprivate int experiencia;\n\n    public Persona(String nombre, String apellidos, int experiencia) {\n        this.id = nextId();\n        this.nombre = nombre;\n        this.apellidos = apellidos;\n        this.experiencia = experiencia;\n    }\n\n    private static int nextId() {\n        return contador++;\n    }\n\n    public static void gritar() {\n        System.out.println(\"\u00a1Gritando!\");\n    }\n}\n\nPersona.gritar();\n</code></pre> <pre><code>class Persona:\ncontador = 0\n\n    def __init__(self, nombre, apellidos, experiencia):\n        self.id = Persona.next_id()\n        self.nombre = nombre\n        self.apellidos = apellidos\n        self.experiencia = experiencia\n\n    @classmethod\n    def next_id(cls):\n        cls.contador += 1\n        return cls.contador\n\n    @staticmethod\n    def gritar():\n        print(\"\u00a1Gritando!\")\n\nPersona.gritar()\n</code></pre>"},{"location":"Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28B%C3%A1sico%29/Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Base%20y%20Avanzado%29/#enums-class","title":"Enums class","text":"<p>Los tipos enumerados son una forma de definir un conjunto de constantes.</p> KotlinJavaPython <pre><code>enum class Color(val rgb: Int) {\nROJO(0xFF0000),\nVERDE(0x00FF00),\nAZUL(0x0000FF);\n\n    fun descripcion(): String {\n        return when (this) {\n            ROJO -&gt; \"Color rojo\"\n            VERDE -&gt; \"Color verde\"\n            AZUL -&gt; \"Color azul\"\n        }\n    }\n}\n\nprintln(Color.ROJO.rgb) // 16711680\nprintln(Color.ROJO.descripcion()) // Color rojo\n</code></pre> <pre><code>public enum Color {\nROJO(0xFF0000),\nVERDE(0x00FF00),\nAZUL(0x0000FF);\n\n    private final int rgb;\n\n    Color(int rgb) {\n        this.rgb = rgb;\n    }\n\n    public int getRgb() {\n        return rgb;\n    }\n\n    public String getDescripcion() {\n        switch (this) {\n            case ROJO: return \"Color rojo\";\n            case VERDE: return \"Color verde\";\n            case AZUL: return \"Color azul\";\n            default: return \"Color desconocido\";\n        }\n    }\n}\n\nSystem.out.println(Color.ROJO.getRgb()); // 16711680\nSystem.out.println(Color.ROJO.getDescripcion()); // Color rojo\n</code></pre> <pre><code>from enum import Enum\n\nclass Color(Enum):\n    ROJO = 0xFF0000\n    VERDE = 0x00FF00\n    AZUL = 0x0000FF\n\n    def descripcion(self):\n        if self == Color.ROJO:\n            return \"Color rojo\"\n        elif self == Color.VERDE:\n            return \"Color verde\"\n        elif self == Color.AZUL:\n            return \"Color azul\"\n        return \"Color desconocido\"\n\nprint(Color.ROJO.value)  # 16711680\nprint(Color.ROJO.descripcion())  # Color rojo\n</code></pre>"},{"location":"Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28B%C3%A1sico%29/Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Base%20y%20Avanzado%29/#paquetes-y-visibilidad","title":"Paquetes y visibilidad","text":"<p>Los paquetes son un mecanismo para organizar el c\u00f3digo fuente y controlar la visibilidad.</p> KotlinJavaPython <pre><code>package com.ejemplo.personas\n\nclass Persona(private val nombre: String, internal val apellidos: String, protected val edad: Int) {\n    public fun getNombre(): String = nombre\n}\n</code></pre> <pre><code>package com.ejemplo.personas;\n\npublic class Persona {\n    private String nombre;\n    String apellidos; // package-private\n    protected int edad;\n\n    public Persona(String nombre, String apellidos, int edad) {\n        this.nombre = nombre;\n        this.apellidos = apellidos;\n        this.edad = edad;\n    }\n\n    public String getNombre() {\n        return nombre;\n    }\n}\n</code></pre> <pre><code># En Python la visibilidad es por convenci\u00f3n\nclass Persona:\ndef **init**(self, nombre, apellidos, edad):\nself._nombre = nombre # protected por convenci\u00f3n\nself.apellidos = apellidos # public\nself.__edad = edad # private (name mangling)\n\n    def get_nombre(self):\n        return self._nombre\n\n    def _metodo_protected(self):\n        pass\n\n    def __metodo_private(self):\n        pass\n</code></pre>"},{"location":"Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28B%C3%A1sico%29/Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Base%20y%20Avanzado%29/#composicion-de-objetos","title":"Composici\u00f3n de objetos","text":"<p>La composici\u00f3n de objetos es una forma de reutilizar c\u00f3digo creando clases que contienen objetos de otras clases.</p> KotlinJavaPython <pre><code>data class Motor(val tipo: String, val potencia: Int)\ndata class Rueda(val diametro: Int, val presion: Double)\n\nclass Coche(val marca: String, val modelo: String, val motor: Motor, val ruedas: List&lt;Rueda&gt;) {\n    fun arrancar() {\n        println(\"Coche $marca $modelo arrancado con motor ${motor.tipo}\")\n    }\n}\n\nval motor = Motor(\"Gasolina\", 150)\nval ruedas = listOf(Rueda(17, 2.5), Rueda(17, 2.5), Rueda(17, 2.5), Rueda(17, 2.5))\nval coche = Coche(\"Seat\", \"Ibiza\", motor, ruedas)\ncoche.arrancar()\n</code></pre> <pre><code>public class Motor {\nprivate String tipo;\nprivate int potencia;\n\n    public Motor(String tipo, int potencia) {\n        this.tipo = tipo;\n        this.potencia = potencia;\n    }\n\n    // Getters y setters...\n}\n\npublic class Rueda {\n    private int diametro;\n    private double presion;\n\n    public Rueda(int diametro, double presion) {\n        this.diametro = diametro;\n        this.presion = presion;\n    }\n\n    // Getters y setters...\n}\n\npublic class Coche {\n    private String marca;\n    private String modelo;\n    private Motor motor;\n    private List&lt;Rueda&gt; ruedas;\n\n    public Coche(String marca, String modelo, Motor motor, List&lt;Rueda&gt; ruedas) {\n        this.marca = marca;\n        this.modelo = modelo;\n        this.motor = motor;\n        this.ruedas = ruedas;\n    }\n\n    public void arrancar() {\n        System.out.println(\"Coche \" + marca + \" \" + modelo + \" arrancado con motor \" + motor.getTipo());\n    }\n}\n</code></pre> <pre><code>from typing import List\n\nclass Motor:\n    def __init__(self, tipo, potencia):\n        self.tipo = tipo\n        self.potencia = potencia\n\nclass Rueda:\n    def __init__(self, diametro, presion):\n        self.diametro = diametro\n        self.presion = presion\n\nclass Coche:\n    def __init__(self, marca, modelo, motor, ruedas):\n        self.marca = marca\n        self.modelo = modelo\n        self.motor = motor\n        self.ruedas = ruedas\n\n    def arrancar(self):\n        print(f\"Coche {self.marca} {self.modelo} arrancado con motor {self.motor.tipo}\")\n\nmotor = Motor(\"Gasolina\", 150)\nruedas = [Rueda(17, 2.5) for _ in range(4)]\ncoche = Coche(\"Seat\", \"Ibiza\", motor, ruedas)\ncoche.arrancar()\n</code></pre>"},{"location":"Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28B%C3%A1sico%29/Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Base%20y%20Avanzado%29/#clases-internas-y-anidadas","title":"Clases internas y anidadas","text":"<p>Las clases internas son clases que se definen dentro de otras clases.</p> KotlinJavaPython <pre><code>class Persona(val nombre: String, val apellidos: String) {\n// Clase interna - puede acceder a propiedades de la clase exterior\ninner class Coche(val marca: String, val modelo: String) {\nfun mostrar() {\nprintln(\"Coche de $nombre: $marca $modelo\")\n}\n}\n\n    // Clase anidada - no puede acceder a propiedades de la clase exterior\n    class Direccion(val calle: String, val ciudad: String)\n}\n\nval persona = Persona(\"Juan\", \"P\u00e9rez\")\nval coche = persona.Coche(\"Renault\", \"Megane\")\ncoche.mostrar()\n\nval direccion = Persona.Direccion(\"Calle Falsa 123\", \"Madrid\")\n</code></pre> <pre><code>public class Persona {\nprivate String nombre;\nprivate String apellidos;\n\n\n    public Persona(String nombre, String apellidos) {\n        this.nombre = nombre;\n        this.apellidos = apellidos;\n    }\n\n    // Clase interna - puede acceder a propiedades de la clase exterior\n    public class Coche {\n        private String marca;\n        private String modelo;\n\n        public Coche(String marca, String modelo) {\n            this.marca = marca;\n            this.modelo = modelo;\n        }\n\n        public void mostrar() {\n            System.out.println(\"Coche de \" + nombre + \": \" + marca + \" \" + modelo);\n        }\n    }\n\n    // Clase anidada est\u00e1tica - no puede acceder a propiedades de la clase exterior\n    public static class Direccion {\n        private String calle;\n        private String ciudad;\n\n        public Direccion(String calle, String ciudad) {\n            this.calle = calle;\n            this.ciudad = ciudad;\n        }\n    }\n}\n\nPersona persona = new Persona(\"Juan\", \"P\u00e9rez\");\nPersona.Coche coche = persona.new Coche(\"Renault\", \"Megane\");\ncoche.mostrar();\n\nPersona.Direccion direccion = new Persona.Direccion(\"Calle Falsa 123\", \"Madrid\");\n</code></pre> <pre><code>class Persona:\ndef **init**(self, nombre, apellidos):\nself.nombre = nombre\nself.apellidos = apellidos\n\n    class Coche:\n        def __init__(self, persona, marca, modelo):\n            self.persona = persona\n            self.marca = marca\n            self.modelo = modelo\n\n        def mostrar(self):\n            print(f\"Coche de {self.persona.nombre}: {self.marca} {self.modelo}\")\n\n    class Direccion:\n        def __init__(self, calle, ciudad):\n            self.calle = calle\n            self.ciudad = ciudad\n\npersona = Persona(\"Juan\", \"P\u00e9rez\")\ncoche = Persona.Coche(persona, \"Renault\", \"Megane\")\ncoche.mostrar()\n\ndireccion = Persona.Direccion(\"Calle Falsa 123\", \"Madrid\")\n</code></pre>"},{"location":"Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28B%C3%A1sico%29/Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Base%20y%20Avanzado%29/#inyeccion-de-dependencias","title":"Inyecci\u00f3n de dependencias","text":"<p>La inyecci\u00f3n de dependencias es un patr\u00f3n de dise\u00f1o que permite desacoplar componentes.</p> KotlinJavaPython <pre><code>interface Motor {\nfun arrancar()\nfun parar()\n}\n\nclass MotorGasolina : Motor {\n    override fun arrancar() = println(\"Motor gasolina arrancado\")\n    override fun parar() = println(\"Motor gasolina parado\")\n}\n\nclass Coche(private val motor: Motor) {\n    fun conducir() {\n        motor.arrancar()\n        println(\"Coche en movimiento\")\n    }\n}\n\nval motor = MotorGasolina()\nval coche = Coche(motor) // Inyecci\u00f3n de dependencia\ncoche.conducir()\n</code></pre> <pre><code>public interface Motor {\nvoid arrancar();\nvoid parar();\n}\n\npublic class MotorGasolina implements Motor {\n    @Override\n    public void arrancar() {\n        System.out.println(\"Motor gasolina arrancado\");\n    }\n\n    @Override\n    public void parar() {\n        System.out.println(\"Motor gasolina parado\");\n    }\n}\n\npublic class Coche {\n    private final Motor motor;\n\n    // Inyecci\u00f3n por constructor\n    public Coche(Motor motor) {\n        this.motor = motor;\n    }\n\n    public void conducir() {\n        motor.arrancar();\n        System.out.println(\"Coche en movimiento\");\n    }\n}\n\nMotor motor = new MotorGasolina();\nCoche coche = new Coche(motor); // Inyecci\u00f3n de dependencia\ncoche.conducir();\n</code></pre> <pre><code>from abc import ABC, abstractmethod\n\n\nclass Motor(ABC):\n    @abstractmethod\n    def arrancar(self):\n        pass\n\n    @abstractmethod\n    def parar(self):\n        pass\n\nclass MotorGasolina(Motor):\n    def arrancar(self):\n        print(\"Motor gasolina arrancado\")\n\n    def parar(self):\n        print(\"Motor gasolina parado\")\n\nclass Coche:\n    def __init__(self, motor: Motor):\n        self.motor = motor  # Inyecci\u00f3n de dependencia\n\n    def conducir(self):\n        self.motor.arrancar()\n        print(\"Coche en movimiento\")\n\nmotor = MotorGasolina()\ncoche = Coche(motor)\ncoche.conducir()\n</code></pre>"},{"location":"Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28B%C3%A1sico%29/Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Base%20y%20Avanzado%29/#singleton","title":"Singleton","text":"<p>El patr\u00f3n singleton garantiza que una clase tenga solo una instancia.</p> KotlinJavaPython <pre><code>object Configuracion {\nvar lenguaje: String = \"es\"\nvar tema: String = \"oscuro\"\n\nfun mostrarConfig() {\n        println(\"Lenguaje: $lenguaje, Tema: $tema\")\n    }\n}\n\nConfiguracion.mostrarConfig()\nConfiguracion.lenguaje = \"en\"\n</code></pre> <pre><code>public class Configuracion {\nprivate static Configuracion instancia;\nprivate String lenguaje = \"es\";\nprivate String tema = \"oscuro\";\n\nprivate Configuracion() {}\n\n    public static Configuracion getInstancia() {\n        if (instancia == null) {\n            instancia = new Configuracion();\n        }\n        return instancia;\n    }\n\n    public void mostrarConfig() {\n        System.out.println(\"Lenguaje: \" + lenguaje + \", Tema: \" + tema);\n    }\n\n    // Getters y setters...\n}\n\nConfiguracion config = Configuracion.getInstancia();\nconfig.mostrarConfig();\n</code></pre> <pre><code>class Configuracion:\n_instancia = None\n\n    def __new__(cls):\n        if cls._instancia is None:\n            cls._instancia = super().__new__(cls)\n            cls._instancia.lenguaje = \"es\"\n            cls._instancia.tema = \"oscuro\"\n        return cls._instancia\n\n    def mostrar_config(self):\n        print(f\"Lenguaje: {self.lenguaje}, Tema: {self.tema}\")\n\nconfig = Configuracion()\nconfig.mostrar_config()\n</code></pre>"},{"location":"Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28B%C3%A1sico%29/Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Base%20y%20Avanzado%29/#factory","title":"Factory","text":"<p>El patr\u00f3n factory proporciona una interfaz para crear objetos.</p> KotlinJavaPython <pre><code>interface Vehiculo {\nfun conducir()\n}\n\nclass Coche : Vehiculo {\n    override fun conducir() = println(\"Conduciendo coche\")\n}\n\nclass Moto : Vehiculo {\n    override fun conducir() = println(\"Conduciendo moto\")\n}\n\nobject VehiculoFactory {\n    fun crearVehiculo(tipo: String): Vehiculo {\n        return when (tipo) {\n            \"coche\" -&gt; Coche()\n            \"moto\" -&gt; Moto()\n            else -&gt; throw IllegalArgumentException(\"Tipo desconocido: $tipo\")\n        }\n    }\n}\n\nval vehiculo = VehiculoFactory.crearVehiculo(\"coche\")\nvehiculo.conducir()\n</code></pre> <pre><code>public interface Vehiculo {\nvoid conducir();\n}\n\npublic class Coche implements Vehiculo {\n    @Override\n    public void conducir() {\n        System.out.println(\"Conduciendo coche\");\n    }\n}\n\npublic class Moto implements Vehiculo {\n    @Override\n    public void conducir() {\n        System.out.println(\"Conduciendo moto\");\n    }\n}\n\npublic class VehiculoFactory {\n    public static Vehiculo crearVehiculo(String tipo) {\n        switch (tipo) {\n            case \"coche\": return new Coche();\n            case \"moto\": return new Moto();\n            default: throw new IllegalArgumentException(\"Tipo desconocido: \" + tipo);\n        }\n    }\n}\n\nVehiculo vehiculo = VehiculoFactory.crearVehiculo(\"coche\");\nvehiculo.conducir();\n</code></pre> <pre><code>from abc import ABC, abstractmethod\n\nclass Vehiculo(ABC):\n    @abstractmethod\n    def conducir(self):\n        pass\n\nclass Coche(Vehiculo):\n    def conducir(self):\n        print(\"Conduciendo coche\")\n\nclass Moto(Vehiculo):\n    def conducir(self):\n        print(\"Conduciendo moto\")\n\nclass VehiculoFactory:\n    @staticmethod\n    def crear_vehiculo(tipo):\n        if tipo == \"coche\":\n            return Coche()\n        elif tipo == \"moto\":\n            return Moto()\n        else:\n            raise ValueError(f\"Tipo desconocido: {tipo}\")\n\nvehiculo = VehiculoFactory.crear_vehiculo(\"coche\")\nvehiculo.conducir()\n</code></pre>"},{"location":"Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28B%C3%A1sico%29/Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Base%20y%20Avanzado%29/#fachada","title":"Fachada","text":"<p>El patr\u00f3n fachada proporciona una interfaz simplificada a un sistema complejo.</p> KotlinJavaPython <pre><code>class SubsistemaA {\nfun operacionA() = println(\"Operaci\u00f3n A\")\n}\n\nclass SubsistemaB {\n    fun operacionB() = println(\"Operaci\u00f3n B\")\n}\n\nclass SubsistemaC {\n    fun operacionC() = println(\"Operaci\u00f3n C\")\n}\n\nclass Fachada {\n    private val subsistemaA = SubsistemaA()\n    private val subsistemaB = SubsistemaB()\n    private val subsistemaC = SubsistemaC()\n\n    fun operacionCompleja() {\n        subsistemaA.operacionA()\n        subsistemaB.operacionB()\n        subsistemaC.operacionC()\n    }\n}\n\nval fachada = Fachada()\nfachada.operacionCompleja()\n</code></pre> <pre><code>public class SubsistemaA {\npublic void operacionA() {\nSystem.out.println(\"Operaci\u00f3n A\");\n}\n}\n\n\npublic class SubsistemaB {\n    public void operacionB() {\n        System.out.println(\"Operaci\u00f3n B\");\n    }\n}\n\npublic class SubsistemaC {\n    public void operacionC() {\n        System.out.println(\"Operaci\u00f3n C\");\n    }\n}\n\npublic class Fachada {\n    private SubsistemaA subsistemaA;\n    private SubsistemaB subsistemaB;\n    private SubsistemaC subsistemaC;\n\n    public Fachada() {\n        this.subsistemaA = new SubsistemaA();\n        this.subsistemaB = new SubsistemaB();\n        this.subsistemaC = new SubsistemaC();\n    }\n\n    public void operacionCompleja() {\n        subsistemaA.operacionA();\n        subsistemaB.operacionB();\n        subsistemaC.operacionC();\n    }\n}\n\nFachada fachada = new Fachada();\nfachada.operacionCompleja();\n</code></pre> <pre><code>class SubsistemaA:\ndef operacion_a(self):\nprint(\"Operaci\u00f3n A\")\n\n\nclass SubsistemaB:\n    def operacion_b(self):\n        print(\"Operaci\u00f3n B\")\n\nclass SubsistemaC:\n    def operacion_c(self):\n        print(\"Operaci\u00f3n C\")\n\nclass Fachada:\n    def __init__(self):\n        self.subsistema_a = SubsistemaA()\n        self.subsistema_b = SubsistemaB()\n        self.subsistema_c = SubsistemaC()\n\n    def operacion_compleja(self):\n        self.subsistema_a.operacion_a()\n        self.subsistema_b.operacion_b()\n        self.subsistema_c.operacion_c()\n\nfachada = Fachada()\nfachada.operacion_compleja()\n</code></pre>"},{"location":"Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28B%C3%A1sico%29/Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Base%20y%20Avanzado%29/#herencia","title":"Herencia","text":"<p>La herencia permite crear nuevas clases a partir de clases existentes.</p> KotlinJavaPython <pre><code>open class Vehiculo(val marca: String, val modelo: String) {\nopen fun arrancar() {\nprintln(\"$marca $modelo arrancando...\")\n}\n\n    open fun parar() {\n        println(\"$marca $modelo parando...\")\n    }\n}\n\nclass Coche(marca: String, modelo: String, val numPuertas: Int) : Vehiculo(marca, modelo) {\n    override fun arrancar() {\n        super.arrancar()\n        println(\"Coche con $numPuertas puertas\")\n    }\n}\n\nclass Moto(marca: String, modelo: String, val cilindrada: Int) : Vehiculo(marca, modelo) {\n    override fun arrancar() {\n        println(\"Moto $marca $modelo de $cilindrada cc arrancando...\")\n    }\n}\n\nval coche = Coche(\"Toyota\", \"Corolla\", 4)\ncoche.arrancar()\n</code></pre> <pre><code>public class Vehiculo {\nprotected String marca;\nprotected String modelo;\n\n\n    public Vehiculo(String marca, String modelo) {\n        this.marca = marca;\n        this.modelo = modelo;\n    }\n\n    public void arrancar() {\n        System.out.println(marca + \" \" + modelo + \" arrancando...\");\n    }\n\n    public void parar() {\n        System.out.println(marca + \" \" + modelo + \" parando...\");\n    }\n}\n\npublic class Coche extends Vehiculo {\n    private int numPuertas;\n\n    public Coche(String marca, String modelo, int numPuertas) {\n        super(marca, modelo);\n        this.numPuertas = numPuertas;\n    }\n\n    @Override\n    public void arrancar() {\n        super.arrancar();\n        System.out.println(\"Coche con \" + numPuertas + \" puertas\");\n    }\n}\n\npublic class Moto extends Vehiculo {\n    private int cilindrada;\n\n    public Moto(String marca, String modelo, int cilindrada) {\n        super(marca, modelo);\n        this.cilindrada = cilindrada;\n    }\n\n    @Override\n    public void arrancar() {\n        System.out.println(\"Moto \" + marca + \" \" + modelo + \" de \" + cilindrada + \" cc arrancando...\");\n    }\n}\n\nCoche coche = new Coche(\"Toyota\", \"Corolla\", 4);\ncoche.arrancar();\n</code></pre> <pre><code>class Vehiculo:\ndef **init**(self, marca, modelo):\nself.marca = marca\nself.modelo = modelo\n\n    def arrancar(self):\n        print(f\"{self.marca} {self.modelo} arrancando...\")\n\n    def parar(self):\n        print(f\"{self.marca} {self.modelo} parando...\")\n\nclass Coche(Vehiculo):\n    def __init__(self, marca, modelo, num_puertas):\n        super().__init__(marca, modelo)\n        self.num_puertas = num_puertas\n\n    def arrancar(self):\n        super().arrancar()\n        print(f\"Coche con {self.num_puertas} puertas\")\n\nclass Moto(Vehiculo):\n    def __init__(self, marca, modelo, cilindrada):\n        super().__init__(marca, modelo)\n        self.cilindrada = cilindrada\n\n    def arrancar(self):\n        print(f\"Moto {self.marca} {self.modelo} de {self.cilindrada} cc arrancando...\")\n\ncoche = Coche(\"Toyota\", \"Corolla\", 4)\ncoche.arrancar()\n</code></pre>"},{"location":"Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28B%C3%A1sico%29/Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Base%20y%20Avanzado%29/#modificadores-de-acceso","title":"Modificadores de acceso","text":"<p>Los modificadores de acceso controlan la visibilidad de clases, m\u00e9todos y propiedades.</p> Modificador Kotlin Java Python P\u00fablico (por defecto) <code>public</code> (por defecto) Privado <code>private</code> <code>private</code> <code>__</code> (name mangling) Protegido <code>protected</code> <code>protected</code> <code>_</code> (convenci\u00f3n) Paquete <code>internal</code> (por defecto) N/A"},{"location":"Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28B%C3%A1sico%29/Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Base%20y%20Avanzado%29/#polimorfismo","title":"Polimorfismo","text":"<p>El polimorfismo permite que una referencia de tipo padre pueda apuntar a objetos de tipo hijo.</p> KotlinJavaPython <pre><code>open class Animal {\nopen fun hacerSonido() {\nprintln(\"Sonido gen\u00e9rico de animal\")\n}\n}\n\nclass Perro : Animal() {\n    override fun hacerSonido() {\n        println(\"Guau guau!\")\n    }\n}\n\nclass Gato : Animal() {\n    override fun hacerSonido() {\n        println(\"Miau miau!\")\n    }\n}\n\nfun hacerSonidoAnimal(animal: Animal) {\n    animal.hacerSonido()\n}\n\nval animales = listOf(Perro(), Gato(), Animal())\nanimales.forEach { hacerSonidoAnimal(it) }\n</code></pre> <pre><code>public class Animal {\npublic void hacerSonido() {\nSystem.out.println(\"Sonido gen\u00e9rico de animal\");\n}\n}\n\npublic class Perro extends Animal {\n    @Override\n    public void hacerSonido() {\n        System.out.println(\"Guau guau!\");\n    }\n}\n\npublic class Gato extends Animal {\n    @Override\n    public void hacerSonido() {\n        System.out.println(\"Miau miau!\");\n    }\n}\n\npublic class Main {\n    public static void hacerSonidoAnimal(Animal animal) {\n        animal.hacerSonido();\n    }\n\n    public static void main(String[] args) {\n        List&lt;Animal&gt; animales = Arrays.asList(new Perro(), new Gato(), new Animal());\n        animales.forEach(Main::hacerSonidoAnimal);\n    }\n}\n</code></pre> <pre><code>class Animal:\ndef hacer_sonido(self):\nprint(\"Sonido gen\u00e9rico de animal\")\n\nclass Perro(Animal):\n    def hacer_sonido(self):\n        print(\"Guau guau!\")\n\nclass Gato(Animal):\n    def hacer_sonido(self):\n        print(\"Miau miau!\")\n\ndef hacer_sonido_animal(animal):\n    animal.hacer_sonido()\n\nanimales = [Perro(), Gato(), Animal()]\nfor animal in animales:\n    hacer_sonido_animal(animal)\n</code></pre>"},{"location":"Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28B%C3%A1sico%29/Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Base%20y%20Avanzado%29/#interfaces","title":"Interfaces","text":"<p>Las interfaces definen un contrato que las clases deben implementar.</p> KotlinJava <pre><code>interface Volador {\nfun volar()\nfun aterrizar() {\nprintln(\"Aterrizando...\")\n}\n}\n\ninterface Nadador {\n    fun nadar()\n}\n\nclass Pato : Volador, Nadador {\n    override fun volar() {\n        println(\"Pato volando\")\n    }\n\n    override fun nadar() {\n        println(\"Pato nadando\")\n    }\n}\n\nval pato = Pato()\npato.volar()\npato.nadar()\npato.aterrizar()\n</code></pre> <pre><code>public interface Volador {\nvoid volar();\n\n    default void aterrizar() {\n        System.out.println(\"Aterrizando...\");\n    }\n}\n\npublic interface Nadador {\n    void nadar();\n}\n\npublic class Pato implements Volador, Nadador {\n    @Override\n    public void volar() {\n        System.out.println(\"Pato volando\");\n    }\n\n    @Override\n    public void nadar() {\n        System.out.println(\"Pato nadando\");\n    }\n}\n\nPato pato = new Pato();\npato.volar();\npato.nadar();\npato.aterrizar();\n</code></pre> Python <pre><code>    from abc import ABC, abstractmethod\n\n\n    class Volador(ABC):\n        @abstractmethod\n        def volar(self):\n            pass\n\n        def aterrizar(self):\n            print(\"Aterrizando...\")\n\n    class Nadador(ABC):\n        @abstractmethod\n        def nadar(self):\n            pass\n\n    class Pato(Volador, Nadador):\n        def volar(self):\n            print(\"Pato volando\")\n\n        def nadar(self):\n            print(\"Pato nadando\")\n\n    pato = Pato()\n    pato.volar()\n    pato.nadar()\n    pato.aterrizar()\n</code></pre>"},{"location":"Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28B%C3%A1sico%29/Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Base%20y%20Avanzado%29/#sealed-classes","title":"Sealed Classes","text":"<p>Las clases selladas restringen qu\u00e9 clases pueden heredar de ellas.</p> KotlinJavaPython <pre><code>sealed class Resultado&lt;out T&gt; {\ndata class Exito&lt;T&gt;(val datos: T) : Resultado&lt;T&gt;()\ndata class Error(val mensaje: String) : Resultado&lt;Nothing&gt;()\nobject Cargando : Resultado&lt;Nothing&gt;()\n}\n\nfun procesarResultado(resultado: Resultado&lt;String&gt;) {\n    when (resultado) {\n        is Resultado.Exito -&gt; println(\"\u00c9xito: ${resultado.datos}\")\n        is Resultado.Error -&gt; println(\"Error: ${resultado.mensaje}\")\n        Resultado.Cargando -&gt; println(\"Cargando...\")\n    }\n}\n\nval exito = Resultado.Exito(\"Datos obtenidos\")\nprocesarResultado(exito)\n</code></pre> <pre><code>// Java 17+ sealed classes\npublic sealed class Resultado permits Resultado.Exito, Resultado.Error, Resultado.Cargando {\npublic static final class Exito&lt;T&gt; extends Resultado {\nprivate final T datos;\npublic Exito(T datos) { this.datos = datos; }\npublic T getDatos() { return datos; }\n}\n\n\n    public static final class Error extends Resultado {\n        private final String mensaje;\n        public Error(String mensaje) { this.mensaje = mensaje; }\n        public String getMensaje() { return mensaje; }\n    }\n\n    public static final class Cargando extends Resultado {}\n}\n\npublic void procesarResultado(Resultado resultado) {\n    if (resultado instanceof Resultado.Exito exito) {\n        System.out.println(\"\u00c9xito: \" + exito.getDatos());\n    } else if (resultado instanceof Resultado.Error error) {\n        System.out.println(\"Error: \" + error.getMensaje());\n    } else if (resultado instanceof Resultado.Cargando) {\n        System.out.println(\"Cargando...\");\n    }\n}\n</code></pre> <pre><code>from abc import ABC\nfrom dataclasses import dataclass\nfrom typing import Generic, TypeVar\n\n\nT = TypeVar('T')\n\nclass Resultado(ABC):\n    pass\n\n@dataclass\nclass Exito(Resultado, Generic[T]):\n    datos: T\n\n@dataclass\nclass Error(Resultado):\n    mensaje: str\n\nclass Cargando(Resultado):\n    pass\n\ndef procesar_resultado(resultado: Resultado):\n    if isinstance(resultado, Exito):\n        print(f\"\u00c9xito: {resultado.datos}\")\n    elif isinstance(resultado, Error):\n        print(f\"Error: {resultado.mensaje}\")\n    elif isinstance(resultado, Cargando):\n        print(\"Cargando...\")\n\nexito = Exito(\"Datos obtenidos\")\nprocesar_resultado(exito)\n</code></pre>"},{"location":"Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28B%C3%A1sico%29/Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Base%20y%20Avanzado%29/#smart-casts","title":"Smart Casts","text":"<p>Los smart casts permiten el casting autom\u00e1tico de tipos.</p> KotlinJavaPython <pre><code>fun procesar(valor: Any) {\nwhen (valor) {\nis String -&gt; println(valor.uppercase()) // Smart cast a String\nis Int -&gt; println(valor * 2) // Smart cast a Int\nelse -&gt; println(\"Tipo desconocido\")\n}\n}\n\nfun safeCast(valor: Any) {\n    val str = valor as? String // Cast seguro que devuelve null si falla\n    println(str?.length)\n}\n\nprocesar(\"hola\")\nprocesar(42)\nsafeCast(\"test\")\nsafeCast(123)\n</code></pre> <pre><code>public void procesar(Object valor) {\nif (valor instanceof String str) { // Pattern matching (Java 16+)\nSystem.out.println(str.toUpperCase());\n} else if (valor instanceof Integer num) {\nSystem.out.println(num * 2);\n} else {\nSystem.out.println(\"Tipo desconocido\");\n}\n}\n\npublic void safeCast(Object valor) {\n    if (valor instanceof String) {\n        String str = (String) valor; // Cast tradicional\n        System.out.println(str.length());\n    }\n}\n\n// Java 14+ con instanceof mejorado\npublic void procesarModerno(Object valor) {\n    if (valor instanceof String str &amp;&amp; !str.isEmpty()) {\n        System.out.println(str.toUpperCase());\n    }\n}\n</code></pre> <pre><code>def procesar(valor):\nif isinstance(valor, str):\nprint(valor.upper()) # No necesita cast expl\u00edcito\nelif isinstance(valor, int):\nprint(valor * 2)\nelse:\nprint(\"Tipo desconocido\")\n\ndef safe_cast(valor):\n    try:\n        str_val = str(valor)  # Conversi\u00f3n segura\n        print(len(str_val))\n    except (ValueError, TypeError):\n        print(\"No se puede convertir a string\")\n\nprocesar(\"hola\")\nprocesar(42)\nsafe_cast(\"test\")\nsafe_cast(123)\n</code></pre>"},{"location":"Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28B%C3%A1sico%29/Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Base%20y%20Avanzado%29/#inlining","title":"Inlining","text":"<p>El inlining permite optimizaciones en tiempo de compilaci\u00f3n.</p> KotlinJavaPython <pre><code>inline fun &lt;T&gt; medirTiempo(block: () -&gt; T): T {\nval start = System.currentTimeMillis()\nval result = block()\nval end = System.currentTimeMillis()\nprintln(\"Tiempo ejecuci\u00f3n: ${end - start} ms\")\nreturn result\n}\n\n// Uso\nval resultado = medirTiempo {\n    // C\u00f3digo a medir\n    (1..1000000).sum()\n}\nprintln(\"Resultado: $resultado\")\n</code></pre> <pre><code>public final class Utilidades {\n// Los m\u00e9todos final/private/static pueden ser inlineados por el JIT compiler\npublic static &lt;T&gt; T medirTiempo(Supplier&lt;T&gt; block) {\nlong start = System.currentTimeMillis();\nT result = block.get();\nlong end = System.currentTimeMillis();\nSystem.out.println(\"Tiempo ejecuci\u00f3n: \" + (end - start) + \" ms\");\nreturn result;\n}\n}\n\n\n// Uso\nInteger resultado = Utilidades.medirTiempo(() -&gt; {\n    int sum = 0;\n    for (int i = 1; i &lt;= 1000000; i++) {\n        sum += i;\n    }\n    return sum;\n});\nSystem.out.println(\"Resultado: \" + resultado);\n</code></pre> <pre><code>import time\nfrom contextlib import contextmanager\n\n@contextmanager\ndef medir_tiempo(descripcion=\"\"):\n    start = time.time()\n    try:\n        yield\n    finally:\n        end = time.time()\n        print(f\"{descripcion} - Tiempo ejecuci\u00f3n: {(end - start) * 1000:.2f} ms\")\n\n# Uso\nwith medir_tiempo(\"C\u00e1lculo suma\"):\n    resultado = sum(range(1, 1000001))\n\nprint(f\"Resultado: {resultado}\")\n</code></pre>"},{"location":"Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28B%C3%A1sico%29/Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Base%20y%20Avanzado%29/#type-aliases","title":"Type Aliases","text":"<p>Los alias de tipos permiten crear nombres alternativos para tipos existentes.</p> KotlinJavaPython <pre><code>typealias UserId = Int\ntypealias UserMap = Map&lt;UserId, String&gt;\ntypealias ClickHandler = (UserId, String) -&gt; Unit\n\nfun procesarUsuario(id: UserId, nombre: String, handler: ClickHandler) {\n    handler(id, nombre)\n}\n\nval usuarios: UserMap = mapOf(\n    1 to \"Juan\",\n    2 to \"Mar\u00eda\"\n)\n</code></pre> <pre><code>// Java no tiene type aliases nativos, se usan wrappers o se definen interfaces\npublic class UserId {\nprivate final int id;\npublic UserId(int id) { this.id = id; }\npublic int getValue() { return id; }\n}\n\npublic interface ClickHandler {\n    void handle(UserId id, String nombre);\n}\n\n// O usando anotaciones para documentaci\u00f3n\n/**\n* @param userId ID del usuario\n*/\npublic void procesarUsuario(int userId, String nombre) {\n    // implementaci\u00f3n\n}\n</code></pre> <pre><code>from typing import TypeAlias, Dict, Callable\n\nUserId: TypeAlias = int\nUserMap: TypeAlias = Dict[UserId, str]\nClickHandler: TypeAlias = Callable[[UserId, str], None]\n\ndef procesar_usuario(id: UserId, nombre: str, handler: ClickHandler):\n    handler(id, nombre)\n\nusuarios: UserMap = {\n    1: \"Juan\",\n    2: \"Mar\u00eda\"\n}\n</code></pre>"},{"location":"Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28B%C3%A1sico%29/Unidad%204%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Base%20y%20Avanzado%29/#inicializacion-tardia-y-perezosa","title":"Inicializaci\u00f3n tard\u00eda y perezosa","text":"<p>La inicializaci\u00f3n tard\u00eda y perezosa permite diferir la creaci\u00f3n de objetos hasta que sean necesarios.</p> KotlinJavaPython <pre><code>class Configurador {\nlateinit var config: String\n\n    val configuracionPerezosa: String by lazy {\n        println(\"Inicializando configuraci\u00f3n perezosa...\")\n        \"Configuraci\u00f3n cargada\"\n    }\n\n    fun inicializar() {\n        config = \"Configuraci\u00f3n inicializada\"\n    }\n}\n\nval configurador = Configurador()\nconfigurador.inicializar()\nprintln(configurador.config)\nprintln(configurador.configuracionPerezosa) // Se inicializa aqu\u00ed\nprintln(configurador.configuracionPerezosa) // Ya est\u00e1 inicializada\n</code></pre> <pre><code>public class Configurador {\nprivate String config;\nprivate String configuracionPerezosa;\n\n    public void inicializar() {\n        this.config = \"Configuraci\u00f3n inicializada\";\n    }\n\n    public String getConfig() {\n        if (config == null) {\n            throw new IllegalStateException(\"Config no inicializada\");\n        }\n        return config;\n    }\n\n    public String getConfiguracionPerezosa() {\n        if (configuracionPerezosa == null) {\n            System.out.println(\"Inicializando configuraci\u00f3n perezosa...\");\n            configuracionPerezosa = \"Configuraci\u00f3n cargada\";\n        }\n        return configuracionPerezosa;\n    }\n}\n\nConfigurador configurador = new Configurador();\nconfigurador.inicializar();\nSystem.out.println(configurador.getConfig());\nSystem.out.println(configurador.getConfiguracionPerezosa());\nSystem.out.println(configurador.getConfiguracionPerezosa());\n</code></pre> <pre><code>class Configurador:\ndef **init**(self):\nself._config = None\nself._configuracion_perezosa = None\n\n    def inicializar(self):\n        self._config = \"Configuraci\u00f3n inicializada\"\n\n    @property\n    def config(self):\n        if self._config is None:\n            raise ValueError(\"Config no inicializada\")\n        return self._config\n\n    @property\n    def configuracion_perezosa(self):\n        if self._configuracion_perezosa is None:\n            print(\"Inicializando configuraci\u00f3n perezosa...\")\n            self._configuracion_perezosa = \"Configuraci\u00f3n cargada\"\n        return self._configuracion_perezosa\n\nconfigurador = Configurador()\nconfigurador.inicializar()\nprint(configurador.config)\nprint(configurador.configuracion_perezosa)  # Se inicializa aqu\u00ed\nprint(configurador.configuracion_perezosa)  # Ya est\u00e1 inicializada\n</code></pre>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/","title":"Unidad 5 - Estructuras de datos din\u00e1micas","text":""},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#1-introduccion","title":"1. Introducci\u00f3n","text":"<p>Cuando el volumen de datos a manejar por una aplicaci\u00f3n es elevado, no basta con utilizar variables. Manejar los datos de un \u00fanico pedido en una aplicaci\u00f3n puede ser relativamente sencillo, pues un pedido est\u00e1 compuesto por una serie de datos y eso simplemente se traduce en varias variables. Pero, \u00bfqu\u00e9 ocurre cuando en una aplicaci\u00f3n tenemos que gestionar varios pedidos a la vez?</p> <p>Lo mismo ocurre en otros casos. Para poder realizar ciertas aplicaciones se necesita poder manejar datos que van m\u00e1s all\u00e1 de meros datos simples (n\u00fameros y letras). A veces, los datos que tiene que manejar la aplicaci\u00f3n son datos compuestos, es decir, datos que est\u00e1n compuestos a su vez de varios datos m\u00e1s simples. Por ejemplo, un pedido est\u00e1 compuesto por varios datos, los datos podr\u00edan ser el cliente que hace el pedido, la direcci\u00f3n de entrega, la fecha requerida de entrega y los art\u00edculos del pedido.</p> <p>Ya hemos trabajo con arrays, pero, a veces, los datos tienen estructuras a\u00fan m\u00e1s complejas, y son necesarias soluciones adicionales.</p> <p>En esta UD aprenderemos esas soluciones adicionales que consisten b\u00e1sicamente en la capacidad de poder manejar varios datos del mismo o diferente tipo de forma din\u00e1mica y flexible. Aunque hablaremos de diferentes estructuras de datos din\u00e1micas, nos centraremos en manejar las listas y en concretos los ArrayLists.</p>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#2-colecciones","title":"2. Colecciones","text":"<p>El manejo de las estructuras de datos din\u00e1micas es una tarea muy importante en el desarrollo de software. Sin embargo, su manejo, creando y manipulando directamente sus elementos y las referencias a ellos, podr\u00eda considerarse un trabajo de bajo nivel.</p>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#java","title":"Java","text":"<p>Java incluye un conjunto de interfaces y clases gen\u00e9ricas, conocido como el Java Collection Framework (marco de trabajo de colecciones de Java), el cu\u00e1l contiene estructuras de datos, interfaces y algoritmos pre empaquetados para manipular estructuras de datos tales como listas, pilas, colas, conjuntos y mapas clave \u2013 valor. Podr\u00edamos considerarlo como la librer\u00eda de las estructuras din\u00e1micas.</p>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#kotlin","title":"Kotlin","text":"<p>Kotlin utiliza las colecciones de Java pero proporciona dos variantes: colecciones mutables y colecciones de solo lectura. Adem\u00e1s, ofrece una API m\u00e1s segura y funcional con extensiones espec\u00edficas para operaciones comunes.</p>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#python","title":"Python","text":"<p>Python tiene estructuras de datos incorporadas como listas, tuplas, diccionarios y conjuntos, adem\u00e1s del m\u00f3dulo <code>collections</code> que proporciona tipos de datos especializados adicionales.</p> <p>Las colecciones definen un conjunto de interfaces, clases gen\u00e9ricas y algoritmos que permiten manejar grupos de objetos, todo ello enfocado a potenciar la reusabilidad del software y facilitar las tareas de programaci\u00f3n. Parecer\u00e1 incre\u00edble el tiempo que se ahorra empleando colecciones y c\u00f3mo se reduce la complejidad del software us\u00e1ndolas adecuadamente. Las colecciones permiten almacenar y manipular grupos de objetos que, a priori, est\u00e1n relacionados entre s\u00ed (aunque no es obligatorio que est\u00e9n relacionados, lo l\u00f3gico es que si se almacenan juntos es porque tienen alguna relaci\u00f3n entre s\u00ed), pudiendo trabajar con cualquier tipo de objeto.</p>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#estructuras-basicas-en-los-tres-lenguajes","title":"Estructuras b\u00e1sicas en los tres lenguajes:","text":"Estructura Java Kotlin Python Lista mutable ArrayList MutableList list Lista inmutable List.of() listOf() tuple Conjunto HashSet mutableSetOf() set Mapa HashMap mutableMapOf() dict"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#21-interfaz-basica","title":"2.1. Interfaz b\u00e1sica","text":"<p>Las colecciones en Java parten de una serie de interfaces b\u00e1sicas. Cada interfaz define un modelo de colecci\u00f3n y las operaciones que se pueden llevar a cabo sobre los datos almacenados, por lo que es necesario conocerlas.</p> <p>La interfaz inicial, a trav\u00e9s de la cual se han construido el resto de colecciones, es la interfaz <code>java.util.Collection</code>, que define las operaciones comunes a todas las colecciones derivadas.</p> <p>A continuaci\u00f3n se muestran las operaciones m\u00e1s importantes definidas por esta interfaz. Ten en cuenta que <code>Collection</code> es una interfaz gen\u00e9rica donde la letra E se utiliza para representar cualquier clase y al utilizarse se deber\u00e1 sustituir por una clase concreta.</p> M\u00e9todo Descripci\u00f3n Java Kotlin Python Tama\u00f1o Devuelve el n\u00famero de elementos <code>size()</code> <code>size</code> <code>len()</code> Vac\u00edo Verifica si est\u00e1 vac\u00eda <code>isEmpty()</code> <code>isEmpty()</code> not collection Contiene Verifica si tiene un elemento <code>contains(Object)</code> <code>contains()</code> <code>in</code> operator A\u00f1adir A\u00f1ade un elemento <code>add(E)</code> <code>add()</code> <code>append()</code>/<code>add()</code> Eliminar Elimina un elemento <code>remove(Object)</code> <code>remove()</code> <code>remove()</code> Iterador Crea iterador <code>iterator()</code> <code>iterator()</code> <code>iter()</code> Array Convierte a array <code>toArray()</code> <code>toTypedArray()</code> <code>list()</code> Vaciar Vac\u00eda la colecci\u00f3n <code>clear()</code> <code>clear()</code> <code>clear()</code> <p>En todos los tipos de colecciones en Java dispondremos de estos m\u00e9todos comunes m\u00e1s otros particulares dependiendo de sus funcionalidades. M\u00e1s adelante veremos como se usan estos m\u00e9todos.</p>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#22-elegir-una-coleccion","title":"2.2. Elegir una colecci\u00f3n","text":"<p>En esta parte nos centraremos en trabajar con la colecci\u00f3n ArrayList en Java, MutableList en Kotlin y list en Python.</p> <p>Sin embargo, cuando vayamos a desarrollar una nueva aplicaci\u00f3n es importante tener en cuenta los siguientes puntos:</p> <ul> <li>\u00bfQu\u00e9 informaci\u00f3n queremos guardar?</li> <li>\u00bfPuede haber datos repetidos?</li> <li>\u00bfEs importante que los datos est\u00e9n ordenados?</li> </ul> <p>En funci\u00f3n de las respuestas que demos, existir\u00e1n colecciones que debido a su estructura y funcionamiento interno, ser\u00e1n m\u00e1s eficientes que otras y deberemos tenerlo en cuenta.</p>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#3-listas","title":"3. Listas","text":"<p>Las listas son una estructura de datos que nos recuerdan a los arrays pero que proporcionan mayor flexibilidad ya que podemos a\u00f1adir y eliminar elementos sin preocuparnos por el tama\u00f1o de la lista. La lista crece seg\u00fan a\u00f1adimos elementos y se reduce cuando los eliminarnos sin que nosotros tengamos que hacer nada al respecto. De echo, las listas son una de las estructuras de datos fundamentales que te vas ha encontrar en programaci\u00f3n.</p> <p>Sus caracter\u00edsticas son las siguientes:</p> <ul> <li>Pueden almacenar elementos duplicados. Si no queremos duplicados, hay que verificar manualmente que el elemento no est\u00e9 en la lista antes de su inserci\u00f3n.</li> <li>Permiten acceso posicional. Es decir, podemos acceder a un elemento indicando su posici\u00f3n en la lista.</li> <li>Es posible buscar elementos en la lista y obtener su posici\u00f3n.</li> <li>Es posible la extracci\u00f3n de sublistas. Es decir se puede obtener una lista que contenga solo una parte de los elementos de forma muy sencilla.</li> </ul> <p>Para ello, adem\u00e1s de los m\u00e9todos heredados de Collection, a\u00f1ade m\u00e9todos que permiten esas funcionalidades.</p> <p>Dentro de las listas podemos encontrar ArrayList y LinkedList en Java. Las 2 son muy parecidas de manejar estando su diferencia en la estructura y funcionamiento interno. Cuando la lista vaya a cambiar frecuentemente, es decir cuando tengamos que introducir elementos nuevos y borrar otros de forma habitual, las LinkedList ser\u00e1n m\u00e1s eficientes. Para la mayor\u00eda de las soluciones sin embargo, los ArrayLists son suficientes y por ello vamos a centrar esta UD en su manejo.</p>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#31-metodos","title":"3.1. M\u00e9todos","text":"<p>Java: En Java, para las listas se dispone de una interfaz llamada <code>java.util.List</code>, y dos implementaciones b\u00e1sicas, <code>java.util.LinkedList</code> y <code>java.util.ArrayList</code>, con diferencias significativas entre ellas.</p> <p>Kotlin: Kotlin distingue entre listas de solo lectura (<code>List</code>) y listas mutables (<code>MutableList</code>). Las operaciones son similares pero con nombres m\u00e1s intuitivos.</p> <p>Python: Python tiene listas integradas (<code>list</code>) que son mutables por defecto y proporcionan una sintaxis muy expresiva para operaciones comunes.</p> <p>Los m\u00e9todos de la interfaz List, que obviamente estar\u00e1n en todas las implementaciones, y que permiten las operaciones anteriores son:</p> M\u00e9todo Descripci\u00f3n Java Kotlin Python Obtener Obtiene elemento por posici\u00f3n <code>get(int)</code> <code>get()</code>/<code>[]</code> <code>[]</code> Modificar Cambia elemento en posici\u00f3n <code>set(int, E)</code> <code>set()</code> <code>lista[pos] = valor</code> A\u00f1adir en posici\u00f3n Inserta en posici\u00f3n <code>add(int, E)</code> <code>add(index, E)</code> <code>insert(pos, valor)</code> Eliminar por posici\u00f3n Elimina en posici\u00f3n <code>remove(int)</code> <code>removeAt()</code> <code>pop(pos)</code> A\u00f1adir al final A\u00f1ade al final <code>add(E)</code> <code>add()</code> <code>append()</code> Vaciar Elimina todos <code>clear()</code> <code>clear()</code> <code>clear()</code> Tama\u00f1o N\u00famero de elementos <code>size()</code> <code>size</code> <code>len()</code> Representaci\u00f3n Devuelve string <code>toString()</code> <code>toString()</code> <code>str()</code> Array Convierte a array <code>toArray()</code> <code>toTypedArray()</code> <code>list()</code> <p>F\u00edjate que las listas conservan los m\u00e9todos de las colecciones (add, clear, size...) y de la clase Object (toString) y a\u00f1ade otras m\u00e1s para posibilitar las funcionalidades descritas.</p> <p>Al igual que los arrays, los elementos de una lista empiezan a numerarse por 0. Es decir, que el primer elemento de la lista es el 0.</p> <p>Recuerda tambi\u00e9n que <code>List</code> es una interfaz gen\u00e9rica, podemos crear listas con elementos de cualquier clase, por lo que <code>&lt;E&gt;</code> se corresponder\u00e1 con la clase usada para crear esa lista.</p> <p>Hay otros m\u00e9todos que para funcionar correctamente necesitan encontrar un elemento en la lista. Funcionan con los tipos b\u00e1sicos, enteros, double, String.. pero no con el resto de objetos:</p> M\u00e9todo Descripci\u00f3n Java Kotlin Python Eliminar objeto Elimina elemento <code>remove(Object)</code> <code>remove()</code> <code>remove()</code> \u00cdndice de Primera aparici\u00f3n <code>indexOf(Object)</code> <code>indexOf()</code> <code>index()</code> Contiene Verifica existencia <code>contains(Object)</code> <code>contains()</code> <code>in</code> operator \u00daltimo \u00edndice \u00daltima aparici\u00f3n <code>lastIndexOf(Object)</code> <code>lastIndexOf()</code> <code>-</code>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#metodos-comunes-de-la-interfaz-list","title":"M\u00e9todos Comunes de la Interfaz List","text":"<pre><code>    graph TB\n    subgraph \"M\u00e9todos de la Interfaz List&lt;E&gt;\"\n        ListInterface[\"&lt;b&gt;Interfaz List&lt;/b&gt;&lt;br/&gt;java.util.List&lt;E&gt;\"] --&gt; OperacionesBasicas[\"&lt;b&gt;Operaciones B\u00e1sicas&lt;/b&gt;\"]\n        ListInterface --&gt; OperacionesPosicionales[\"&lt;b&gt;Operaciones Posicionales&lt;/b&gt;\"]\n        ListInterface --&gt; OperacionesBusqueda[\"&lt;b&gt;Operaciones de B\u00fasqueda&lt;/b&gt;\"]\n        ListInterface --&gt; OperacionesVista[\"&lt;b&gt;Operaciones de Vista&lt;/b&gt;\"]\n\n        OperacionesBasicas --&gt; B1[\"int size()&lt;br/&gt;O(1) - Devuelve n\u00famero de elementos\"]\n        OperacionesBasicas --&gt; B2[\"boolean isEmpty()&lt;br/&gt;O(1) - Verifica si est\u00e1 vac\u00eda\"]\n        OperacionesBasicas --&gt; B3[\"boolean add(E e)&lt;br/&gt;O(1)* - A\u00f1ade al final\"]\n        OperacionesBasicas --&gt; B4[\"boolean remove(Object o)&lt;br/&gt;O(n) - Elimina primera ocurrencia\"]\n        OperacionesBasicas --&gt; B5[\"void clear()&lt;br/&gt;O(n) - Elimina todos\"]\n        OperacionesBasicas --&gt; B6[\"Iterator&lt;E&gt; iterator()&lt;br/&gt;O(1) - Crea iterador\"]\n\n        OperacionesPosicionales --&gt; P1[\"E get(int index)&lt;br/&gt;O(1) ArrayList / O(n) LinkedList\"]\n        OperacionesPosicionales --&gt; P2[\"E set(int index, E e)&lt;br/&gt;O(1) ArrayList / O(n) LinkedList\"]\n        OperacionesPosicionales --&gt; P3[\"void add(int index, E e)&lt;br/&gt;O(n) - Inserta en posici\u00f3n\"]\n        OperacionesPosicionales --&gt; P4[\"E remove(int index)&lt;br/&gt;O(n) - Elimina por posici\u00f3n\"]\n\n        OperacionesBusqueda --&gt; S1[\"boolean contains(Object o)&lt;br/&gt;O(n) - Verifica existencia\"]\n        OperacionesBusqueda --&gt; S2[\"int indexOf(Object o)&lt;br/&gt;O(n) - Primera ocurrencia\"]\n        OperacionesBusqueda --&gt; S3[\"int lastIndexOf(Object o)&lt;br/&gt;O(n) - \u00daltima ocurrencia\"]\n\n        OperacionesVista --&gt; V1[\"List&lt;E&gt; subList(int from, int to)&lt;br/&gt;O(1) - Vista, no copia\"]\n        OperacionesVista --&gt; V2[\"Object[] toArray()&lt;br/&gt;O(n) - Copia a array\"]\n        OperacionesVista --&gt; V3[\"&lt;T&gt; T[] toArray(T[] a)&lt;br/&gt;O(n) - Copia tipada\"]\n\n        Nota[\"* O(1) amortizado para ArrayList&lt;br/&gt;Puede ser O(n) durante redimensi\u00f3n\"]\n\n        style B1 fill:#e8f5e8\n        style B2 fill:#e8f5e8\n        style B3 fill:#fff3e0\n        style B4 fill:#ffebee\n        style B5 fill:#ffebee\n        style B6 fill:#e8f5e8\n        style P1 fill:#e3f2fd\n        style P2 fill:#e3f2fd\n        style P3 fill:#ffebee\n        style P4 fill:#ffebee\n        style S1 fill:#ffebee\n        style S2 fill:#ffebee\n        style S3 fill:#ffebee\n        style V1 fill:#e8f5e8\n        style V2 fill:#ffebee\n        style V3 fill:#ffebee\n    end\n</code></pre>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#32-uso-de-listas","title":"3.2. Uso de listas","text":"<p>Java: Para usar una lista haremos uso de su implementaci\u00f3n <code>ArrayList</code>. El siguiente ejemplo muestra como usar un <code>ArrayList</code> pero valdr\u00eda tambi\u00e9n para <code>LinkedList.</code></p> JavaKotlinPython <pre><code>import java.util.ArrayList;\n\nArrayList&lt;String&gt; t = new ArrayList&lt;String&gt;();      // Crea un ArrayList de cadenas de caracteres.\nt.add(\"hola\");                                      // A\u00f1ade el valor \"hola\" al final de la lista.\nt.add(\"Agur\");                                      // A\u00f1ade \"Agur\" al final de la lista.\nt.add(1, \"Adios\");                                  // A\u00f1ade \"Adios\" en la posici\u00f3n 1 de la lista (la segunda).\nt.remove(0);                                        // Elimina el primer elementos de la lista.\nt.set(1, \"kaixo\");                                  // Modifica el valor del elemento 1\n\n// Muestra los elementos de la lista.\nfor (int i = 0; i &lt; t.size(); i++) {\n    System.out.println(\"Elemento:\" + t.get(i));\n}\n\nt.set(t.indexOf(\"kaixo\"), \"Agur\");                  // Busca el elemento \"kaixo\" y lo sustituye por \"Agur\".\n\n// Muestra los elementos de la lista mediante el m\u00e9todo toString de las clases\nSystem.out.println(t);\n</code></pre> <pre><code>// Crea una MutableList de cadenas de caracteres\nval t = mutableListOf&lt;String&gt;()  \nt.add(\"hola\")                                      // A\u00f1ade el valor \"hola\" al final de la lista.\nt.add(\"Agur\")                                      // A\u00f1ade \"Agur\" al final de la lista.\nt.add(1, \"Adios\")                                  // A\u00f1ade \"Adios\" en la posici\u00f3n 1 de la lista (la segunda).\nt.removeAt(0)                                      // Elimina el primer elementos de la lista.\nt[1] = \"kaixo\"                                     // Modifica el valor del elemento 1\n\n// Muestra los elementos de la lista.\nfor (i in t.indices) {\n    println(\"Elemento: ${t[i]}\")\n}\n\nval index = t.indexOf(\"kaixo\")\nif (index != -1) {\n    t[index] = \"Agur\"                             // Busca el elemento \"kaixo\" y lo sustituye por \"Agur\".\n}\n\n// Muestra los elementos de la lista\nprintln(t)\n</code></pre> <pre><code># Crea una lista de cadenas de caracteres\nt = []\nt.append(\"hola\")                                   # A\u00f1ade el valor \"hola\" al final de la lista.\nt.append(\"Agur\")                                   # A\u00f1ade \"Agur\" al final de la lista.\nt.insert(1, \"Adios\")                               # A\u00f1ade \"Adios\" en la posici\u00f3n 1 de la lista (la segunda).\nt.pop(0)                                           # Elimina el primer elementos de la lista.\nt[1] = \"kaixo\"                                     # Modifica el valor del elemento 1\n\n# Muestra los elementos de la lista.\nfor i in range(len(t)):\n    print(f\"Elemento: {t[i]}\")\n\ntry:\n    index = t.index(\"kaixo\")                      # Busca el elemento \"kaixo\"\n    t[index] = \"Agur\"                             # Lo sustituye por \"Agur\".\nexcept ValueError:\n    pass\n\n# Muestra los elementos de la lista\nprint(t)\n</code></pre> <p>La lista ArrayList en Java, MutableList en Kotlin y list en Python representan una familia de listas que se diferencian en la clase de elemento que almacenan. Usaremos ArrayList para almacenar una lista de cadenas de caracteres en Java, MutableList en Kotlin para diferentes elementos todos ellos de la clase Punto y ArrayList ser\u00e1 una lista de Clientes. <p>F\u00edjate que nunca podemos declarar algo de la clase ArrayList. Siempre tendremos que sustituir la E por la clase concreta que queremos utilizar. <p>En el ejemplo anterior, se realizan muchas operaciones, \u00bfcu\u00e1l ser\u00e1 el contenido de la lista al final? Pues ser\u00e1 \"Adios\" y \"Agur\". </p>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#metodos-especificos-de-arraylist","title":"M\u00e9todos Espec\u00edficos de ArrayList","text":"<pre><code>\n    graph LR\n    subgraph \"M\u00e9todos Espec\u00edficos de ArrayList\"\n        ArrayListClass[\"&lt;b&gt;Clase ArrayList&lt;E&gt;&lt;/b&gt;&lt;br/&gt;extends AbstractList&lt;E&gt;&lt;br/&gt;implements List&lt;E&gt;, RandomAccess\"]\n\n        ArrayListClass --&gt; Constructores[\"&lt;b&gt;Constructores&lt;/b&gt;\"]\n        ArrayListClass --&gt; MetodosOptimizacion[\"&lt;b&gt;M\u00e9todos de Optimizaci\u00f3n&lt;/b&gt;\"]\n        ArrayListClass --&gt; MetodosCapacidad[\"&lt;b&gt;Gesti\u00f3n de Capacidad&lt;/b&gt;\"]\n\n        Constructores --&gt; C1[\"ArrayList()&lt;br/&gt;Capacidad inicial: 10\"]\n        Constructores --&gt; C2[\"ArrayList(int capacidad)&lt;br/&gt;Especifica capacidad inicial\"]\n        Constructores --&gt; C3[\"ArrayList(Collection c)&lt;br/&gt;Copia elementos de colecci\u00f3n\"]\n\n        MetodosOptimizacion --&gt; O1[\"void ensureCapacity(int min)&lt;br/&gt;Aumenta capacidad si es menor\"]\n        MetodosOptimizacion --&gt; O2[\"void trimToSize()&lt;br/&gt;Reduce capacidad al tama\u00f1o actual\"]\n\n        MetodosCapacidad --&gt; CA1[\"No tiene m\u00e9todos p\u00fablicos&lt;br/&gt;para obtener capacidad\"]\n        MetodosCapacidad --&gt; CA2[\"Capacidad interna: size \u2264 capacity\"]\n\n        NotaConstructores[\"&lt;b&gt;Consejo:&lt;/b&gt; Usar ArrayList(capacidad)&lt;br/&gt;para evitar redimensiones\"]\n        NotaOptimizacion[\"&lt;b&gt;trimToSize() \u00fatil cuando&lt;/b&gt;&lt;br/&gt;lista no crecer\u00e1 m\u00e1s\"]\n\n        style Constructores fill:#e3f2fd\n        style MetodosOptimizacion fill:#fff3e0\n        style MetodosCapacidad fill:#e8f5e8\n        style C1 fill:#fff3e0\n        style C2 fill:#e8f5e8\n        style C3 fill:#fff3e0\n        style O1 fill:#e8f5e8\n        style O2 fill:#fff3e0\n    end\n</code></pre>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#33-otros-tipos-de-listas","title":"3.3. Otros tipos de listas","text":""},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#java-linkedlist-vs-arraylist","title":"Java LinkedList vs ArrayList","text":"<p>\u00bfY en qu\u00e9 se diferencia una <code>LinkedList</code> de una <code>ArrayList</code>? Los <code>LinkedList</code> utilizan listas doblemente enlazadas.</p> <p>Las listas enlazadas sus elementos se encapsulan en los llamados nodos. Los nodos van enlazados unos a otros para no perder el orden y no limitar el tama\u00f1o de almacenamiento. Cuando queremos a\u00f1adir un elemento al final solo tenemos que enlazarlo al \u00faltimo elemento. Para eliminar un elemento de una lista, solo hay que \"puentearlo\". Es decir, hay que cambiar el enlace del elemento anterior para que conecte directamente con el siguiente, dejando el elemento a borrar fuera de la lista.</p> <p>Tener un doble enlace significa que en cada nodo se almacena la informaci\u00f3n de cu\u00e1l es el siguiente nodo y tambi\u00e9n, informaci\u00f3n de cu\u00e1l es el nodo anterior. Si un nodo no tiene nodo siguiente o nodo anterior, se almacena null para ambos casos.</p> <p>En el caso de los <code>ArrayList,</code> \u00e9stos se implementan utilizando arrays que se van redimensionando conforme se necesita m\u00e1s espacio o menos. La redimensi\u00f3n es transparente a nosotros, no nos enteramos cuando se produce, pero eso redunda en una diferencia de rendimiento notable dependiendo del uso.</p> <p>Los <code>ArrayList</code> son m\u00e1s r\u00e1pidos en cuanto a acceso a los elementos. Acceder a un elemento seg\u00fan su posici\u00f3n es m\u00e1s r\u00e1pido en un array que en una lista doblemente enlazada que exige recorrer la lista. En cambio, eliminar un elemento implica muchas m\u00e1s operaciones en un array que en una lista enlazada de cualquier tipo.</p> <p>\u00bfY esto que quiere decir? Que si se van a realizar muchas operaciones de eliminaci\u00f3n de elementos sobre la lista, conviene usar una lista enlazada (<code>LinkedList</code>), pero si no se van a realizar muchas eliminaciones, sino que solamente se van a insertar y consultar elementos por posici\u00f3n, conviene usar una lista basada en arrays redimensionados (<code>ArrayList</code>).</p> <pre><code>graph TB\n    subgraph LinkedListJava[\"LinkedList en Java - Estructura de Lista Doblemente Enlazada\"]\n        direction LR\n\n        HeaderFirst[Primer Nodo: first] --&gt; Nodo1\n        HeaderLast[\u00daltimo Nodo: last] --&gt; Nodo4\n\n        Nodo1[\"Nodo 1&lt;br/&gt;prev = null&lt;br/&gt;element = 'Volvo'&lt;br/&gt;next = ref_Nodo2\"] \n        Nodo2[\"Nodo 2&lt;br/&gt;prev = ref_Nodo1&lt;br/&gt;element = 'BMW'&lt;br/&gt;next = ref_Nodo3\"] \n        Nodo3[\"Nodo 3&lt;br/&gt;prev = ref_Nodo2&lt;br/&gt;element = 'Ford'&lt;br/&gt;next = ref_Nodo4\"] \n        Nodo4[\"Nodo 4&lt;br/&gt;prev = ref_Nodo3&lt;br/&gt;element = 'Mazda'&lt;br/&gt;next = null\"] \n\n        Nodo1 -- \"next\" --&gt; Nodo2\n        Nodo2 -- \"prev\" --&gt; Nodo1\n        Nodo2 -- \"next\" --&gt; Nodo3\n        Nodo3 -- \"prev\" --&gt; Nodo2\n        Nodo3 -- \"next\" --&gt; Nodo4\n        Nodo4 -- \"prev\" --&gt; Nodo3\n    end\n\n    Nodo1 --&gt; Operaciones[\"Operaciones Disponibles\"]\n    Nodo4 --&gt; Operaciones\n\n    Operaciones --&gt; OpAddFirst[\"addFirst('SEAT')\"]\n    Operaciones --&gt; OpAddLast[\"addLast('MG')\"]\n    Operaciones --&gt; OpRemoveFirst[\"removeFirst()\"]\n    Operaciones --&gt; OpRemoveLast[\"removeLast()\"]\n    Operaciones --&gt; OpGetFirst[\"getFirst()\"]\n    Operaciones --&gt; OpGetLast[\"getLast()\"]\n\n    OpAddFirst --&gt; ExAddFirst[\"&lt;b&gt;Crea nuevo nodo&lt;/b&gt;&lt;br/&gt;next \u2192 Nodo1&lt;br/&gt;prev = null\"]\n    OpAddLast --&gt; ExAddLast[\"&lt;b&gt;Crea nuevo nodo&lt;/b&gt;&lt;br/&gt;prev \u2192 Nodo4&lt;br/&gt;next = null\"]\n    OpRemoveFirst --&gt; ExRemoveFirst[\"&lt;b&gt;Elimina Nodo1&lt;/b&gt;&lt;br/&gt;first \u2192 Nodo2&lt;br/&gt;Nodo2.prev = null\"]\n    OpRemoveLast --&gt; ExRemoveLast[\"&lt;b&gt;Elimina Nodo4&lt;/b&gt;&lt;br/&gt;last \u2192 Nodo3&lt;br/&gt;Nodo3.next = null\"]\n    OpGetFirst --&gt; ExGetFirst[\"&lt;b&gt;Devuelve:&lt;/b&gt; 'Volvo'&lt;br/&gt;(elemento de first)\"]\n    OpGetLast --&gt; ExGetLast[\"&lt;b&gt;Devuelve:&lt;/b&gt; 'Mazda'&lt;br/&gt;(elemento de last)\"]\n\n    classDef nodo fill:#e3f2fd,stroke:#1565c0,stroke-width:2px,color:#000;\n    classDef operacion fill:#e8f5e8,stroke:#1b5e20,stroke-width:2px,color:#000;\n    classDef ejemplo fill:#fff3e0,stroke:#ff6f00,stroke-width:2px,color:#000;\n    classDef header fill:#f3e5f5,stroke:#4a148c,stroke-width:2px,color:#000;\n\n    class Nodo1,Nodo2,Nodo3,Nodo4 nodo;\n    class OpAddFirst,OpAddLast,OpRemoveFirst,OpRemoveLast,OpGetFirst,OpGetLast operacion;\n    class ExAddFirst,ExAddLast,ExRemoveFirst,ExRemoveLast,ExGetFirst,ExGetLast ejemplo;\n    class HeaderFirst,HeaderLast header;</code></pre> <pre><code>\n    graph LR\n        A[&lt;b&gt;LinkedList Java&lt;/b&gt;] --&gt; B[&lt;b&gt;Estructura Interna&lt;/b&gt;]\n        A --&gt; C[&lt;b&gt;Operaciones&lt;/b&gt;]\n        A --&gt; D[&lt;b&gt;Comparaci\u00f3n ArrayList&lt;/b&gt;]\n\n        B --&gt; B1[\"&lt;b&gt;Clase Node&lt;/b&gt;&lt;br/&gt;E item&lt;br/&gt;Node next&lt;br/&gt;Node prev\"]\n        B --&gt; B2[\"&lt;b&gt;Primer Nodo&lt;/b&gt;&lt;br/&gt;first = ref primer elemento\"]\n        B --&gt; B3[\"&lt;b&gt;\u00daltimo Nodo&lt;/b&gt;&lt;br/&gt;last = ref \u00faltimo elemento\"]\n        B --&gt; B4[\"&lt;b&gt;Size&lt;/b&gt;&lt;br/&gt;tama\u00f1o de la lista\"]\n\n        C --&gt; C1[\"&lt;b&gt;A\u00f1adir&lt;/b&gt;&lt;br/&gt;addFirst()&lt;br/&gt;addLast()&lt;br/&gt;add()\"]\n        C --&gt; C2[\"&lt;b&gt;Eliminar&lt;/b&gt;&lt;br/&gt;removeFirst()&lt;br/&gt;removeLast()&lt;br/&gt;remove()\"]\n        C --&gt; C3[\"&lt;b&gt;Consultar&lt;/b&gt;&lt;br/&gt;getFirst()&lt;br/&gt;getLast()&lt;br/&gt;get()\"]\n        C --&gt; C4[\"&lt;b&gt;Otros&lt;/b&gt;&lt;br/&gt;size()&lt;br/&gt;isEmpty()&lt;br/&gt;contains()\"]\n\n        D --&gt; D1[\"&lt;b&gt;Ventajas LinkedList&lt;/b&gt;&lt;br/&gt;\u2022 Inserci\u00f3n r\u00e1pida O(1)&lt;br/&gt;\u2022 Eliminaci\u00f3n r\u00e1pida O(1)&lt;br/&gt;\u2022 No redimensiona&lt;br/&gt;\u2022 Implementa Queue/Deque\"]\n        D --&gt; D2[\"&lt;b&gt;Desventajas LinkedList&lt;/b&gt;&lt;br/&gt;\u2022 Acceso lento O(n)&lt;br/&gt;\u2022 Mayor uso memoria&lt;br/&gt;\u2022 No acceso aleatorio\"]\n        D --&gt; D3[\"&lt;b&gt;Ventajas ArrayList&lt;/b&gt;&lt;br/&gt;\u2022 Acceso r\u00e1pido O(1)&lt;br/&gt;\u2022 Menor uso memoria&lt;br/&gt;\u2022 Cache-friendly\"]\n        D --&gt; D4[\"&lt;b&gt;Desventajas ArrayList&lt;/b&gt;&lt;br/&gt;\u2022 Inserci\u00f3n lenta O(n)&lt;br/&gt;\u2022 Eliminaci\u00f3n lenta O(n)&lt;br/&gt;\u2022 Redimensiona arrays\"]\n\n        classDef titulo fill:#D7BBEA,stroke:#262F7E,stroke-width:3px,color:#262F7E;\n        classDef subtitulo fill:#e3f2fd,stroke:#1565c0,stroke-width:2px,color:#1565c0;\n        classDef ventaja fill:#e8f5e8,stroke:#1b5e20,stroke-width:2px,color:#000;\n        classDef desventaja fill:#ffebee,stroke:#b71c1c,stroke-width:2px,color:#000;\n        classDef operacion fill:#fff3e0,stroke:#ff6f00,stroke-width:2px,color:#000;\n\n        class A titulo;\n        class B,C,D subtitulo;\n        class B1,B2,B3,B4,C1,C2,C3,C4 operacion;\n        class D1,D3 ventaja;\n        class D2,D4 desventaja;\n</code></pre> <p>Resumen de operaciones</p> <pre><code>\n    graph TD\n        Start[\"Operaciones LinkedList\"] --&gt; Add[\"A\u00f1adir\"]\n        Start --&gt; Remove[\"Eliminar\"]\n        Start --&gt; Get[\"Consultar\"]\n\n        Add --&gt; AddFirst[\"addFirst(e)&lt;br/&gt;A\u00f1ade al principio\"]\n        Add --&gt; AddLast[\"addLast(e)&lt;br/&gt;A\u00f1ade al final\"]\n        Add --&gt; AddPos[\"add(index, e)&lt;br/&gt;A\u00f1ade en posici\u00f3n\"]\n\n        Remove --&gt; RemoveFirst[\"removeFirst()&lt;br/&gt;Elimina primero\"]\n        Remove --&gt; RemoveLast[\"removeLast()&lt;br/&gt;Elimina \u00faltimo\"]\n        Remove --&gt; RemovePos[\"remove(index)&lt;br/&gt;Elimina por posici\u00f3n\"]\n\n        Get --&gt; GetFirst[\"getFirst()&lt;br/&gt;Obtiene primero\"]\n        Get --&gt; GetLast[\"getLast()&lt;br/&gt;Obtiene \u00faltimo\"]\n        Get --&gt; GetPos[\"get(index)&lt;br/&gt;Obtiene por posici\u00f3n\"]\n\n        classDef categoria fill:#e3f2fd,stroke:#1565c0\n        classDef operacion fill:#fff3e0,stroke:#ff6f00\n\n        class Start,Add,Remove,Get categoria\n        class AddFirst,AddLast,AddPos,RemoveFirst,RemoveLast,RemovePos,GetFirst,GetLast,GetPos operacion\n</code></pre>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#arraylist-vs-linkedlist","title":"\u00bfArrayList vs LinkedList?","text":"<pre><code>    graph TD\n    Start[\"&lt;b&gt;\u00bfQu\u00e9 estructura usar?&lt;/b&gt;&lt;br/&gt;Considera tu caso de uso principal\"] --&gt; Decision\n\n    subgraph Decision[\"\u00c1rbol de Decisi\u00f3n\"]\n        Q1[\"\u00bfOperaciones frecuentes&lt;br/&gt;de acceso por \u00edndice?\"] --&gt;|S\u00cd| Recomendacion1[\"\u2705 &lt;b&gt;ARRAYLIST&lt;/b&gt;&lt;br/&gt;\u2022 get(index): O(1)&lt;br/&gt;\u2022 set(index, e): O(1)\"]\n\n        Q1 --&gt;|NO| Q2[\"\u00bfInserci\u00f3n/eliminaci\u00f3n&lt;br/&gt;frecuente en extremos?\"]\n        Q2 --&gt;|S\u00cd| Recomendacion2[\"\u2705 &lt;b&gt;LINKEDLIST&lt;/b&gt;&lt;br/&gt;\u2022 addFirst/Last: O(1)&lt;br/&gt;\u2022 removeFirst/Last: O(1)\"]\n\n        Q2 --&gt;|NO| Q3[\"\u00bfUso como cola o pila?\"]\n        Q3 --&gt;|S\u00cd| Recomendacion2\n\n        Q3 --&gt;|NO| Q4[\"\u00bfTama\u00f1o variable&lt;br/&gt;con muchas inserciones?\"]\n        Q4 --&gt;|S\u00cd| Q5[\"\u00bfInserciones en medio?\"]\n        Q5 --&gt;|S\u00cd| Recomendacion2\n        Q5 --&gt;|NO| Recomendacion1\n\n        Q4 --&gt;|NO| Q6[\"\u00bfMemoria limitada?\"]\n        Q6 --&gt;|S\u00cd| Recomendacion1\n        Q6 --&gt;|NO| Q7[\"\u00bfIteraci\u00f3n secuencial frecuente?\"]\n        Q7 --&gt;|S\u00cd| Ambos[\"Ambos: O(n) similar&lt;br/&gt;ArrayList algo m\u00e1s r\u00e1pido\"]\n\n        Q7 --&gt;|NO| Default[\"Por defecto:&lt;br/&gt;\u2705 ARRAYLIST\"]\n    end\n\n    subgraph \"Casos de Uso Espec\u00edficos\"\n        CasoArrayList[\"&lt;b&gt;ArrayList ideal para:&lt;/b&gt;&lt;br/&gt;\u2022 Implementaci\u00f3n de matrices&lt;br/&gt;\u2022 Cache de datos&lt;br/&gt;\u2022 Procesamiento por lotes&lt;br/&gt;\u2022 Lectura intensiva\"]\n\n        CasoLinkedList[\"&lt;b&gt;LinkedList ideal para:&lt;/b&gt;&lt;br/&gt;\u2022 Implementaci\u00f3n de colas&lt;br/&gt;\u2022 Navegador hist\u00f3rico&lt;br/&gt;\u2022 Playlist de m\u00fasica&lt;br/&gt;\u2022 Operaciones undo/redo\"]\n\n        CasoMixto[\"&lt;b&gt;Considerar ambos:&lt;/b&gt;&lt;br/&gt;\u2022 Listas peque\u00f1as (&lt;1000)&lt;br/&gt;\u2022 Uso como interfaz List&lt;br/&gt;\u2022 Iteradores ListIterator\"]\n    end\n\n    style Recomendacion1 fill:#e8f5e8,stroke:#1b5e20,stroke-width:3px\n    style Recomendacion2 fill:#e3f2fd,stroke:#1565c0,stroke-width:3px\n    style Start fill:#f3e5f5,stroke:#4a148c,stroke-width:3px\n    style CasoArrayList fill:#e8f5e8,stroke:#1b5e20\n    style CasoLinkedList fill:#e3f2fd,stroke:#1565c0\n    style CasoMixto fill:#fff3e0,stroke:#ff6f00\n</code></pre>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#analisis-detallado-por-operacion","title":"An\u00e1lisis Detallado por Operaci\u00f3n","text":"<pre><code>    graph LR\n    subgraph \"An\u00e1lisis Detallado por Tipo de Operaci\u00f3n\"\n        TipoOperacion[\"&lt;b&gt;Tipo de Operaci\u00f3n&lt;/b&gt;\"] --&gt; AccesoAleatorio\n        TipoOperacion --&gt; Insercion\n        TipoOperacion --&gt; Eliminacion\n        TipoOperacion --&gt; Busqueda\n        TipoOperacion --&gt; Iteracion\n\n        AccesoAleatorio --&gt; AR1[\"get(index)\"]\n        AR1 --&gt; AR1A[\"&lt;b&gt;ArrayList&lt;/b&gt;: O(1)&lt;br/&gt;Acceso directo por \u00edndice\"]\n        AR1 --&gt; AR1L[\"&lt;b&gt;LinkedList&lt;/b&gt;: O(n)&lt;br/&gt;Recorre desde cabeza/cola\"]\n\n        Insercion --&gt; IN1[\"add(e) - Final\"]\n        IN1 --&gt; IN1A[\"&lt;b&gt;ArrayList&lt;/b&gt;: O(1) amortizado&lt;br/&gt;O(n) si redimensiona\"]\n        IN1 --&gt; IN1L[\"&lt;b&gt;LinkedList&lt;/b&gt;: O(1)&lt;br/&gt;Actualiza \u00faltimos enlaces\"]\n\n        Insercion --&gt; IN2[\"add(0, e) - Principio\"]\n        IN2 --&gt; IN2A[\"&lt;b&gt;ArrayList&lt;/b&gt;: O(n)&lt;br/&gt;Desplaza todos los elementos\"]\n        IN2 --&gt; IN2L[\"&lt;b&gt;LinkedList&lt;/b&gt;: O(1)&lt;br/&gt;Actualiza primeros enlaces\"]\n\n        Eliminacion --&gt; EL1[\"remove(0) - Principio\"]\n        EL1 --&gt; EL1A[\"&lt;b&gt;ArrayList&lt;/b&gt;: O(n)&lt;br/&gt;Desplaza n-1 elementos\"]\n        EL1 --&gt; EL1L[\"&lt;b&gt;LinkedList&lt;/b&gt;: O(1)&lt;br/&gt;Actualiza primeros enlaces\"]\n\n        Busqueda --&gt; BU1[\"contains(Object)\"]\n        BU1 --&gt; BU1A[\"&lt;b&gt;ArrayList&lt;/b&gt;: O(n)&lt;br/&gt;B\u00fasqueda secuencial\"]\n        BU1 --&gt; BU1L[\"&lt;b&gt;LinkedList&lt;/b&gt;: O(n)&lt;br/&gt;B\u00fasqueda secuencial\"]\n\n        Iteracion --&gt; IT1[\"Iteraci\u00f3n con for-each\"]\n        IT1 --&gt; IT1A[\"&lt;b&gt;ArrayList&lt;/b&gt;: O(n) r\u00e1pido&lt;br/&gt;Localidad de cache\"]\n        IT1 --&gt; IT1L[\"&lt;b&gt;LinkedList&lt;/b&gt;: O(n) lento&lt;br/&gt;Saltos de memoria\"]\n\n        style AR1A fill:#c8e6c9\n        style AR1L fill:#ffcdd2\n        style IN1A fill:#fff9c4\n        style IN1L fill:#c8e6c9\n        style IN2A fill:#ffcdd2\n        style IN2L fill:#c8e6c9\n        style EL1A fill:#ffcdd2\n        style EL1L fill:#c8e6c9\n        style BU1A fill:#ffcdd2\n        style BU1L fill:#ffcdd2\n        style IT1A fill:#c8e6c9\n        style IT1L fill:#fff9c4\n    end\n</code></pre>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#comparativa-de-consumo-de-memoria","title":"Comparativa de Consumo de Memoria","text":"<pre><code>    graph TB\n    subgraph \"Consumo de Memoria y Overhead\"\n        MemoriaArrayList[\"\n        &lt;b&gt;ArrayList (n elementos)&lt;/b&gt;&lt;br/&gt;&lt;br/&gt;\n        \u2022 &lt;b&gt;Array interno&lt;/b&gt;: n \u00d7 tama\u00f1o_elemento&lt;br/&gt;\n        \u2022 &lt;b&gt;Capacidad extra&lt;/b&gt;: hasta 50%&lt;br/&gt;\n        \u2022 &lt;b&gt;Overhead por objeto&lt;/b&gt;: ~24 bytes&lt;br/&gt;\n        \u2022 &lt;b&gt;Total aproximado&lt;/b&gt;: capacidad \u00d7 tama\u00f1o_elemento + 24\n        \"]\n\n        MemoriaLinkedList[\"\n        &lt;b&gt;LinkedList (n elementos)&lt;/b&gt;&lt;br/&gt;&lt;br/&gt;\n        \u2022 &lt;b&gt;Cada Node&lt;/b&gt;:&lt;br/&gt;  - elemento: tama\u00f1o_elemento&lt;br/&gt;  - next: 8 bytes (referencia)&lt;br/&gt;  - prev: 8 bytes (referencia)&lt;br/&gt;  - overhead Node: ~24 bytes&lt;br/&gt;\n        \u2022 &lt;b&gt;Total por nodo&lt;/b&gt;: tama\u00f1o_elemento + 40&lt;br/&gt;\n        \u2022 &lt;b&gt;Total lista&lt;/b&gt;: n \u00d7 (tama\u00f1o_elemento + 40) + 24\n        \"]\n\n        EjemploNumerico[\"\n        &lt;b&gt;Ejemplo con 1000 Integer (4 bytes):&lt;/b&gt;&lt;br/&gt;&lt;br/&gt;\n        \u2022 &lt;b&gt;ArrayList&lt;/b&gt;:&lt;br/&gt;  - Capacidad: 1000 \u00d7 4 = 4000 bytes&lt;br/&gt;  + overhead: 24 bytes&lt;br/&gt;  \u2192 &lt;b&gt;Total: ~4024 bytes&lt;/b&gt;&lt;br/&gt;&lt;br/&gt;\n        \u2022 &lt;b&gt;LinkedList&lt;/b&gt;:&lt;br/&gt;  - Por nodo: 4 + 40 = 44 bytes&lt;br/&gt;  - 1000 nodos: 1000 \u00d7 44 = 44000 bytes&lt;br/&gt;  + overhead lista: 24 bytes&lt;br/&gt;  \u2192 &lt;b&gt;Total: ~44024 bytes&lt;/b&gt;&lt;br/&gt;&lt;br/&gt;\n        &lt;b&gt;LinkedList usa ~11\u00d7 m\u00e1s memoria!&lt;/b&gt;\n        \"]\n\n        MemoriaArrayList --&gt; Conclusion1[\"\u2705 ArrayList: Memoria contigua&lt;br/&gt;\u2705 Mejor uso de cache&lt;br/&gt;\u2705 Menor overhead\"]\n        MemoriaLinkedList --&gt; Conclusion2[\"\u274c LinkedList: Memoria dispersa&lt;br/&gt;\u274c Peor localidad de cache&lt;br/&gt;\u274c Alto overhead por nodo\"]\n\n        style MemoriaArrayList fill:#e8f5e8,stroke:#1b5e20\n        style MemoriaLinkedList fill:#ffebee,stroke:#b71c1c\n        style EjemploNumerico fill:#fff3e0,stroke:#ff6f00\n        style Conclusion1 fill:#c8e6c9\n        style Conclusion2 fill:#ffcdd2\n    end\n</code></pre> <p><code>LinkedList</code> tiene otras ventajas que nos puede llevar a su uso. Implementa las interfaces <code>java.util.Queue</code> y <code>java.util.Deque</code>. Dichas interfaces permiten hacer uso de las listas como si fueran una cola de prioridad o una pila, respectivamente.</p>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#python-deque","title":"Python deque","text":"<p>En Python, la estructura equivalente a LinkedList es <code>collections.deque</code> (cola doblemente terminada), que permite inserciones y eliminaciones eficientes en ambos extremos.</p> <pre><code>from collections import deque\n\n# Crear un deque\nd = deque(['a', 'b', 'c'])\nd.append('d')           # A\u00f1adir al final\nd.appendleft('z')       # A\u00f1adir al principio\nd.pop()                 # Eliminar del final\nd.popleft()             # Eliminar del principio\n</code></pre>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#kotlin-linkedlist","title":"Kotlin LinkedList","text":"<p>Kotlin tambi\u00e9n tiene LinkedList en su API de colecciones:</p> <pre><code>import java.util.LinkedList\n\nval linkedList = LinkedList&lt;String&gt;()\nlinkedList.add(\"A\")\nlinkedList.addFirst(\"Primero\")\nlinkedList.addLast(\"\u00daltimo\")\n</code></pre> <p>Las colas, tambi\u00e9n conocidas como colas de prioridad, son una lista pero que aportan m\u00e9todos para trabajar de forma diferente. \u00bfRecord\u00e1is una cola para que te atiendan en una ventanilla? Pues igual. Se trata de que el que primero llega es el primero en ser atendido (FIFO). Simplemente se aportan tres m\u00e9todos nuevos:</p> <ul> <li>meter en el final de la lista (<code>add</code> y <code>offer</code>)</li> <li>sacar y eliminar el elemento m\u00e1s antiguo (<code>poll</code>)</li> <li>examinar el elemento al principio de la lista sin eliminarlo (<code>peek</code>).</li> </ul> <p>Las pilas, mucho menos usadas, son todo lo contrario a las listas. Una pila es igual que una monta\u00f1a de hojas en blanco, para a\u00f1adir hojas nuevas se ponen encima del resto, y para retirar una se coge la primera que hay, encima de todas. En las pilas el \u00faltimo en llegar es el primero en ser atendido. Para ello se proveen de tres m\u00e9todos:</p> <ul> <li>meter al principio de la pila (<code>push</code>)</li> <li>sacar y eliminar del principio de la pila (<code>pop</code>)</li> <li>examinar el primer elemento de la pila (<code>peek</code>, igual que si usara la lista como una cola).</li> </ul>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#arraylist-vs-linkedlist_1","title":"ArrayList vs. LinkedList","text":"<p>La clase LinkedList es una colecci\u00f3n que puede contener muchos objetos del mismo tipo, al igual que ArrayList.</p> <p>La clase LinkedList tiene todos los mismos m\u00e9todos que la clase ArrayList porque ambas implementan la interfaz List. Esto significa que puede agregar elementos, cambiar elementos, eliminar elementos y limpiar la lista de la misma manera.</p> <p>Sin embargo, si bien la clase ArrayList y la clase LinkedList se pueden usar de la misma manera, se construyen de manera muy diferente.</p>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#como-funciona-arraylist","title":"C\u00f3mo funciona ArrayList","text":"<p>La clase ArrayList tiene una matriz regular dentro de ella. Cuando se agrega un elemento, se coloca en la matriz. Si la matriz no es lo suficientemente grande, se crea una matriz nueva, m\u00e1s grande, para reemplazar la anterior y se elimina la anterior.</p>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#como-funciona-linkedlist","title":"C\u00f3mo funciona LinkedList","text":"<p>La LinkedList almacena sus elementos en \"contenedores\". La lista tiene un v\u00ednculo al primer contenedor y cada contenedor tiene un v\u00ednculo al siguiente contenedor en la lista. Para agregar un elemento a la lista, el elemento se coloca en un nuevo contenedor y ese contenedor se vincula a uno de los otros contenedores de la lista.</p> <p>Cu\u00e1ndo se usa Use una ArrayList para almacenar y acceder a los datos, y LinkedList para manipularlos.</p>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#metodos-de-linkedlist","title":"M\u00e9todos de LinkedList","text":"<p>En muchos casos, ArrayList es m\u00e1s eficiente, ya que es com\u00fan necesitar acceso a elementos aleatorios en la lista, pero LinkedList proporciona varios m\u00e9todos para realizar ciertas operaciones de manera m\u00e1s eficiente:</p> M\u00e9todo Descripci\u00f3n Java Kotlin Python (deque) A\u00f1adir primero Agrega al principio <code>addFirst()</code> <code>addFirst()</code> <code>appendleft()</code> A\u00f1adir \u00faltimo Agrega al final <code>addLast()</code> <code>addLast()</code> <code>append()</code> Eliminar primero Elimina del principio <code>removeFirst()</code> <code>removeFirst()</code> <code>popleft()</code> Eliminar \u00faltimo Elimina del final <code>removeLast()</code> <code>removeLast()</code> <code>pop()</code> Obtener primero Obtiene primer elemento <code>getFirst()</code> <code>first()</code> <code>[0]</code> Obtener \u00faltimo Obtiene \u00faltimo elemento <code>getLast()</code> <code>last()</code> <code>[-1]</code> JavaKotlinPython <pre><code>import java.util.LinkedList;\n\npublic class Main {\n    public static void main(String[] args) {\n        LinkedList&lt;String&gt; coches = new LinkedList&lt;String&gt;();\n        coches.add(\"Volvo\");\n        coches.add(\"BMW\");\n        coches.add(\"Ford\");\n        coches.add(\"Mazda\");\n\n\n        coches.addFirst(\"SEAT\"); //A\u00f1adimos a principio de la lista\n        System.out.println(coches);\n        coches.addLast(\"MG\"); //A\u00f1adimos al final de la lista\n        System.out.println(coches);\n        coches.removeFirst(); // Eliminamos el primero\n        System.out.println(coches);\n        coches.removeLast(); // Eliminamos el \u00faltimo\n        System.out.println(coches);\n        String primero = coches.getFirst(); // Obtenemos el primer coche\n        String ultimo = coches.getLast(); // Obtenemos el \u00faltimo coche\n        coches.remove(2);\n        System.out.println(coches);\n    }\n}\n</code></pre> <pre><code>fun main() {\n    val coches = LinkedList&lt;String&gt;()\n    coches.add(\"Volvo\")\n    coches.add(\"BMW\")\n    coches.add(\"Ford\")\n    coches.add(\"Mazda\")\n\n    coches.addFirst(\"SEAT\") // A\u00f1adimos a principio de la lista\n    println(coches)\n    coches.addLast(\"MG\") // A\u00f1adimos al final de la lista\n    println(coches)\n    coches.removeFirst() // Eliminamos el primero\n    println(coches)\n    coches.removeLast() // Eliminamos el \u00faltimo\n    println(coches)\n    val primero = coches.first // Obtenemos el primer coche\n    val ultimo = coches.last // Obtenemos el \u00faltimo coche\n    coches.removeAt(2)\n    println(coches)\n}\n</code></pre> <pre><code>from collections import deque\n\ncoches = deque([\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"])\n\ncoches.appendleft(\"SEAT\")  # A\u00f1adimos a principio de la lista\nprint(coches)\ncoches.append(\"MG\")  # A\u00f1adimos al final de la lista\nprint(coches)\ncoches.popleft()  # Eliminamos el primero\nprint(coches)\ncoches.pop()  # Eliminamos el \u00faltimo\nprint(coches)\nprimero = coches[0]  # Obtenemos el primer coche\nultimo = coches[-1]  # Obtenemos el \u00faltimo coche\ndel coches[2]\nprint(coches)\n</code></pre>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#34-ordenacion-de-listas","title":"3.4 Ordenaci\u00f3n de listas","text":"<p>Otra clase \u00fatil en el paquete java.util es la clase Collections, que incluye el m\u00e9todo sort() para ordenar listas alfab\u00e9ticamente o num\u00e9ricamente. Sirven tanto para ArrayList como para LinkedList</p> <p>Por defecto la ordenaci\u00f3n es ascendente.</p> <p>Java:</p> Java LinkedListJava ArrayListKotlinPythonPython ordenacion <pre><code>import java.util.Collections;\nimport java.util.LinkedList;\n\npublic class Main {\n    public static void main(String[] args) {\n        LinkedList&lt;String&gt; coches = new LinkedList&lt;String&gt;();\n        coches.add(\"Volvo\");\n        coches.add(\"BMW\");\n        coches.add(\"Ford\");\n        coches.add(\"Mazda\");\n        coches.add(\"Audi\");\n        coches.add(\"SEAT\");\n        coches.add(\"Tesla\");\n\n        // Ordenaci\u00f3n ascendente alfabeticamente\n        Collections.sort(coches);\n        System.out.println(coches);\n\n        // Ordenaci\u00f3n descendente alfabeticamente\n        Collections.sort(coches, Collections.reverseOrder());\n        System.out.println(coches);\n    }\n}\n</code></pre> <pre><code>import java.util.ArrayList;\nimport java.util.Collections;  // Import the Collections class\n\npublic class Main {\n    public static void main(String[] args) {\n        ArrayList&lt;Integer&gt; numeros = new ArrayList&lt;Integer&gt;();\n        numeros.add(33);\n        numeros.add(15);\n        numeros.add(20);\n        numeros.add(34);\n        numeros.add(8);\n        numeros.add(12);\n\n        // La ordenamos ascendentemente\n        Collections.sort(numeros);\n        System.out.println(\"Ascendente\");\n        System.out.println(\"*\".repeat(20));\n\n        for (int i : numeros) {\n            System.out.println(i);\n        }\n        // La ordenamos descendentemente\n        Collections.sort(numeros, Collections.reverseOrder()); // Sort myNumbers\n        System.out.println(\"Descendente\");\n        System.out.println(\"*\".repeat(20));\n        for (int i : numeros) {\n            System.out.println(i);\n        }\n    }\n}\n</code></pre> <pre><code>fun main() {\n    val coches = mutableListOf(\"Volvo\", \"BMW\", \"Ford\", \"Mazda\", \"Audi\", \"SEAT\", \"Tesla\")\n\n    // Ordenaci\u00f3n ascendente alfab\u00e9ticamente\n    coches.sort()\n    println(coches)\n\n    // Ordenaci\u00f3n descendente alfab\u00e9ticamente\n    coches.sortDescending()\n    println(coches)\n}\n\nfun main() {\n    val numeros = mutableListOf(33, 15, 20, 34, 8, 12)\n\n    // Ordenamos ascendentemente\n    numeros.sort()\n    println(\"Ascendente\")\n    println(\"*\".repeat(20))\n\n    for (i in numeros) {\n        println(i)\n    }\n\n    // Ordenamos descendentemente\n    numeros.sortDescending()\n    println(\"Descendente\")\n    println(\"*\".repeat(20))\n    for (i in numeros) {\n        println(i)\n    }\n}\n</code></pre> <pre><code>coches = [\"Volvo\", \"BMW\", \"Ford\", \"Mazda\", \"Audi\", \"SEAT\", \"Tesla\"]\n\n# Ordenaci\u00f3n ascendente alfab\u00e9ticamente\ncoches.sort()\nprint(coches)\n\n# Ordenaci\u00f3n descendente alfab\u00e9ticamente\ncoches.sort(reverse=True)\nprint(coches)\n</code></pre> <pre><code>numeros = [33, 15, 20, 34, 8, 12]\n\n# Ordenamos ascendentemente\nnumeros.sort()\nprint(\"Ascendente\")\nprint(\"*\" * 20)\n\nfor i in numeros:\n    print(i)\n\n# Ordenamos descendentemente\nnumeros.sort(reverse=True)\nprint(\"Descendente\")\nprint(\"*\" * 20)\nfor i in numeros:\n    print(i)\n</code></pre>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#4-mapas-hashmapdictionary","title":"4. Mapas (HashMap/Dictionary)","text":"<p>En el apartado de ArrayList, aprendiste que los Arrays almacenan elementos como una colecci\u00f3n ordenada y que debes acceder a ellos con un n\u00famero de \u00edndice (tipo int). Sin embargo, un HashMap almacena elementos en pares \"clave/valor\" y puedes acceder a ellos mediante un \u00edndice de otro tipo (por ejemplo, una cadena).</p> <p>Un objeto se usa como clave (\u00edndice) para otro objeto (valor). Puede almacenar diferentes tipos: claves de tipo String y valores de tipo int, o el mismo tipo, como: claves de tipo String y valores de tipo String:</p> JavaKotlinPython <pre><code>import java.util.HashMap; // import the HashMap class\n\npublic class Main {\n    public static void main(String[] args) {\n        // Creamos un HashMap que almacena capitales de provincia\n        HashMap&lt;String, String&gt; CapitalesProvincia = new HashMap&lt;String, String&gt;();\n\n        // A\u00f1adimos las claves y los valores keys and values (Provincia, Ciudad)\n        // El m\u00e9todo que se utiliza es put\n        CapitalesProvincia.put(\"Valencia\", \"Valencia\");\n        CapitalesProvincia.put(\"Castell\u00f3n\", \"Castell\u00f3n de la Plana\");\n        CapitalesProvincia.put(\"Alicante\", \"Alicante\");\n        CapitalesProvincia.put(\"Alava\", \"Victoria\");\n        CapitalesProvincia.put(\"Gipuzcoa\", \"San Sebasti\u00e1n\");\n        CapitalesProvincia.put(\"Vizcaya\", \"Bilbao\");\n\n        // Acceder a un elemento. Se hace por la clave\n        String capital = CapitalesProvincia.get(\"Vizcaya\");\n\n        // Eliminar un elemento. Se hace de nuevo por clave\n        CapitalesProvincia.remove(\"Valencia\");\n\n        // Eliminar todos los elementos\n        CapitalesProvincia.clear();\n\n        // Obtener el tama\u00f1o del HashMap\n        int tama\u00f1o = CapitalesProvincia.size();\n    }\n}\n</code></pre> <pre><code>fun main() {\n    // Creamos un HashMap que almacena capitales de provincia\n    val capitalesProvincia = mutableMapOf&lt;String, String&gt;()\n\n    // A\u00f1adimos las claves y los valores (Provincia, Ciudad)\n    capitalesProvincia[\"Valencia\"] = \"Valencia\"\n    capitalesProvincia[\"Castell\u00f3n\"] = \"Castell\u00f3n de la Plana\"\n    capitalesProvincia[\"Alicante\"] = \"Alicante\"\n    capitalesProvincia[\"Alava\"] = \"Victoria\"\n    capitalesProvincia[\"Gipuzcoa\"] = \"San Sebasti\u00e1n\"\n    capitalesProvincia[\"Vizcaya\"] = \"Bilbao\"\n\n    // Acceder a un elemento. Se hace por la clave\n    val capital = capitalesProvincia[\"Vizcaya\"]\n\n    // Eliminar un elemento. Se hace de nuevo por clave\n    capitalesProvincia.remove(\"Valencia\")\n\n    // Eliminar todos los elementos\n    capitalesProvincia.clear()\n\n    // Obtener el tama\u00f1o del HashMap\n    val tama\u00f1o = capitalesProvincia.size\n}\n</code></pre> <pre><code># Creamos un diccionario que almacena capitales de provincia\ncapitales_provincia = {}\n\n# A\u00f1adimos las claves y los valores (Provincia, Ciudad)\ncapitales_provincia[\"Valencia\"] = \"Valencia\"\ncapitales_provincia[\"Castell\u00f3n\"] = \"Castell\u00f3n de la Plana\"\ncapitales_provincia[\"Alicante\"] = \"Alicante\"\ncapitales_provincia[\"Alava\"] = \"Victoria\"\ncapitales_provincia[\"Gipuzcoa\"] = \"San Sebasti\u00e1n\"\ncapitales_provincia[\"Vizcaya\"] = \"Bilbao\"\n\n# Acceder a un elemento. Se hace por la clave\ncapital = capitales_provincia.get(\"Vizcaya\")\n\n# Eliminar un elemento. Se hace de nuevo por clave\ncapitales_provincia.pop(\"Valencia\", None)\n\n# Eliminar todos los elementos\ncapitales_provincia.clear()\n\n# Obtener el tama\u00f1o del diccionario\ntama\u00f1o = len(capitales_provincia)\n</code></pre>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#41-recorrer-un-hashmap-en-bucle","title":"4.1 Recorrer un HashMap en bucle","text":"<p>Recorrer los elementos de un HashMap con un bucle for-each.</p> <p>Nota: utilice el m\u00e9todo keySet() si solo desea las claves y el m\u00e9todo values() si solo desea los valores:</p> JavaKotlinPython <pre><code>import java.util.HashMap; // import the HashMap class\n\npublic class Main {\n    public static void main(String[] args) {\n        // Creamos un HashMap que almacena capitales de provincia\n        HashMap&lt;String, String&gt; CapitalesProvincia = new HashMap&lt;String, String&gt;();\n\n        // A\u00f1adimos las claves y los valores keys and values (Provincia, Ciudad)\n        // El m\u00e9todo que se utiliza es put\n        CapitalesProvincia.put(\"Valencia\", \"Valencia\");\n        CapitalesProvincia.put(\"Castell\u00f3n\", \"Castell\u00f3n de la Plana\");\n        CapitalesProvincia.put(\"Alicante\", \"Alicante\");\n        CapitalesProvincia.put(\"Alava\", \"Victoria\");\n        CapitalesProvincia.put(\"Gipuzcoa\", \"San Sebasti\u00e1n\");\n        CapitalesProvincia.put(\"Vizcaya\", \"Bilbao\");\n        System.out.println(\"*\".repeat(30));\n        // Imprimimos las claves\n        for (String i : CapitalesProvincia.keySet()) {\n            System.out.println(i);\n        }\n        System.out.println(\"*\".repeat(30));\n        // Imprimimos los valores\n        for (String i : CapitalesProvincia.values()) {\n            System.out.println(i);\n        }\n        System.out.println(\"*\".repeat(30));\n        // Obtengo las claves y los valores\n\n        // Print keys and values\n        for (String i : CapitalesProvincia.keySet()) {\n            System.out.println(\"Clave: \" + i + \" Valor: \" + CapitalesProvincia.get(i));\n        }\n    }\n}\n</code></pre> <pre><code>fun main() {\n    // Creamos un HashMap que almacena capitales de provincia\n    val capitalesProvincia = mutableMapOf(\n        \"Valencia\" to \"Valencia\",\n        \"Castell\u00f3n\" to \"Castell\u00f3n de la Plana\",\n        \"Alicante\" to \"Alicante\",\n        \"Alava\" to \"Victoria\",\n        \"Gipuzcoa\" to \"San Sebasti\u00e1n\",\n        \"Vizcaya\" to \"Bilbao\"\n    )\n\n    println(\"*\".repeat(30))\n    // Imprimimos las claves\n    for (clave in capitalesProvincia.keys) {\n        println(clave)\n    }\n\n    println(\"*\".repeat(30))\n    // Imprimimos los valores\n    for (valor in capitalesProvincia.values) {\n        println(valor)\n    }\n\n    println(\"*\".repeat(30))\n    // Obtengo las claves y los valores\n    for ((clave, valor) in capitalesProvincia) {\n        println(\"Clave: $clave Valor: $valor\")\n    }\n}\n</code></pre> <pre><code># Creamos un diccionario que almacena capitales de provincia\ncapitales_provincia = {\n    \"Valencia\": \"Valencia\",\n    \"Castell\u00f3n\": \"Castell\u00f3n de la Plana\",\n    \"Alicante\": \"Alicante\",\n    \"Alava\": \"Victoria\",\n    \"Gipuzcoa\": \"San Sebasti\u00e1n\",\n    \"Vizcaya\": \"Bilbao\"\n}\n\nprint(\"*\" * 30)\n# Imprimimos las claves\nfor clave in capitales_provincia.keys():\n    print(clave)\n\nprint(\"*\" * 30)\n# Imprimimos los valores\nfor valor in capitales_provincia.values():\n    print(valor)\n\nprint(\"*\" * 30)\n# Obtengo las claves y los valores\nfor clave, valor in capitales_provincia.items():\n    print(f\"Clave: {clave} Valor: {valor}\")\n</code></pre>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#metodos-principales-de-hashmap","title":"M\u00e9todos Principales de HashMap","text":"<pre><code>graph TB\n    subgraph \"M\u00e9todos de HashMap&lt;K, V&gt;\"\n        HashMapClass[\"&lt;b&gt;Clase HashMap&lt;K,V&gt;&lt;/b&gt;&lt;br/&gt;java.util.HashMap&lt;br/&gt;Implementa Map&lt;K,V&gt;\"]\n\n        HashMapClass --&gt; OperacionesBasicas[\"&lt;b&gt;Operaciones B\u00e1sicas&lt;/b&gt;\"]\n        HashMapClass --&gt; OperacionesInsercion[\"&lt;b&gt;Inserci\u00f3n/Actualizaci\u00f3n&lt;/b&gt;\"]\n        HashMapClass --&gt; OperacionesConsulta[\"&lt;b&gt;Consulta/Verificaci\u00f3n&lt;/b&gt;\"]\n        HashMapClass --&gt; OperacionesVista[\"&lt;b&gt;Vistas del Mapa&lt;/b&gt;\"]\n        HashMapClass --&gt; OperacionesAvanzadas[\"&lt;b&gt;Operaciones Avanzadas (Java 8+)&lt;/b&gt;\"]\n\n        OperacionesBasicas --&gt; B1[\"V put(K key, V value)&lt;br/&gt;O(1)* - Inserta o actualiza\"]\n        OperacionesBasicas --&gt; B2[\"V get(Object key)&lt;br/&gt;O(1)* - Obtiene valor por clave\"]\n        OperacionesBasicas --&gt; B3[\"V remove(Object key)&lt;br/&gt;O(1)* - Elimina por clave\"]\n        OperacionesBasicas --&gt; B4[\"int size()&lt;br/&gt;O(1) - N\u00famero de entradas\"]\n        OperacionesBasicas --&gt; B5[\"boolean isEmpty()&lt;br/&gt;O(1) - Verifica si est\u00e1 vac\u00edo\"]\n        OperacionesBasicas --&gt; B6[\"void clear()&lt;br/&gt;O(n) - Elimina todas las entradas\"]\n\n        OperacionesInsercion --&gt; I1[\"void putAll(Map m)&lt;br/&gt;O(k) - Inserta m\u00faltiples\"]\n        OperacionesInsercion --&gt; I2[\"V putIfAbsent(K key, V value)&lt;br/&gt;O(1)* - Inserta si no existe\"]\n        OperacionesInsercion --&gt; I3[\"V compute(K key, BiFunction)&lt;br/&gt;O(1)* - Calcula valor\"]\n        OperacionesInsercion --&gt; I4[\"V merge(K key, V value, BiFunction)&lt;br/&gt;O(1)* - Fusiona valores\"]\n\n        OperacionesConsulta --&gt; C1[\"boolean containsKey(Object key)&lt;br/&gt;O(1)* - Verifica clave\"]\n        OperacionesConsulta --&gt; C2[\"boolean containsValue(Object value)&lt;br/&gt;O(n) - Verifica valor\"]\n        OperacionesConsulta --&gt; C3[\"V getOrDefault(K key, V defaultValue)&lt;br/&gt;O(1)* - Obtiene con default\"]\n\n        OperacionesVista --&gt; V1[\"Set&lt;K&gt; keySet()&lt;br/&gt;O(1) - Conjunto de claves\"]\n        OperacionesVista --&gt; V2[\"Collection&lt;V&gt; values()&lt;br/&gt;O(1) - Colecci\u00f3n de valores\"]\n        OperacionesVista --&gt; V3[\"Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()&lt;br/&gt;O(1) - Conjunto de entradas\"]\n\n        OperacionesAvanzadas --&gt; A1[\"V computeIfAbsent(K key, Function)&lt;br/&gt;O(1)* - Calcula si ausente\"]\n        OperacionesAvanzadas --&gt; A2[\"V computeIfPresent(K key, BiFunction)&lt;br/&gt;O(1)* - Calcula si presente\"]\n        OperacionesAvanzadas --&gt; A3[\"void forEach(BiConsumer)&lt;br/&gt;O(n) - Itera sobre entradas\"]\n        OperacionesAvanzadas --&gt; A4[\"V replace(K key, V value)&lt;br/&gt;O(1)* - Reemplaza si existe\"]\n\n        Nota[\"* O(1) promedio, O(n) en peor caso&lt;br/&gt;con muchas colisiones de hash\"]\n\n        style B1 fill:#fff3e0\n        style B2 fill:#e8f5e8\n        style B3 fill:#fff3e0\n        style B4 fill:#e8f5e8\n        style B5 fill:#e8f5e8\n        style B6 fill:#ffebee\n        style I1 fill:#ffebee\n        style I2 fill:#fff3e0\n        style I3 fill:#fff3e0\n        style I4 fill:#fff3e0\n        style C1 fill:#e8f5e8\n        style C2 fill:#ffebee\n        style C3 fill:#e8f5e8\n        style V1 fill:#e8f5e8\n        style V2 fill:#e8f5e8\n        style V3 fill:#e8f5e8\n        style A1 fill:#fff3e0\n        style A2 fill:#fff3e0\n        style A3 fill:#ffebee\n        style A4 fill:#fff3e0\n    end\n</code></pre>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#constructores-y-configuracion-de-hashmap","title":"Constructores y Configuraci\u00f3n de HashMap","text":"<pre><code>graph LR\n    subgraph \"Constructores y Configuraci\u00f3n\"\n        Constructores[\"&lt;b&gt;Constructores HashMap&lt;/b&gt;\"] --&gt; C1[\"HashMap()&lt;br/&gt;Capacidad: 16, Load Factor: 0.75\"]\n        Constructores --&gt; C2[\"HashMap(int capacidad)&lt;br/&gt;Especifica capacidad inicial\"]\n        Constructores --&gt; C3[\"HashMap(int cap, float loadFactor)&lt;br/&gt;Capacidad y factor de carga\"]\n        Constructores --&gt; C4[\"HashMap(Map m)&lt;br/&gt;Copia otro mapa\"]\n\n        Parametros[\"&lt;b&gt;Par\u00e1metros Importantes&lt;/b&gt;\"] --&gt; P1[\"&lt;b&gt;Capacidad inicial&lt;/b&gt;&lt;br/&gt;N\u00famero de buckets iniciales&lt;br/&gt;Por defecto: 16\"]\n        Parametros --&gt; P2[\"&lt;b&gt;Load Factor&lt;/b&gt;&lt;br/&gt;Umbral para redimensionar&lt;br/&gt;Por defecto: 0.75\"]\n        Parametros --&gt; P3[\"&lt;b&gt;Umbral&lt;/b&gt;&lt;br/&gt;capacity \u00d7 loadFactor&lt;br/&gt;Cuando supera, se redimensiona\"]\n\n        Optimizacion[\"&lt;b&gt;Consejos de Optimizaci\u00f3n&lt;/b&gt;\"] --&gt; O1[\"new HashMap&lt;&gt;(n) si conoces tama\u00f1o\"]\n        Optimizacion --&gt; O2[\"Load factor m\u00e1s alto \u2192 menos redimensiones\"]\n        Optimizacion --&gt; O3[\"Load factor m\u00e1s bajo \u2192 menos colisiones\"]\n        Optimizacion --&gt; O4[\"Capacidad = tama\u00f1o_esperado / loadFactor\"]\n\n        Ejemplo[\"&lt;b&gt;Ejemplo:&lt;/b&gt;&lt;br/&gt;Esperas 1000 elementos&lt;br/&gt;new HashMap&lt;&gt;(1334) // 1000/0.75\"]\n\n        style C1 fill:#fff3e0\n        style C2 fill:#e8f5e8\n        style C3 fill:#e8f5e8\n        style C4 fill:#fff3e0\n        style P1 fill:#e3f2fd\n        style P2 fill:#e3f2fd\n        style P3 fill:#e3f2fd\n        style Optimizacion fill:#fff3e0\n    end\n</code></pre>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#comparativa-directa-hashmap-vs-arraylist","title":"Comparativa Directa: HashMap vs ArrayList","text":"<pre><code>graph TB\n    subgraph \"Comparativa HashMap vs ArrayList\"\n        Criterio[\"&lt;b&gt;Criterio&lt;/b&gt;\"] --&gt; HashMapComp[\"&lt;b&gt;HashMap&lt;/b&gt;\"]\n        Criterio --&gt; ArrayListComp[\"&lt;b&gt;ArrayList&lt;/b&gt;\"]\n        Criterio --&gt; Diferencia[\"&lt;b&gt;Diferencia Clave&lt;/b&gt;\"]\n\n        Criterio --&gt; C1[\"Estructura de datos\"]\n        Criterio --&gt; C2[\"Acceso a elementos\"]\n        Criterio --&gt; C3[\"B\u00fasqueda por clave/valor\"]\n        Criterio --&gt; C4[\"Inserci\u00f3n\"]\n        Criterio --&gt; C5[\"Eliminaci\u00f3n\"]\n        Criterio --&gt; C6[\"Orden de elementos\"]\n        Criterio --&gt; C7[\"Permite duplicados\"]\n        Criterio --&gt; C8[\"Uso de memoria\"]\n        Criterio --&gt; C9[\"Iteraci\u00f3n\"]\n        Criterio --&gt; C10[\"Caso de uso ideal\"]\n\n        HashMapComp --&gt; HC1[\"Tabla hash con buckets\"]\n        HashMapComp --&gt; HC2[\"Por clave: O(1)&lt;br/&gt;Por valor: O(n)\"]\n        HashMapComp --&gt; HC3[\"containsKey: O(1)&lt;br/&gt;containsValue: O(n)\"]\n        HashMapComp --&gt; HC4[\"O(1) promedio\"]\n        HashMapComp --&gt; HC5[\"O(1) promedio por clave\"]\n        HashMapComp --&gt; HC6[\"&lt;b&gt;NO ordenado&lt;/b&gt;&lt;br/&gt;(LinkedHashMap s\u00ed)\"]\n        HashMapComp --&gt; HC7[\"Claves: NO&lt;br/&gt;Valores: S\u00cd\"]\n        HashMapComp --&gt; HC8[\"Alto overhead&lt;br/&gt;~40 bytes por entrada\"]\n        HashMapComp --&gt; HC9[\"keySet(), values(), entrySet()\"]\n        HashMapComp --&gt; HC10[\"Diccionarios, caches,&lt;br/&gt;\u00edndices r\u00e1pidos\"]\n\n        ArrayListComp --&gt; AC1[\"Array redimensionable\"]\n        ArrayListComp --&gt; AC2[\"Por \u00edndice: O(1)&lt;br/&gt;Por valor: O(n)\"]\n        ArrayListComp --&gt; AC3[\"contains: O(n)&lt;br/&gt;indexOf: O(n)\"]\n        ArrayListComp --&gt; AC4[\"Final: O(1)&lt;br/&gt;Medio: O(n)\"]\n        ArrayListComp --&gt; AC5[\"Final: O(1)&lt;br/&gt;Medio: O(n)\"]\n        ArrayListComp --&gt; AC6[\"&lt;b&gt;S\u00cd ordenado&lt;/b&gt;&lt;br/&gt;Por \u00edndice de inserci\u00f3n\"]\n        ArrayListComp --&gt; AC7[\"S\u00cd, elementos duplicados\"]\n        ArrayListComp --&gt; AC8[\"Bajo overhead&lt;br/&gt;~24 bytes + array\"]\n        ArrayListComp --&gt; AC9[\"\u00cdndices o iterador\"]\n        ArrayListComp --&gt; AC10[\"Listas ordenadas,&lt;br/&gt;arrays din\u00e1micos\"]\n\n        Diferencia --&gt; D1[\"Clave-Valor vs Solo Valor\"]\n        Diferencia --&gt; D2[\"Acceso por clave vs \u00edndice\"]\n        Diferencia --&gt; D3[\"HashMap para b\u00fasqueda r\u00e1pida\"]\n        Diferencia --&gt; D4[\"ArrayList para orden y secuencia\"]\n        Diferencia --&gt; D5[\"NO ordenado vs SI ordenado\"]\n        Diferencia --&gt; D6[\"Claves \u00fanicas vs elementos duplicados\"]\n        Diferencia --&gt; D7[\"Mayor memoria vs menor memoria\"]\n        Diferencia --&gt; D8[\"Diferentes formas de iterar\"]\n        Diferencia --&gt; D9[\"Casos de uso distintos\"]\n\n        style HC2 fill:#e8f5e8\n        style HC3 fill:#e3f2fd\n        style HC4 fill:#e8f5e8\n        style HC5 fill:#e8f5e8\n        style HC6 fill:#ffebee\n        style AC2 fill:#e8f5e8\n        style AC3 fill:#ffebee\n        style AC4 fill:#e3f2fd\n        style AC5 fill:#e3f2fd\n        style AC6 fill:#e8f5e8\n        style AC7 fill:#e8f5e8\n        style AC8 fill:#e8f5e8\n    end\n</code></pre>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#42-otros-tipos","title":"4.2 Otros tipos","text":"<p>Las claves y los valores de un HashMap son en realidad objetos. En los ejemplos anteriores, utilizamos objetos de tipo \"String\". Recuerda que un String en Java es un objeto (no un tipo primitivo). Para utilizar otros tipos, como int, debe especificar una clase contenedora equivalente: Integer. Para otros tipos primitivos, utilice: Boolean para boolean, Character para char, Double para double, etc.</p> JavaKotlinPython <pre><code>// Import the HashMap class\nimport java.util.HashMap;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Creamos el HashMap alumnos cuya clave es un String y los valores de tipo entero\n        HashMap&lt;String, Integer&gt; alumnos = new HashMap&lt;String, Integer&gt;();\n\n        // A\u00f1adimos clave y valor (Nombre, Edad)\n        alumnos.put(\"Pepe\", 12);\n        alumnos.put(\"Maria\", 33);\n        alumnos.put(\"Adela\", 18);\n\n        for (String i : alumnos.keySet()) {\n            System.out.println(\"Clave: \" + i + \" Valor: \" + alumnos.get(i));\n        }\n    }\n}\n</code></pre> <pre><code>fun main() {\n    // Creamos el mapa alumnos cuya clave es un String y los valores de tipo entero\n    val alumnos = mutableMapOf&lt;String, Int&gt;()\n\n    // A\u00f1adimos clave y valor (Nombre, Edad)\n    alumnos[\"Pepe\"] = 12\n    alumnos[\"Maria\"] = 33\n    alumnos[\"Adela\"] = 18\n\n    for ((nombre, edad) in alumnos) {\n        println(\"Clave: $nombre Valor: $edad\")\n    }\n}\n</code></pre> <pre><code># Creamos el diccionario alumnos cuya clave es un string y los valores de tipo entero\nalumnos = {}\n\n# A\u00f1adimos clave y valor (Nombre, Edad)\nalumnos[\"Pepe\"] = 12\nalumnos[\"Maria\"] = 33\nalumnos[\"Adela\"] = 18\n\nfor nombre, edad in alumnos.items():\n    print(f\"Clave: {nombre} Valor: {edad}\")\n</code></pre>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#5-conjuntos-hashsetset","title":"5. Conjuntos (HashSet/Set)","text":"<p>Un HashSet es una colecci\u00f3n de elementos donde cada elemento es \u00fanico y se encuentra en el paquete java.util:</p> JavaKotlinPython <pre><code>import java.util.HashSet;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Creaci\u00f3n del HashSet\n        HashSet&lt;String&gt; coches = new HashSet&lt;String&gt;();\n        // A\u00f1adimos elementos \u00fanicos\n        coches.add(\"Volvo\");\n        coches.add(\"BMW\");\n        coches.add(\"Ford\");\n        coches.add(\"Mazda\");\n        coches.add(\"Audi\");\n        coches.add(\"SEAT\");\n        coches.add(\"Tesla\");\n\n        // Comprobamos si un elemento existe. Retorna un booleano\n        boolean esta = coches.contains(\"Volvo\");\n\n        // Eliminamos un elemento\n        coches.remove(\"Volvo\");\n\n        // Eliminamos todos los elementos\n        coches.clear();\n\n        // Tama\u00f1o\n        int tama\u00f1o = coches.size();\n\n        // Bucle. Con un for each\n        for (String i : coches) {\n            System.out.println(i);\n            }\n        }\n    }\n</code></pre> <pre><code>fun main() {\n    // Creaci\u00f3n del HashSet\n    val coches = mutableSetOf&lt;String&gt;()\n    // A\u00f1adimos elementos \u00fanicos\n    coches.add(\"Volvo\")\n    coches.add(\"BMW\")\n    coches.add(\"Ford\")\n    coches.add(\"Mazda\")\n    coches.add(\"Audi\")\n    coches.add(\"SEAT\")\n    coches.add(\"Tesla\")\n\n    // Comprobamos si un elemento existe. Retorna un booleano\n    val esta = coches.contains(\"Volvo\")\n\n    // Eliminamos un elemento\n    coches.remove(\"Volvo\")\n\n    // Eliminamos todos los elementos\n    coches.clear()\n\n    // Tama\u00f1o\n    val tama\u00f1o = coches.size\n\n    // Bucle. Con un for each\n    for (i in coches) {\n        println(i)\n    }\n}\n</code></pre> <pre><code># Creaci\u00f3n del set\ncoches = set()\n# A\u00f1adimos elementos \u00fanicos\ncoches.add(\"Volvo\")\ncoches.add(\"BMW\")\ncoches.add(\"Ford\")\ncoches.add(\"Mazda\")\ncoches.add(\"Audi\")\ncoches.add(\"SEAT\")\ncoches.add(\"Tesla\")\n\n# Comprobamos si un elemento existe. Retorna un booleano\nesta = \"Volvo\" in coches\n\n# Eliminamos un elemento\ncoches.discard(\"Volvo\")  # O remove(), pero discard no lanza error si no existe\n\n# Eliminamos todos los elementos\ncoches.clear()\n\n# Tama\u00f1o\ntama\u00f1o = len(coches)\n\n# Bucle. Con un for each\nfor i in coches:\n    print(i)\n</code></pre>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#metodos-set-y-hashset-en-java","title":"M\u00e9todos Set y HashSet en Java","text":"<pre><code>---\ntitle: Jerarqu\u00eda de Interfaces y Clases Set en Java\n---\nclassDiagram\n    Collection &lt;|-- Set\n    Set &lt;|-- SortedSet\n    SortedSet &lt;|-- NavigableSet\n    Set &lt;|-- HashSet\n    HashSet &lt;|-- LinkedHashSet\n    NavigableSet &lt;|-- TreeSet\n\n    class Collection {\n        &lt;&lt;interface&gt;&gt;\n    }\n\n    class Set {\n        &lt;&lt;interface&gt;&gt;\n        +add(E e) boolean\n        +addAll(Collection c) boolean\n        +remove(Object o) boolean\n        +contains(Object o) boolean\n        +size() int\n        +isEmpty() boolean\n        +clear() void\n        +iterator() Iterator~E~\n    }\n\n    class HashSet {\n        +HashSet()\n        +HashSet(Collection c)\n        +HashSet(int initialCapacity)\n        +HashSet(int initialCapacity, float loadFactor)\n    }\n\n    class LinkedHashSet {\n        +LinkedHashSet()\n        +LinkedHashSet(Collection c)\n    }\n\n    class SortedSet {\n        &lt;&lt;interface&gt;&gt;\n        +first() E\n        +last() E\n        +headSet(E toElement) SortedSet~E~\n        +tailSet(E fromElement) SortedSet~E~\n    }\n\n    class NavigableSet {\n        &lt;&lt;interface&gt;&gt;\n        +lower(E e) E\n        +higher(E e) E\n        +floor(E e) E\n        +ceiling(E e) E\n    }\n\n    class TreeSet {\n        +TreeSet()\n        +TreeSet(Comparator comparator)\n    }\n</code></pre>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#operaciones-comunes-con-hashset","title":"Operaciones Comunes con HashSet","text":"<pre><code>---\ntitle: Operaciones Comunes con HashSet\n---\nflowchart TD\n    A[Crear HashSet] --&gt; B[Agregar elementos]\n    B --&gt; C{Verificar contenido}\n    C --&gt;|S\u00ed| D[Elemento existe]\n    C --&gt;|No| E[Elemento no existe]\n    B --&gt; F[Recorrer elementos]\n    F --&gt; G[Usar Iterator]\n    F --&gt; H[Usar for-each]\n    F --&gt; I[Usar Stream API]\n    B --&gt; J[Eliminar elementos]\n    J --&gt; K[Elemento removido]\n    J --&gt; L[Elemento no encontrado]\n    B --&gt; M[Convertir a Array]\n    B --&gt; N[Operaciones de conjunto&lt;br&gt;uni\u00f3n, intersecci\u00f3n, diferencia]\n</code></pre>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#flujo-de-trabajo-con-hashset-ejemplo-practico","title":"Flujo de Trabajo con HashSet - Ejemplo Pr\u00e1ctico","text":"<pre><code>---\ntitle: Flujo de Trabajo con HashSet - Ejemplo Pr\u00e1ctico\n---\nsequenceDiagram\n    participant Usuario\n    participant HashSet as HashSet&lt;String&gt;\n    participant Iterator\n\n    Usuario-&gt;&gt;HashSet: new HashSet&lt;&gt;()\n    Usuario-&gt;&gt;HashSet: add(\"Manzana\")\n    HashSet--&gt;&gt;Usuario: true\n    Usuario-&gt;&gt;HashSet: add(\"Banana\")\n    HashSet--&gt;&gt;Usuario: true\n    Usuario-&gt;&gt;HashSet: add(\"Manzana\")\n    Note over HashSet: Elemento duplicado\n    HashSet--&gt;&gt;Usuario: false\n\n    Usuario-&gt;&gt;HashSet: contains(\"Banana\")\n    HashSet--&gt;&gt;Usuario: true\n\n    Usuario-&gt;&gt;HashSet: iterator()\n    HashSet--&gt;&gt;Usuario: Iterator object\n\n    loop Iteraci\u00f3n\n        Iterator-&gt;&gt;Usuario: \"Manzana\"\n        Iterator-&gt;&gt;Usuario: \"Banana\"\n    end\n\n    Usuario-&gt;&gt;HashSet: remove(\"Manzana\")\n    HashSet--&gt;&gt;Usuario: true\n\n    Usuario-&gt;&gt;HashSet: size()\n    HashSet--&gt;&gt;Usuario: 1\n</code></pre> <p>Todo esto tambi\u00e9n lo podemos realizar con otras clases envolventes, Wrapper.</p>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#6-trabajando-con-colecciones","title":"6. Trabajando con colecciones","text":"<p>Cuando trabajemos con colecciones hay una serie de aspectos que es importante tener en cuenta:</p> <ol> <li>\u00bfC\u00f3mo crear colecciones de datos de los tipos primitivos (int, double, char o boolean)?</li> <li>\u00bfC\u00f3mo recorrer una colecci\u00f3n para trabajar con sus elementos?</li> <li>\u00bfQu\u00e9 posibilidades ofrecen los m\u00e9todos est\u00e1ticos de las diferentes colecciones?</li> <li>Diferencias ente objetos mutables e inmutables</li> </ol> <p>A continuaci\u00f3n, profundizaremos en estos aspectos.</p>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#61-clases-wrapper-o-envoltorio","title":"6.1. Clases Wrapper o envoltorio.","text":""},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#611-introduccion","title":"6.1.1. Introducci\u00f3n","text":"<p>\u00bfHab\u00e9is probado a crear un ArrayList de n\u00fameros enteros? \u00bfHa sido posible?</p> <p>Java: Seguramente al compilar se ha producido un error \"unexpected type\". Es decir, que el tipo int no era uno de los tipos esperados.</p> <p>Si repas\u00e1is lo que hemos visto sobre las colecciones, ver\u00e9is que son estructuras de datos que pueden almacenar elementos de cualquier tipo de clase. No nos dice nada de los tipos primitivos pero ya vemos que no los admite. Las colecciones son clase gen\u00e9ricas y pueden almacenar cualquier objeto o tipo referenciado (como las clases, arrays...). Los tipos primitivos (int, double, char o boolean) no se pueden usar como tipo de dato en las colecciones.</p> <p>Entonces \u00bfqu\u00e9 hacemos si necesitamos almacenar n\u00fameros pero en una colecci\u00f3n no podemos almacenar tipos primitivos? La respuestas son las denominadas clases Wrapper o envoltorio.</p> <p>Wrapper o envoltorio es el calificativo que se da a unas clases especiales cuyo \u00fanico objetivo es almacenar los tipo primitivos como clases. Es decir, son clases que tendr\u00e1n un \u00fanico atributo que coincidir\u00e1 con el tipo y el valor del tipo primitivo. De esta manera cuando necesitemos trabajar con objetos podremos seguir manejando n\u00fameros, letras y boleanos.</p> <p>Adem\u00e1s, se les ha a\u00f1adido una serie de m\u00e9todos que pueden resultar especialmente \u00fatiles.</p> <p>Las clases que necesitaremos para los tipos primitivos seras:</p> <ul> <li>Integer</li> <li>Double</li> <li>Boolean</li> <li>Char</li> </ul> <p>Kotlin: Kotlin tiene tipos integrados que corresponden a los tipos primitivos de Java, pero el compilador los optimiza autom\u00e1ticamente. Los tipos b\u00e1sicos en Kotlin son: <code>Int</code>, <code>Double</code>, <code>Boolean</code>, <code>Char</code>. Cuando se usan en colecciones, Kotlin autom\u00e1ticamente utiliza las clases envoltorio de Java cuando es necesario.</p> <p>Python: Python no distingue entre tipos primitivos y objetos; todos son objetos. Los tipos b\u00e1sicos son <code>int</code>, <code>float</code>, <code>bool</code>, <code>str</code>. Se pueden usar directamente en colecciones.</p>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#612-metodos-mas-usados","title":"6.1.2. M\u00e9todos m\u00e1s usados.","text":"<p>Java: Como el resto de clases tendr\u00e1n sus constructores propios:</p> <pre><code>Integer x = new Integer(34);\nDouble y = new Double(\"3.58\");\nint z = 61;\nInteger w = new Integer(z);\nBoolean bo = new Boolean(\"false\");\nCharacter co = new Character('a');\n</code></pre> <p>Adem\u00e1s, las clases Wrapper proporcionan los siguientes m\u00e9todos interesantes:</p> <pre><code>int a = x.intValue();\ndouble b = y.doubleValue();\nboolean c = bo.booleanValue();\nchar d = co.charValue();\n</code></pre> <p>M\u00e9todos de instancia para extraer el dato num\u00e9rico del envoltorio. xxxValue(). Permiten pasar de un objeto a un tipo primitivo. Se habla de \"Unboxing\".</p> <pre><code>int i = Integer.parseInt(\"123\");\ndouble d = Double.parseDouble(\"34.89\");\n</code></pre> <p>M\u00e9todos est\u00e1ticos de clase para crear n\u00fameros a partir de cadenas de caracteres. Xxx.parseXxx(String). Permiten leer texto por teclado o de un fichero y luego convertirlo a su tipo primitivo.</p> <p>Las clases envoltorio y en especial los m\u00e9todos parseXxx, son muy utilizados para leer datos tanto de ficheros como desde el teclado. Permiten leer todos los datos como texto con next, comprobar que cumplen un patr\u00f3n concreto y despu\u00e9s convertirlos al tipo adecuado.</p> <pre><code>Integer x = Integer.valueOf(\"123\");\nDouble y = Double.valueOf(\"34.89\");\n</code></pre> <p>M\u00e9todos est\u00e1ticos de clase para crear envoltorios de n\u00fameros a partir de cadenas de caracteres. Xxx.valueOf(String). Pasamos de un texto a un objeto de una de las clases envoltorio. Se habla de \"Boxing\".</p> KotlinPython <pre><code>// Conversiones en Kotlin\nval x = 34  // Int\nval y = \"3.58\".toDouble()\nval z = 61\nval w = z  // Asignaci\u00f3n directa\nval bo = \"false\".toBoolean()\nval co = 'a'\n\n// M\u00e9todos de conversi\u00f3n\nval a = x.toInt()\nval b = y.toDouble()\nval c = bo\nval d = co\n\n// Parseo de strings\nval i = \"123\".toInt()\nval d2 = \"34.89\".toDouble()\n\n// Conversi\u00f3n segura (devuelve null si falla)\nval iOrNull = \"123\".toIntOrNull()\nval dOrNull = \"34.89\".toDoubleOrNull()\n</code></pre> <pre><code># Conversiones en Python\nx = 34  # int\ny = float(\"3.58\")\nz = 61\nw = int(z)  # Aunque generalmente no es necesario\nbo = bool(\"false\")  # Cuidado: bool(\"false\") es True en Python\nco = 'a'\n\n# Conversiones entre tipos\na = int(x)\nb = float(y)\nc = bool(bo)\nd = str(co)\n\n# Parseo de strings\ni = int(\"123\")\nd2 = float(\"34.89\")\n\n# Conversi\u00f3n segura con try/except\ntry:\n    i_value = int(\"123\")\nexcept ValueError:\n    i_value = None\n\ntry:\n    d_value = float(\"34.89\")\nexcept ValueError:\n    d_value = None\n</code></pre>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#613-manejando-las-colecciones","title":"6.1.3. Manejando las colecciones.","text":"<p>Ya conocemos las clases envoltorio. \u00bfC\u00f3mo las usamos para crear colecciones?</p> <p>Java: Para crear una colecci\u00f3n, las usaremos igual que lo hemos hecho con cualquier otra clase en Java:</p> <pre><code>ArrayList&lt;Integer&gt; listaInt = new ArrayList&lt;Integer&gt;();\nArrayList&lt;Double&gt; listaDouble = new ArrayList&lt;Double&gt;();\nArrayList&lt;Character&gt; listaChar = new ArrayList&lt;Character&gt;();\n</code></pre> <p>A la hora de a\u00f1adir y leer elementos podemos utilizar los m\u00e9todos vistos en el apartado anterior:</p> <pre><code>// A\u00f1adir un elemento. Creamos un objeto Integer y lo a\u00f1adimos\nInteger x = new Integer(34);\nlistaInt.add(x);\n// Leer un valor. Obtenemos un objeto Integer y lo pasamos a int.\nx = listaInt.get(0);\nint num = x.intValue();\n</code></pre> <p>La buena noticia es que a partir de la version 5 de Java este proceso lo realiza Java autom\u00e1ticamente y podemos escribir:</p> <pre><code>// A\u00f1adir un elemento. A\u00f1adimos directamente un int y Java lo convierte en un objeto Integer\nlistaInt.add(34);\n\n// Leer un valor. Obtenemos un objeto Integer y Java lo pasa a int para poderlo almacenar\nint num = listaInt.get(0);\n</code></pre> <p>De esta manera, solo tendremos que usar la clase envoltorio para crear la colecci\u00f3n. En el resto de operaciones podemos trabajar con los tipos primitivos directamente y Java se encargar\u00e1 de realizar las conversiones necesarias.</p> KotlinPython <pre><code>// Listas con tipos b\u00e1sicos\nval listaInt = mutableListOf&lt;Int&gt;()\nval listaDouble = mutableListOf&lt;Double&gt;()\nval listaChar = mutableListOf&lt;Char&gt;()\n\n// A\u00f1adir elementos\nlistaInt.add(34)\nlistaDouble.add(3.14)\nlistaChar.add('a')\n\n// Leer elementos\nval num = listaInt[0]  // Devuelve Int directamente\n</code></pre> <pre><code># Listas con tipos b\u00e1sicos\nlista_int = []\nlista_float = []\nlista_str = []\n\n# A\u00f1adir elementos\nlista_int.append(34)\nlista_float.append(3.14)\nlista_str.append('a')\n\n# Leer elementos\nnum = lista_int[0]  # Devuelve int directamente\n</code></pre>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#614-leer-datos-segun-un-patron","title":"6.1.4.- Leer datos seg\u00fan un patr\u00f3n","text":"<p>Hemos visto que las clases envoltorio permiten convertir un texto a int o double mediante los m\u00e9todos parseInt y parseDouble. Pero, \u00bfpodr\u00edamos comprobar si esa cadena de caracteres es realmente un n\u00famero entero antes de convertirla para evitar que se produzca una excepci\u00f3n?</p> <p>Para ello, podr\u00edamos utilizar las expresiones regulares o regex de Java.</p> <p>Vamos a ver las caracter\u00edsticas que tiene los n\u00fameros int. Son n\u00fameros de 32-bit que van del -231 al 231-1. Es decir toman valores comprendidos entre el -2147483648 y el 2147483647. Identificar todos estos valores con una expresi\u00f3n regular es dif\u00edcil pero si los l\u00edmitamos a valores entre -999999999 y +999999999 la cosa se simplifica. Estar\u00edamos descartando algunos n\u00fameros enteros pero evitar\u00edamos excepciones.</p> <p>\u00bfC\u00f3mo ser\u00eda la expresi\u00f3n regular para ese rango de valores?</p> <ol> <li>Puede tener signo o no. Si lo tiene siempre ser\u00e1 -. La expresi\u00f3n ser\u00eda: -? que significa que el signo - puede aparecer o no.</li> <li>Todos los d\u00edgitos pueden tener valores entre 0 y 9. La expresi\u00f3n ser\u00eda: [0-9] o \\d que significa que los caracteres que pueden aparecer en la cadena son los d\u00edgitos del 0 al 9.</li> <li>Siempre debe aparecer al menos un d\u00edgito y como m\u00e1ximo 9. La expresi\u00f3n ser\u00eda: {1,9} que significa que un car\u00e1cter puede aparecer entre 1 y 9 veces.</li> </ol> <p>Si las juntamos, la expresi\u00f3n completa ser\u00e1:</p> <pre><code>-?[0-9]{1,9} \u00f3 -?\\\\d{1,9}\n</code></pre> <p>Es importante no dejar ning\u00fan espacio en blanco, ya que producir\u00e1 un error al ejecutarse.</p> JavaKotlinPython <pre><code>import java.util.Scanner;\nimport java.util.regex.Pattern;\nimport java.util.regex.Matcher;\n\nScanner leerDatos = new Scanner(System.in);\n// Pide palabras hasta que el texto introducido cumpla con el patr\u00f3n\nString dato = null;\nMatcher comparaFormato = null;\nPattern formatoInt = Pattern.compile(\"-?[0-9]{1,9}\");          // Genera la expresi\u00f3n regular para enteros\ndo {\n    System.out.println(\"Introduce un entero: \");\n    dato = leerDatos.next();\n    comparaFormato = formatoInt.matcher(dato);\n} while (!comparaFormato.matches());\n// Convierte el texto a un int\nint numero = Integer.parseInt(dato);\nSystem.out.println(numero + \" es un entero\");\n</code></pre> <pre><code>import java.util.Scanner\nimport kotlin.text.Regex\n\nval leerDatos = Scanner(System.`in`)\nvar dato: String\nval formatoInt = Regex(\"-?[0-9]{1,9}\")  // Expresi\u00f3n regular para enteros\n\ndo {\n    println(\"Introduce un entero: \")\n    dato = leerDatos.next()\n} while (!formatoInt.matches(dato))\n\n// Convierte el texto a un int\nval numero = dato.toInt()\nprintln(\"$numero es un entero\")\n</code></pre> <pre><code>import re\n\nformato_int = re.compile(r\"-?[0-9]{1,9}\")  # Expresi\u00f3n regular para enteros\n\nwhile True:\n    dato = input(\"Introduce un entero: \")\n    if formato_int.fullmatch(dato):\n        break\n    print(\"Por favor, introduce un n\u00famero entero v\u00e1lido\")\n\n# Convierte el texto a un int\nnumero = int(dato)\nprint(f\"{numero} es un entero\")\n</code></pre> <p>Las expresiones regulares las podemos usar tambi\u00e9n para comprobar que el texto introducido es un DNI v\u00e1lido, un correo electr\u00f3nico, un t\u00e9lefono o una fecha. Conviene consultar si existe la expresi\u00f3n que queremos usar antes de empezar a dise\u00f1ar una. Hay muchos ejemplos en Internet.</p>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#62-recorrer-una-coleccion","title":"6.2.- Recorrer una colecci\u00f3n","text":"<p>Para recorrer un array hemos usado el siguiente c\u00f3digo basado en un bucle for:</p> <p>Java:</p> <pre><code>String[] palabras = {\"Hola\", \"Kaixo\", \"Hello\"};\n\nfor (int i = 0; i &lt; palabras.length; i++) {\n    System.out.println(\"Elemento: \" + palabras[i]);\n}\n\nSystem.out.println(Arrays.toString(palabras));\n</code></pre> <p>Para ello, es indispensable que los elementos de la estructura de datos se referencien mediante un \u00edndice.</p> <p>Una estructura parecida nos puede servir tambi\u00e9n para las listas pero no para el resto de colecciones.</p> JavaKotlinPython <pre><code>ArrayList&lt;String&gt; lista = new ArrayList&lt;String&gt;();\nlista.add(\"Hola\");\nlista.add(\"Kaixo\");\nlista.add(\"Hello\");\nfor (int i = 0; i &lt; lista.size(); i++) {\n    System.out.println(\"Elemento: \" + lista.get(i));\n}\nSystem.out.println(lista);\n</code></pre> <pre><code>val lista = mutableListOf(\"Hola\", \"Kaixo\", \"Hello\")\nfor (i in lista.indices) {\n    println(\"Elemento: ${lista[i]}\")\n}\nprintln(lista)\n</code></pre> <pre><code>lista = [\"Hola\", \"Kaixo\", \"Hello\"]\nfor i in range(len(lista)):\n    print(f\"Elemento: {lista[i]}\")\nprint(lista)\n</code></pre> <p>Por ello, vamos a ver otras 2 maneras de recorrer colecciones expresamente dise\u00f1adas para ellas. Estas son:</p> <ol> <li>El bucle for-each</li> <li>La clase Iterator</li> </ol>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#621-bucle-for-each","title":"6.2.1.- Bucle for-each","text":"<p>El bucle \"for-each\" o bucle \"para cada\", se parece mucho a un bucle for con la diferencia de que no hace falta una variable i de inicializaci\u00f3n.</p> <p>Existe a partir de Java 5 y en principio puede resultar m\u00e1s c\u00f3moda y compacta que el uso de la clase Iterator. Sin embargo, como veremos, tendr\u00e1 sus limitaciones y en algunos casos deberemos recurrir obligatoriamente a los iteradores.</p> <p>Java: En el siguiente c\u00f3digo se usa un bucle for-each, en el que texto va tomando los valores de todos los elementos almacenados en el conjunto hasta que llega al \u00faltimo. En este caso, no se necesita ning\u00fan \u00edndice para recorrer la estructura de datos. La sentencia for-each se encarga de pasar por cada uno de los elementos y guardarlo en texto. F\u00edjate que se llama for-each pero solo se escribe for:</p> <pre><code>for (String texto : conjunto) { \n     System.out.println(\"Elemento almacenado: \" + texto); \n}\n</code></pre> <p>La estructura for-each es muy sencilla: la palabra <code>for</code> seguida de \"(tipoDatos nombre : estructura)\" y el cuerpo del bucle.</p> <ul> <li>tipoDatos es el tipo de dato que se ha utilizado para crear la estructura de datos. Puede ser una colecci\u00f3n pero tambi\u00e9n un Array.</li> <li>nombre es el nombre del objeto o la variable donde se almacenar\u00e1 cada elemento de la estructura</li> <li>estructura es el nombre de la colecci\u00f3n en s\u00ed.</li> </ul> <p>Kotlin:</p> <pre><code>val conjunto = listOf(\"Hola\", \"Kaixo\", \"Hello\")\nfor (texto in conjunto) {\n    println(\"Elemento almacenado: $texto\")\n}\n</code></pre> <p>Python:</p> <pre><code>conjunto = [\"Hola\", \"Kaixo\", \"Hello\"]\nfor texto in conjunto:\n    print(f\"Elemento almacenado: {texto}\")\n</code></pre> <p>Los bucles for-each se pueden usar para todas las colecciones y tambi\u00e9n para los arrays pero no permiten modificar la colecci\u00f3n dentro del bucle. Es decir, obtenemos el valor de cada elemento, podemos trabajar con \u00e9l pero no podr\u00edamos borrarlo. Para ello, habr\u00eda que recurrir a la clase Iterator.</p>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#622-iteradores","title":"6.2.2.- Iteradores.","text":"<p>\u00bfQu\u00e9 son los iteradores? Son un mecanismo que nos permite recorrer todos los elementos de una colecci\u00f3n de forma sencilla, de forma secuencial, y de forma segura.</p> <p>Cuando queremos modificar una colecci\u00f3n mientras la estamos recorriendo, en concreto cuando queremos borrar el \u00faltimo elemento que hemos procesado, necesitaremos utilizar iteradores. Adem\u00e1s, los podemos encontrar en programas de versiones antiguas de Java, anteriores a la aparici\u00f3n del bucle for-each.</p> <p>Ahora la pregunta es, \u00bfc\u00f3mo se crea un iterador? Pues creando un objeto de la clase Iterator a partir de la colecci\u00f3n que queremos recorrer. Es decir, invocando el m\u00e9todo \"<code>iterator()</code>\" de cualquier colecci\u00f3n.</p> <p>Java: Veamos un ejemplo en el que <code>t</code> es una colecci\u00f3n cualquiera:</p> <pre><code>Iterator&lt;String&gt; it = t.iterator();\n</code></pre> <p>Fijate que se ha especificado un par\u00e1metro para el tipo de dato gen\u00e9rico en el iterador (poniendo <code>\"&lt;String&gt;\"</code> despu\u00e9s de <code>Iterator</code>). Esto es porque los iteradores son tambi\u00e9n clases gen\u00e9ricas (podemos tener iteradores de cualquier clase), y es necesario especificar el tipo base que contendr\u00e1 el iterador. Sino se especifica el tipo base del iterador, igualmente nos permitir\u00eda recorrer la colecci\u00f3n, pero retornar\u00e1 objetos tipo <code>Object</code> (clase de la que derivan todas las clases), con lo que nos veremos obligados a forzar la conversi\u00f3n de tipo.</p> <p>Para recorrer y gestionar la colecci\u00f3n, el iterador ofrece tres m\u00e9todos b\u00e1sicos:</p> <ul> <li><code>boolean hasNext()</code>. Retornar\u00e1 true si le quedan m\u00e1s elementos a la colecci\u00f3n por visitar. False en caso contrario.</li> <li><code>E next()</code>. Retornar\u00e1 el siguiente elemento de la colecci\u00f3n, si no existe siguiente elemento, lanzar\u00e1 una excepci\u00f3n (<code>NoSuchElementException</code> para ser exactos), con lo que conviene chequear primero si el siguiente elemento existe.</li> <li><code>remove()</code>. Elimina de la colecci\u00f3n el \u00faltimo elemento retornado en la \u00faltima invocaci\u00f3n de next (no es necesario pasarselo por par\u00e1metro). Cuidado, si next no ha sido invocado todav\u00eda, saltar\u00e1 una incomoda excepci\u00f3n.</li> </ul> <p>\u00bfC\u00f3mo recorrer\u00edamos una colecci\u00f3n con estos m\u00e9todos? Pues de una forma muy parecida a como leemos datos por teclado y un fichero. Un bucle mientras (<code>while</code>) con la condici\u00f3n <code>hasNext()</code> nos permite hacerlo:</p> <pre><code>while (it.hasNext()) {        // Mientras que haya otro elemento, seguiremos en el bucle.\n   String t = it.next();      // Recogemos el siguiente elemento.\n   if (t.equals(\"borrar\")) {\n       it.remove();       // Si el elemento es igual a \"borrar\" es extra\u00eddo de la lista.\n   }\n}\n</code></pre> <p>\u00bfQu\u00e9 elementos contendr\u00eda la lista despu\u00e9s de ejecutar el bucle? Efectivamente, todas las palabras menos las que coinciden con \"borrar\".</p> <p>Tenemos que pensar que las listas permiten acceso posicional a trav\u00e9s de los m\u00e9todos <code>get</code> y <code>set</code>, y acceso secuencial a trav\u00e9s de iteradores, \u00bfcu\u00e1l es para t\u00ed la forma m\u00e1s c\u00f3moda de recorrer todos los elementos? \u00bfUn acceso posicional a trav\u00e9s un bucle \"<code>for (int i = 0; i &lt; lista.size(); i++)</code>\" o un acceso secuencial usando un bucle \"<code>while (iterador.hasNext())</code>\"?</p> <p>\u00bfQu\u00e9 inconvenientes tiene usar los iteradores sin especificar el tipo de objeto? En el siguiente ejemplo, se genera una lista con los n\u00fameros del 0 al 10. De la lista, se eliminan aquellos que son pares y solo se dejan los impares. En el primer ejemplo se especifica el tipo de objeto del iterador y en el segundo ejemplo no, observa el uso de la conversi\u00f3n de tipos en la l\u00ednea 6.</p> <pre><code>ArrayList &lt;Integer&gt; lista = new ArrayList&lt;Integer&gt;();\nfor (int i = 0; i &lt; 10; i++) {\n    lista.add(i);\n}\nIterator&lt;Integer&gt; it = lista.iterator();\nwhile (it.hasNext()) {\n    Integer t = it.next();\n    if (t % 2 == 0) {\n        it.remove();\n    }\n}\n</code></pre> <pre><code>ArrayList &lt;Integer&gt; lista = new ArrayList&lt;Integer&gt;();\nfor (int i = 0; i &lt; 10; i++)  {\n    lista.add(i);\n}\nIterator it = lista.iterator();\nwhile (it.hasNext()) {\n    Integer t = (Integer) it.next();\n    if (t % 2 == 0) {\n        it.remove();\n    }\n}\n</code></pre> <p>Kotlin:</p> <pre><code>val lista = mutableListOf&lt;Int&gt;()\nfor (i in 0..9) {\n    lista.add(i)\n}\n\nval iterator = lista.iterator()\nwhile (iterator.hasNext()) {\n    val t = iterator.next()\n    if (t % 2 == 0) {\n        iterator.remove()\n    }\n}\n</code></pre> <p>Python: Python tiene iteradores pero no tiene un m\u00e9todo <code>remove()</code> en sus iteradores. Para eliminar elementos mientras se itera, se debe usar una copia de la lista o una lista por comprensi\u00f3n:</p> <pre><code># M\u00e9todo 1: Usando una copia de la lista\nlista = list(range(10))\nfor item in lista[:]:  # Copia de la lista\n    if item % 2 == 0:\n        lista.remove(item)\n\n# M\u00e9todo 2: Usando list comprehension\nlista = list(range(10))\nlista = [x for x in lista if x % 2 != 0]\n\n# M\u00e9todo 3: Usando filter\nlista = list(range(10))\nlista = list(filter(lambda x: x % 2 != 0, lista))\n</code></pre> <p>Un iterador es seguro porque esta pensado para no sobrepasar los l\u00edmites de la colecci\u00f3n, ocultando operaciones m\u00e1s complicadas que pueden repercutir en errores de software. Pero realmente se convierte en inseguro cuando es necesario hacer la operaci\u00f3n de conversi\u00f3n de tipos. Si la colecci\u00f3n no contiene los objetos esperados, al intentar hacer la conversi\u00f3n, saltar\u00e1 una incomoda excepci\u00f3n. Usar gen\u00e9ricos aporta grandes ventajas, pero us\u00e1ndolos adecuadamente.</p> <p>Si al final usas iteradores, y piensas eliminar elementos de la colecci\u00f3n (e incluso de un mapa), debes usar el m\u00e9todo <code>remove</code> del iterador y no el de la colecci\u00f3n. Si eliminas los elementos utilizando el m\u00e9todo <code>remove</code> de la colecci\u00f3n, mientras est\u00e1s dentro de un bucle de iteraci\u00f3n, o dentro de un bucle for-each, los fallos que pueden producirse en tu programa son impredecibles. \u00bfLogras adivinar porqu\u00e9 se pueden producir dichos problemas?</p> <p>Los problemas son debidos a que el m\u00e9todo <code>remove</code> del iterador elimina el elemento de dos sitios: de la colecci\u00f3n y del iterador en s\u00ed (que mantiene interiormente informaci\u00f3n del orden de los elementos). Si usas el m\u00e9todo <code>remove</code> de la colecci\u00f3n, la informaci\u00f3n solo se elimina de un lugar, de la colecci\u00f3n.</p>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#623-listiterator-vs-iterator","title":"6.2.3.- ListIterator vs Iterator.","text":"<p>Iterator y ListIterator son los dos de los tres cursores de Java. Tanto Iterator como ListIterator est\u00e1n definidos por Collection Framework en el paquete Java.Util . ListIterator es la interfaz secundaria de la interfaz Iterator. La principal diferencia entre Iterator y ListIterator es que Iterator puede atravesar los elementos de la colecci\u00f3n solo en direcci\u00f3n hacia adelante, mientras que ListIterator puede atravesar los elementos en una colecci\u00f3n tanto en direcci\u00f3n hacia adelante como hacia atr\u00e1s .</p> <p>Algunas diferencias m\u00e1s entre Iterator y ListIterator con la ayuda del cuadro de comparaci\u00f3n que se muestra a continuaci\u00f3n.</p> Bases para la comparaci\u00f3n Iterador ListIterator BASIC El iterador puede atravesar los elementos en una colecci\u00f3n solo en direcci\u00f3n hacia adelante. ListIterator puede atravesar los elementos de una colecci\u00f3n tanto hacia delante como hacia atr\u00e1s. A\u00f1adir Iterator no puede agregar elementos a una colecci\u00f3n. ListIterator puede agregar elementos a una colecci\u00f3n. Modificar El iterador no puede modificar los elementos de una colecci\u00f3n. ListIterator puede modificar los elementos de una colecci\u00f3n usando set (). atravesar El iterador puede atravesar Mapa, Lista y Conjunto. ListIterator solo puede atravesar objetos de lista. \u00cdndice Iterator no tiene un m\u00e9todo para obtener un \u00edndice del elemento en una colecci\u00f3n. Usando ListIterator, puede obtener un \u00edndice del elemento en una colecci\u00f3n. <p>ListIterator es una interfaz en un marco de Colecci\u00f3n y extiende la interfaz Iterator . Usando ListIterator, puede recorrer los elementos de la colecci\u00f3n en ambas direcciones hacia adelante y hacia atr\u00e1s . Tambi\u00e9n puede agregar, eliminar o modificar cualquier elemento de la colecci\u00f3n. En resumen, podemos decir que elimina los inconvenientes del iterador.</p> <p>Los m\u00e9todos de ListIterator son los siguientes:</p> M\u00e9todo Descripci\u00f3n hasNext () si devuelve true, se confirma que hay m\u00e1s elementos en una colecci\u00f3n. next () Devuelve los siguientes elementos de la lista. nextIndex () devuelve el \u00edndice de los siguientes elementos de la lista. hasPrevious () devuelve true si hay elementos en la direcci\u00f3n inversa en una colecci\u00f3n. previous () Devuelve el elemento anterior en una colecci\u00f3n. previousIndex () devuelve el \u00edndice del elemento anterior en una colecci\u00f3n. remove () elimina el elemento de una colecci\u00f3n. set () modifica el elemento en una colecci\u00f3n. add () agrega el nuevo elemento en una colecci\u00f3n. <p>Diferencias clave entre el iterador y el listador :</p> <ol> <li>La diferencia b\u00e1sica entre Iterator y ListIterator es que, al ser el cursor, Iterator puede atravesar elementos en una colecci\u00f3n solo en direcci\u00f3n hacia adelante. Por otro lado, el ListIterator puede atravesar en ambas direcciones hacia adelante y hacia atr\u00e1s.</li> <li>Usando iterador no puedes agregar ning\u00fan elemento a una colecci\u00f3n. Pero, al usar ListIterator puedes agregar elementos a una colecci\u00f3n.</li> <li>Usando Iterator, no puede eliminar un elemento de una colecci\u00f3n donde, como Puede eliminar un elemento de una colecci\u00f3n usando ListIterator.</li> <li>Usando Iterator puedes recorrer todas las colecciones como Mapa, Lista, Conjunto. Pero, mediante ListIteror, puede atravesar la lista de objetos implementados solamente.</li> <li>Puede recuperar un \u00edndice de un elemento utilizando Iterator. Pero como la Lista es secuencial y est\u00e1 basada en \u00edndices, puede recuperar un \u00edndice de un elemento utilizando ListIterator.</li> </ol> <p>Por lo que podemos concluir que se puede usar ListIterator cuando tiene que atravesar particularmente un objeto List en direcci\u00f3n tanto hacia adelante como hacia atr\u00e1s. De lo contrario, puede utilizar Iterator ya que admite todos los objetos de colecci\u00f3n de tipos.</p>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#anexo-i-introduccion-a-las-excepciones","title":"Anexo I.- Introducci\u00f3n a las excepciones","text":"<p>En Java los errores en tiempo de ejecuci\u00f3n (cuando se esta ejecutando el programa) se denominan excepciones, y esto ocurre cuando se produce un error en alguna de las instrucciones de nuestro programa, como por ejemplo cuando se hace una divisi\u00f3n entre cero, cuando un objeto es 'null' y no puede serlo, cuando no se abre correctamente un fichero, etc. Cuando se produce una excepci\u00f3n se muestra en la pantalla un mensaje de error y finaliza la ejecuci\u00f3n del programa.</p> <p>En Java (al igual que en otros lenguajes de programaci\u00f3n), existen mucho tipos de excepciones y enumerar cada uno de ellos seria casi una labor infinita. En lo referente a las excepciones hay que decir que se aprenden a base experiencia, de encontrarte con ellas y de saber solucionarlas.</p> <p>Cuando en Java se produce una excepci\u00f3n se crear un objeto de una determina clase (dependiendo del tipo de error que se haya producido), que mantendr\u00e1 la informaci\u00f3n sobre el error producido y nos proporcionar\u00e1 los m\u00e9todos necesarios para obtener dicha informaci\u00f3n. Estas clases tienen como clase padre la clase Throwable, por tanto se mantiene una jerarqu\u00eda en las excepciones.</p> <p>A continuaci\u00f3n vamos a mostrar un ejemplo de como al hacer una divisi\u00f3n entre cero, se produce una excepci\u00f3n.</p> KotlinPython <pre><code>fun main() {\n    println(\"ANTES DE HACER LA DIVISI\u00d3N\")\n    val resultado = 10 / 0  // Esto lanzar\u00e1 ArithmeticException\n    println(\"DESPUES DE HACER LA DIVISI\u00d3N\")\n}\n</code></pre> <pre><code>print(\"ANTES DE HACER LA DIVISI\u00d3N\")\nresultado = 10 / 0  # Esto lanzar\u00e1 ZeroDivisionError\nprint(\"DESPUES DE HACER LA DIVISI\u00d3N\")\n</code></pre> <p>Por suerte Java nos permite hacer un control de las excepciones para que nuestro programa no se pare inesperadamente y aunque se produzca una excepci\u00f3n, nuestro programa siga su ejecuci\u00f3n. Para ello tenemos la estructura \"try \u2013 catch \u2013 finally\" que la mostramos a continuaci\u00f3n:</p> JavaKotlinPython <pre><code>try {\n    // Instrucciones cuando no hay una excepci\u00f3n\n} catch (TypeException ex) {\n    // Instrucciones cuando se produce una excepcion\n} finally {\n    // Instruciones que se ejecutan, tanto si hay como sino hay excepciones\n}\n</code></pre> <pre><code>try {\n    // Instrucciones cuando no hay una excepci\u00f3n\n} catch (e: TypeException) {\n    // Instrucciones cuando se produce una excepci\u00f3n\n} finally {\n    // Instrucciones que se ejecutan, tanto si hay como si no hay excepciones\n}\n</code></pre> <pre><code>try:\n    # Instrucciones cuando no hay una excepci\u00f3n\nexcept TypeException as ex:\n    # Instrucciones cuando se produce una excepci\u00f3n\nfinally:\n    # Instrucciones que se ejecutan, tanto si hay como si no hay excepciones\n</code></pre> <p>Respecto a la estructura \"try \u2013 catch \u2013 finally\", se ha de decir que primero se ejecuta el bloque \"try\", si se produce una excepci\u00f3n se ejecuta el bloque \"catch\" y por \u00faltimo el bloque \"finally\". En esta estructura se puede omitir el bloque \"catch\" o el bloque \"finally\", pero no ambos.</p> <p>Sabiendo esta estructura, podemos reescribir nuestro programa para que se ejecuten las tres instrucciones aunque se produzca una excepci\u00f3n. Previamente debemos de saber cual va a ser la clase de la excepci\u00f3n que puede aparecer que seria la \"ArithmeticException\" para definirla en la parte del \"catch\". Nuestro programa quedar\u00eda de la siguiente forma y se ejecutar\u00eda sin problema obteniendo tambi\u00e9n la informaci\u00f3n de la excepci\u00f3n:</p> JavaKotlinPython <pre><code>public class EjemploExcepcion {\n    public static void main(String[] args) {\n        try {\n            System.out.println(\"ANTES DE HACER LA DIVISI\u00d3N\");\n            int resultado = 10 / 0;\n            System.out.println(\"DESPUES DE HACER LA DIVISI\u00d3N\");\n        } catch (ArithmeticException ex) {\n            System.out.println(\"Se ha producido un error aritm\u00e9tico: \" + ex.getMessage());\n        } finally {\n            System.out.println(\"Esto se ejecuta siempre\");\n        }\n    }\n}\n</code></pre> <pre><code>fun main() {\n    try {\n        println(\"ANTES DE HACER LA DIVISI\u00d3N\")\n        val resultado = 10 / 0\n        println(\"DESPUES DE HACER LA DIVISI\u00d3N\")\n    } catch (e: ArithmeticException) {\n        println(\"Se ha producido un error aritm\u00e9tico: ${e.message}\")\n    } finally {\n        println(\"Esto se ejecuta siempre\")\n    }\n}\n</code></pre> <pre><code>try:\n    print(\"ANTES DE HACER LA DIVISI\u00d3N\")\n    resultado = 10 / 0\n    print(\"DESPUES DE HACER LA DIVISI\u00d3N\")\nexcept ZeroDivisionError as ex:\n    print(f\"Se ha producido un error aritm\u00e9tico: {ex}\")\nfinally:\n    print(\"Esto se ejecuta siempre\")\n</code></pre> <p>Como vemos capturamos la excepci\u00f3n en un objeto \"ex\" de la clase \"ArithmeticException\" y podemos obtener el mensaje de error que nos da la excepci\u00f3n. Vemos tambi\u00e9n que el programa termina su ejecuci\u00f3n aunque se haya producido una excepci\u00f3n.</p> <p>Dentro de una misma estructura podemos definir todas las excepciones que queramos. En el caso anterior hemos definido solo la excepci\u00f3n \"ArithmeticException\"; pero por ejemplo, podemos definir tambi\u00e9n la excepci\u00f3n \"NullPointerException\", por si nos viene un valor a 'null' al hacer la divisi\u00f3n:</p> JavaKotlinPythonJava <pre><code>public class EjemploExcepcion {\n    public static void main(String[] args) {\n        try {\n            System.out.println(\"ANTES DE HACER LA DIVISI\u00d3N\");\n            Integer numero = null;\n            int resultado = 10 / numero;\n            System.out.println(\"DESPUES DE HACER LA DIVISI\u00d3N\");\n        } catch (ArithmeticException ex) {\n            System.out.println(\"Se ha producido un error aritm\u00e9tico: \" + ex.getMessage());\n        } catch (NullPointerException ex) {\n            System.out.println(\"Se ha producido un error de null: \" + ex.getMessage());\n        } finally {\n            System.out.println(\"Esto se ejecuta siempre\");\n        }\n    }\n}\n</code></pre> <pre><code>fun main() {\n    try {\n        println(\"ANTES DE HACER LA DIVISI\u00d3N\")\n        val numero: Int? = null\n        val resultado = 10 / (numero ?: 0)\n        println(\"DESPUES DE HACER LA DIVISI\u00d3N\")\n    } catch (e: ArithmeticException) {\n        println(\"Se ha producido un error aritm\u00e9tico: ${e.message}\")\n    } catch (e: NullPointerException) {\n        println(\"Se ha producido un error de null: ${e.message}\")\n    } finally {\n        println(\"Esto se ejecuta siempre\")\n    }\n}\n</code></pre> <pre><code>try:\n    print(\"ANTES DE HACER LA DIVISI\u00d3N\")\n    numero = None\n    resultado = 10 / (numero if numero is not None else 0)\n    print(\"DESPUES DE HACER LA DIVISI\u00d3N\")\nexcept ZeroDivisionError as ex:\n    print(f\"Se ha producido un error aritm\u00e9tico: {ex}\")\nexcept TypeError as ex:\n    print(f\"Se ha producido un error de tipo: {ex}\")\nfinally:\n    print(\"Esto se ejecuta siempre\")\n</code></pre> <pre><code>public class EjemploExcepcion {\n    public static void main(String[] args) {\n        System.out.println(\"ANTES DE HACER LA DIVISI\u00d3N\");\n        int resultado = 10 / 0;  // Esto lanzar\u00e1 ArithmeticException\n        System.out.println(\"DESPUES DE HACER LA DIVISI\u00d3N\");\n    }\n}\n</code></pre>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#jerarquia-de-excepciones-en-java","title":"Jerarqu\u00eda de Excepciones en Java","text":"<pre><code>---\ntitle: Jerarqu\u00eda de Excepciones en Java\n---\nclassDiagram\n    Throwable &lt;|-- Exception\n    Throwable &lt;|-- Error\n    Exception &lt;|-- RuntimeException\n    Exception &lt;|-- IOException\n    Exception &lt;|-- SQLException\n\n    class Throwable {\n        &lt;&lt;class&gt;&gt;\n        +getMessage() String\n        +getCause() Throwable\n        +printStackTrace() void\n        +fillInStackTrace() Throwable\n    }\n\n    class Exception {\n        &lt;&lt;class&gt;&gt;\n        #Exception()\n        #Exception(String message)\n        #Exception(String message, Throwable cause)\n    }\n\n    class Error {\n        &lt;&lt;class&gt;&gt;\n        #Error()\n        #Error(String message)\n        +OutOfMemoryError\n        +StackOverflowError\n        +VirtualMachineError\n    }\n\n    class RuntimeException {\n        &lt;&lt;class&gt;&gt;\n        #RuntimeException()\n        #RuntimeException(String message)\n        +NullPointerException\n        +ArrayIndexOutOfBoundsException\n        +IllegalArgumentException\n        +ArithmeticException\n    }\n\n    class IOException {\n        &lt;&lt;class&gt;&gt;\n        #IOException()\n        #IOException(String message)\n        +FileNotFoundException\n        +EOFException\n    }\n\n    class SQLException {\n        &lt;&lt;class&gt;&gt;\n        #SQLException()\n        #SQLException(String message)\n    }\n\n    note for RuntimeException \"Excepciones NO verificadas\\n(Unchecked)\"\n    note for Exception \"Excepciones verificadas\\n(Checked) - excepto RuntimeException\"\n</code></pre>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#flujo-de-manejo-de-excepciones-con-try-catch-finally","title":"Flujo de Manejo de Excepciones con try-catch-finally","text":"<pre><code>---\ntitle: Flujo de Manejo de Excepciones con try-catch-finally\n---\nflowchart TD\n    A[Inicio del bloque try] --&gt; B[Ejecutar c\u00f3digo]\n    B --&gt; C{\u00bfOcurre excepci\u00f3n?}\n\n    C --&gt;|No| D[Contin\u00faa ejecuci\u00f3n normal]\n    D --&gt; E[Fin bloque try]\n    E --&gt; F[Ejecutar bloque finally]\n    F --&gt; G[Continuar despu\u00e9s de try-catch]\n\n    C --&gt;|S\u00ed| H[Tipo de excepci\u00f3n]\n    H --&gt; I{\u00bfHay catch que coincida?}\n\n    I --&gt;|S\u00ed| J[Ejecutar bloque catch correspondiente]\n    J --&gt; K[\u00bfHay m\u00e1s catches?]\n    K --&gt;|S\u00ed| L{\u00bfCoincide siguiente catch?}\n    L --&gt;|No| K\n    L --&gt;|S\u00ed| J\n\n    K --&gt;|No| F\n\n    I --&gt;|No| M[Propagar excepci\u00f3n al m\u00e9todo llamador]\n    M --&gt; N[\u00bfFinally ejecutado?]\n    N --&gt;|No| F\n    N --&gt;|S\u00ed| O[Excepci\u00f3n no manejada&lt;br&gt;Termina programa o propaga]\n\n    F --&gt; P[\u00bfExcepci\u00f3n en finally?]\n    P --&gt;|S\u00ed| Q[Finally prevalece sobre excepci\u00f3n original]\n    P --&gt;|No| R[Continuar flujo normal]\n</code></pre> <p>En resumen, hemos puesto en esta entrada un ejemplo muy sencillo para controlar un par de excepciones bastante obvias como la divisi\u00f3n entre '0' y un 'null', que perfectamente lo podr\u00edamos haber controlado con una sentencia de control \"if\" mirando el contenido de los atributos, pero la finalidad de esta entrada era ver como controlar las excepciones con la estructura \"try \u2013 catch \u2013 finally\", que si lo sabemos utilizar nuestro programa deber\u00e1 seguir funcionando aunque se produzcan excepciones. Decir tambi\u00e9n que es casi imposible aprenderse todas las excepciones que hay en Java, ya que estas las ir\u00e9is aprendiendo seg\u00fan os las vay\u00e1is encontrando en vuestros desarrollos. Estas que os hemos mostrados son bastante comunes al igual que las que os pod\u00e9is encontrar con el tratamiento de ficheros, de arrays, etc.</p>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#anexo-ii-manejo-de-fechas","title":"Anexo II.- Manejo de fechas","text":"<p>Para trabajar con fechas vamos a utilizar la clase LocalDateTime para lo que necesitamos la librer\u00eda java.time.LocalDateTime.</p> <p>Lo primero que vamos a hacer es crear la fecha y hora actual y mostrarla por consola:</p> JavaKotlinPython <pre><code>import java.time.LocalDateTime;\n\n// Crear una instancia de la clase Date\n// El objeto guardar\u00e1 la fecha y hora actual\nLocalDateTime fechaLocal = LocalDateTime.now();\n\n// Mostrar la fecha con formato predeterminado\nSystem.out.println(fechaLocal);\n</code></pre> <pre><code>import java.time.LocalDateTime\n\n// Crear una instancia de la clase Date\n// El objeto guardar\u00e1 la fecha y hora actual\nval fechaLocal = LocalDateTime.now()\n\n// Mostrar la fecha con formato predeterminado\nprintln(fechaLocal)\n</code></pre> <pre><code>from datetime import datetime\n\n# Crear una instancia de la clase datetime\n# El objeto guardar\u00e1 la fecha y hora actual\nfecha_local = datetime.now()\n\n# Mostrar la fecha con formato predeterminado\nprint(fecha_local)\n</code></pre> <p>Lo que veremos es:</p> <pre><code>2024-12-18T12:36:06.224680500\n</code></pre> <p>C\u00f3mo se puede observar nos va a mostrar a\u00f1o, mes y d\u00eda as\u00ed como las horas, minutos, segundos y milisegundos.</p> <p>En ocasiones no nos va a interesar la hora, s\u00f3lo la fecha. Para ello haremos uso de la clase LocalDate que se encuentra en el paquete java.time.LocalDate.</p> JavaKotlinPython <pre><code>import java.time.LocalDate;\n\nLocalDate fechaLocal;\nfechaLocal = LocalDate.now();\nSystem.out.println(fechaLocal);\n</code></pre> <pre><code>import java.time.LocalDate\n\nval fechaLocal: LocalDate\nfechaLocal = LocalDate.now()\nprintln(fechaLocal)\n</code></pre> <pre><code>from datetime import date\n\nfecha_local = date.today()\nprint(fecha_local)\n</code></pre> <p>y muestra lo siguiente:</p> <pre><code>2024-12-18\n</code></pre> <p>A\u00f1o, mes y d\u00eda.</p> <p>Mostrar la hora actual</p> <p>Para mostrar la hora actual (hora, minuto, segundo y nanosegundos), importe la clase java.time.LocalTime y utilice su m\u00e9todo now():</p> JavaKotlinPython <pre><code>import java.time.LocalTime;\n\nLocalTime miHora = LocalTime.now();\nSystem.out.println(miHora);\n</code></pre> <pre><code>import java.time.LocalTime\n\nval miHora = LocalTime.now()\nprintln(miHora)\n</code></pre> <pre><code>from datetime import datetime\n\nmi_hora = datetime.now().time()\nprint(mi_hora)\n</code></pre> <pre><code>13:37:15.349263300\n</code></pre> <p>Crear un tipo de datos de tipo Fecha</p> JavaKotlinPython <pre><code>import java.time.LocalDate;\n\nLocalDate fecha = LocalDate.of(2020,1,1);\n</code></pre> <pre><code>import java.time.LocalDate\n\nval fecha = LocalDate.of(2020, 1, 1)\n</code></pre> <pre><code>from datetime import date\n\nfecha = date(2020, 1, 1)\n</code></pre> <p>Formato de fecha y hora</p> <p>La \"T\" en el ejemplo anterior se utiliza para separar la fecha de la hora. Puede utilizar la clase DateTimeFormatter con el m\u00e9todo ofPattern() en el mismo paquete para formatear o analizar objetos de fecha y hora. El siguiente ejemplo eliminar\u00e1 tanto la \"T\" como los nanosegundos de la fecha y hora:</p> JavaKotlinPython <pre><code>import java.time.LocalDateTime;\nimport java.time.format.DateTimeFormatter;\n\nLocalDateTime myFechaObjeto = LocalDateTime.now();\nSystem.out.println(\"Antes de formatear: \" + myFechaObjeto);\nDateTimeFormatter myFormatFecha = DateTimeFormatter.ofPattern(\"dd-MM-yyyy HH:mm:ss\");\n\nString formattedDate = myFechaObjeto.format(myFormatFecha);\nSystem.out.println(\"Despu\u00e9s de formatear: \" + formattedDate);\n</code></pre> <pre><code>import java.time.LocalDateTime\nimport java.time.format.DateTimeFormatter\n\nval myFechaObjeto = LocalDateTime.now()\nprintln(\"Antes de formatear: $myFechaObjeto\")\nval myFormatFecha = DateTimeFormatter.ofPattern(\"dd-MM-yyyy HH:mm:ss\")\n\nval formattedDate = myFechaObjeto.format(myFormatFecha)\nprintln(\"Despu\u00e9s de formatear: $formattedDate\")\n</code></pre> <pre><code>from datetime import datetime\n\nmy_fecha_objeto = datetime.now()\nprint(f\"Antes de formatear: {my_fecha_objeto}\")\nformatted_date = my_fecha_objeto.strftime(\"%d-%m-%Y %H:%M:%S\")\nprint(f\"Despu\u00e9s de formatear: {formatted_date}\")\n</code></pre> <pre><code>Antes de formatear: 2024-12-18T13:45:52.642614100\nDespu\u00e9s de formatear: 18-12-2024 13:45:52\n</code></pre> <p>El m\u00e9todo ofPattern() acepta todo tipo de valores, si desea mostrar la fecha y la hora en un formato diferente. Por ejemplo:</p> Valor Resultado yyyy-MM-dd 1988-09-29 dd/MM/yyyy 29/09/1988 dd-MMM-yyyy 29-Sep-1988 E, MMM dd yyyy Thu, Sep 29 1988 <p>Como se observa, para incluir texto dentro del formato hay que usar las comillas simples.</p> <p>Las letras principales para definir el formato se muestran a continuaci\u00f3n y dependiendo del n\u00famero de veces que aparezca cambiar\u00e1 el valor que se muestre:</p> Formato Descripci\u00f3n y A\u00f1o. Por ejemplo: yyyy --&gt; 2018 M Mes. Por ejemplo: MM --&gt; 01 o MMMM --&gt; enero d D\u00eda. Por ejemplo: dd --&gt; 24 E D\u00eda de la semana. Por ejemplo: EEEE --&gt; jueves h Hora AM/PM (1-12). Por ejemplo: hh --&gt; 04 m Minutos. Por ejemplo: mm --&gt; 34 s Segundos. Por ejemplo: ss --&gt; 25 H Hora 0-23. Por ejemplo: hh --&gt; 16 a AM/PM z Zona horaria. Por ejemplo: zzz --&gt; CET (Central European Time) <p>Prestad especial atenci\u00f3n a c\u00f3mo queremos formatear las horas. No es lo mismo hh:mm:ss que HH:mm:ss.</p> <p>Si usamos la \"h\" m\u00ednuscula, las horas se mostrar\u00e1n de la 1 a la 12 mientras que si usamos la \"H\" may\u00fascula, las horas se mostrar\u00e1n de la 0 a la 23.</p>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#comparar-objetos-date-compareto","title":"Comparar objetos Date: compareTo.","text":"<p>Uno de los m\u00e9todos m\u00e1s \u00fatiles para comparar fechas es el m\u00e9todo compareTo.</p> <p>Es un m\u00e9todo de la clase Date que devuelve un entero.</p> <ul> <li>Si la fecha es anterior (m\u00e1s antigua) a la fecha que se pasa como par\u00e1metro el resultado ser\u00e1 negativo.</li> <li>Si es posterior (m\u00e1s reciente) devolver\u00e1 un n\u00famero positivo.</li> <li>Si son iguales devolver\u00e1 0.</li> </ul> <p>Por ejemplo:</p> JavaKotlinPython <pre><code>import java.time.LocalDate;\n\nLocalDate fecha = LocalDate.of(2020,1,1);\nLocalDate fecha2 = LocalDate.of(2024,3,20);\n\nint comparacion = fecha.compareTo(fecha2);\nif (comparacion &gt; 0) {\n    System.out.println(\"La fecha introducida ocurre despues de 20_03_2024\");\n} else if (comparacion &lt; 0) {\n    System.out.println(\"La fecha introducida ocurre antes del 20_03_2024\");\n} else {\n    System.out.println(\"Ambas fechas son iguales\");\n}\n</code></pre> <pre><code>import java.time.LocalDate\n\nval fecha = LocalDate.of(2020, 1, 1)\nval fecha2 = LocalDate.of(2024, 3, 20)\n\nval comparacion = fecha.compareTo(fecha2)\nwhen {\n    comparacion &gt; 0 -&gt; println(\"La fecha introducida ocurre despu\u00e9s de 20_03_2024\")\n    comparacion &lt; 0 -&gt; println(\"La fecha introducida ocurre antes del 20_03_2024\")\n    else -&gt; println(\"Ambas fechas son iguales\")\n}\n</code></pre> <pre><code>from datetime import date\n\nfecha = date(2020, 1, 1)\nfecha2 = date(2024, 3, 20)\n\nif fecha &gt; fecha2:\n    print(\"La fecha introducida ocurre despu\u00e9s de 20_03_2024\")\nelif fecha &lt; fecha2:\n    print(\"La fecha introducida ocurre antes del 20_03_2024\")\nelse:\n    print(\"Ambas fechas son iguales\")\n</code></pre> <p>En este caso fecha, 01-01-2020, es m\u00e1s antigua que fecha, 20-03-2024, y el resultado ser\u00e1 negativo.</p> <p>Lo que veremos es:</p> <pre><code>La fecha introducida ocurre antes del 20_03_2024\n</code></pre>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#anexo-iii-formato-decimal-en-java","title":"Anexo III: Formato decimal en Java","text":"<p>La clase DecimalFormat de java nos permite mostrar los n\u00fameros en pantalla con el formato que queramos, por ejemplo, con dos decimales, con una coma para separar los decimales, etc. DecimalFormat tambi\u00e9n es \u00fatil para presentar un n\u00famero o recoger y reconstruir el n\u00famero. Veamos unos ejemplos.</p>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#redondear-decimales-por-ejemplo-dos-decimales","title":"Redondear decimales, por ejemplo, dos decimales","text":"<p>Antes de nada, dejar claro que por ejemplo, usar dos decimales en java, no es algo que se haga con las variables o el c\u00f3digo. En c\u00f3digo se usa <code>double</code> o <code>float</code> con todos sus decimales y lo \u00fanico que se hace es, a la hora de presentarlo en pantalla, imprimirlo o mostrarlo en alguna ventana de nuestra aplicaci\u00f3n, darle el formato que queramos, el formato de dos decimales, con separador de miles y coma decimal, o el que queramos. Para ello, la clase <code>DecimalFormat</code> de java es la clase que debemos usar.</p> <p>Java: Un uso simple de <code>DecimalFormat</code> puede ser este:</p> <pre><code>import java.text.DecimalFormat;\n\nDecimalFormat formateador = new DecimalFormat(\"####.##\");\n\n// Esto sale en pantalla con dos decimales, es decir, 3,43\nSystem.out.println(formateador.format(3.43242383));\n</code></pre> <p>Hemos cogido un n\u00famero con muchos decimales y lo hemos redondeado a dos decimales para sacarlo por pantalla. Para ello, s\u00f3lo hemos tenido que indicar la m\u00e1scara <code>####.##</code> en el constructor de la clase <code>DecimalFormat</code>. Las <code>#</code> representan una cifra, as\u00ed que hemos puesto que el n\u00famero se ponga en pantalla con cuatro cifras, un punto decimal y dos decimales.</p> <p>En la API de DecimalFormat podemos ver todos los posibles caracteres que admite la m\u00e1scara.</p> <p>Si usamos ceros en vez de #, los huecos se rellenar\u00e1n con ceros por delante.</p> JavaKotlinPython <pre><code>import java.text.DecimalFormat;\n\nDecimalFormat formateador = new DecimalFormat(\"0000.00\");\n\n// Esto sale en pantalla con cuatro cifras enteras\n// y cuatro decimales, es decir, 0003,40\nSystem.out.println(formateador.format(3.4));\n</code></pre> <pre><code>import java.text.DecimalFormat\n\nval formateador = DecimalFormat(\"####.##\")\nprintln(formateador.format(3.43242383))  // 3,43\n\nval formateador2 = DecimalFormat(\"0000.00\")\nprintln(formateador2.format(3.4))  // 0003,40\n</code></pre> <pre><code># Formateo b\u00e1sico\nnumero = 3.43242383\nprint(f\"{numero:.2f}\")  # 3.43\nprint(\"{:.2f}\".format(numero))  # 3.43\n\n# Con ceros a la izquierda\nprint(f\"{3.4:07.2f}\")  # 0003.40\nprint(\"{:07.2f}\".format(3.4))  # 0003.40\n</code></pre> <p>Al poner <code>0</code> en vez de <code>#</code>, las cifras que falten por delante o por detr\u00e1s, se pondr\u00e1n con ceros. Es una forma, por ejemplo, de obligar a presentar con dos decimales aunque el n\u00famero s\u00f3lo tenga uno o ninguno.</p> <p>Por supuesto, podemos poner <code>#</code> en la parte entera y <code>0</code> en la parte decimal, para que salgan dos decimales aunque sean ceros, pero no se rellenen por delante los ceros de la parte entera.</p>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#mostrar-porcentajes","title":"Mostrar porcentajes","text":"<p>Una caracter\u00edstica curiosa, es que si usamos en la m\u00e1scara el signo de porcentaje <code>%</code>, el n\u00famero se multiplicar\u00e1 autom\u00e1ticamente por 100 al presentarlo en pantalla.</p> JavaKotlinPython <pre><code>import java.text.DecimalFormat;\n\nDecimalFormat formateador = new DecimalFormat(\"###.##%\");\n\n// Esto saca en pantalla 34,44%\nSystem.out.println(formateador.format(0.3444));\n</code></pre> <pre><code>import java.text.DecimalFormat\n\nval formateador = DecimalFormat(\"###.##%\")\nprintln(formateador.format(0.3444))  // 34,44%\n</code></pre> <pre><code>porcentaje = 0.3444\nprint(f\"{porcentaje:.2%}\")  # 34.44%\nprint(\"{:.2%}\".format(porcentaje))  # 34.44%\n</code></pre>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#redondeo-al-fijar-el-numero-de-decimales","title":"Redondeo al fijar el n\u00famero de decimales","text":"<p>Como hemos visto al principio, con <code>DecimalFormat</code> podemos indicar cu\u00e1ntos decimales queremos mostrar en la salida. Un detalle a tener en cuenta es que la clase <code>DecimalFormat</code> es lo suficientemente lista como para redondear, es decir, incrementar en uno el \u00faltimo decimal visible si es necesario. Por ejemplo, si queremos dos decimales, el n\u00famero 1.2345 se ver\u00e1 como 1.23, pero si la cifra del tercer decimal es 5 o m\u00e1s, como por ejemplo en 1.2356, entonces el resultado ser\u00e1 1.24. El siguiente c\u00f3digo nos lo muestra:</p> JavaKotlinPython <pre><code>double a = 1.2345;\ndouble b = 1.2356;\n\nDecimalFormat formatter = new DecimalFormat(\"#.##\");\n\nSystem.out.println(formatter.format(a));   // La salida es 1,23\nSystem.out.println(formatter.format(b));   // La salida es 1,24\n</code></pre> <pre><code>val a = 1.2345\nval b = 1.2356\n\nval formatter = DecimalFormat(\"#.##\")\n\nprintln(formatter.format(a))  // La salida es 1,23\nprintln(formatter.format(b))  // La salida es 1,24\n</code></pre> <pre><code>a = 1.2345\nb = 1.2356\n\nprint(f\"{a:.2f}\")  # La salida es 1.23\nprint(f\"{b:.2f}\")  # La salida es 1.24\n</code></pre>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#puntos-decimales-y-separador-de-miles-decimalformatsymbols","title":"Puntos decimales y separador de miles : DecimalFormatSymbols","text":"<p>La clase <code>DecimalFormat</code> usa por defecto el formato para el lenguaje que tengamos instalado en el ordenador. Es decir, si nuestro sistema operativo est\u00e1 en espa\u00f1ol, se usar\u00e1 la coma para los decimales y el punto para los separadores de miles. Si estamos en ingl\u00e9s, se usar\u00e1 el punto decimal.</p> <p>Una opci\u00f3n para cambiar esto, es crear una clase <code>DecimalFormatSymbols</code> que vendr\u00e1 rellena con lo del idioma por defecto, y cambiar en ella el s\u00edmbolo que nos interese. Por ejemplo, si estamos en espa\u00f1ol y queremos usar el punto decimal en vez de la coma, podemos hacer esto:</p> JavaKotlinPython <pre><code>import java.text.DecimalFormat;\nimport java.text.DecimalFormatSymbols;\n\nDecimalFormatSymbols simbolos = new DecimalFormatSymbols();\nsimbolos.setDecimalSeparator('.');\nDecimalFormat formateador = new DecimalFormat(\"####.####\",simbolos);\n\n// Esto sale en pantalla con punto decimal, es decir, 3.4324,\nSystem.out.println(formateador.format(3.43242383));\n</code></pre> <pre><code>import java.text.DecimalFormat\nimport java.text.DecimalFormatSymbols\n\nval simbolos = DecimalFormatSymbols()\nsimbolos.decimalSeparator = '.'\nval formateador = DecimalFormat(\"####.####\", simbolos)\n\nprintln(formateador.format(3.43242383))  // 3.4324\n</code></pre> <pre><code>import locale\n\n# Configurar locale para usar punto decimal\nlocale.setlocale(locale.LC_NUMERIC, 'en_US.UTF-8')\nnumero = 3.43242383\nprint(locale.format_string(\"%.4f\", numero))  # 3.4324\n\n# O usando format directamente\nprint(f\"{numero:.4f}\".replace(',', '.'))  # 3.4324\n</code></pre> <p>En la API de DecimalFormatSymbols puedes ver qu\u00e9 m\u00e1s s\u00edmbolos se pueden cambiar.</p> <p>Tambi\u00e9n es posible coger el <code>DecimalFormaSymbols</code> de alguna localizaci\u00f3n concreta que nos interese y modificar o no lo que haga falta. Por ejemplo, si nos interesa que la coma decimal sea un punto en vez de una coma, podr\u00edamos coger el <code>DecimalFormatSymbols</code> de Inglaterra:</p> <p>Java:</p> <pre><code>import java.text.DecimalFormat;\nimport java.text.DecimalFormatSymbols;\nimport java.util.Locale;\n\nDecimalFormatSymbols simbolos = DecimalFormatSymbols.getInstance(Locale.ENGLISH);\nDecimalFormat formateador = new DecimalFormat(\"####.####\",simbolos);\n</code></pre>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#reconstruir-el-numero","title":"Reconstruir el n\u00famero","text":"<p>Si suponemos que un usuario escribe un n\u00famero, podemos leerlo y reconstruirlo con DecimalFormat:</p> JavaKotlinPython <pre><code>import java.text.DecimalFormat;\nimport java.text.ParseException;\nimport java.util.Scanner;\n\nScanner teclado = new Scanner(System.in);\nDecimalFormat formateador = new DecimalFormat(\"####.####\");\nString texto = teclado.nextLine();\ntry {\n    // parse() lanza una ParseException en caso de fallo que hay\n    // que capturar.\n    Number numero = formateador.parse(texto);\n    double valor = numero.doubleValue();\n    // Estas dos l\u00edneas se puede abreviar con\n    // double valor = formateador.parse(texto).doubleValue();\n} catch (ParseException e) {\n    // Error. El usuario ha escrito algo que no se puede convertir\n    // a n\u00famero.\n}\n</code></pre> <pre><code>import java.text.DecimalFormat\nimport java.text.ParseException\nimport java.util.Scanner\n\nval teclado = Scanner(System.`in`)\nval formateador = DecimalFormat(\"####.####\")\nval texto = teclado.nextLine()\ntry {\n    val numero = formateador.parse(texto)\n    val valor = numero.toDouble()\n} catch (e: ParseException) {\n    // Error. El usuario ha escrito algo que no se puede convertir\n    // a n\u00famero.\n}\n</code></pre> <pre><code>texto = input(\"Introduce un n\u00famero: \")\ntry:\n    # Intentamos convertir a float\n    valor = float(texto)\n    # Si queremos formatearlo despu\u00e9s\n    print(f\"N\u00famero introducido: {valor}\")\nexcept ValueError:\n    print(\"Error. El usuario ha escrito algo que no se puede convertir a n\u00famero.\")\n</code></pre>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#anexo-iv-expresiones-regulares","title":"Anexo IV.- Expresiones regulares","text":"<p>\u00bfQu\u00e9 es una expresi\u00f3n regular?</p> <p>Una expresi\u00f3n regular es una secuencia de caracteres que forma un patr\u00f3n de b\u00fasqueda. Cuando busca datos en un texto, puede utilizar este patr\u00f3n de b\u00fasqueda para describir lo que est\u00e1 buscando.</p> <p>Una expresi\u00f3n regular puede ser un solo car\u00e1cter o un patr\u00f3n m\u00e1s complicado.</p> <p>Las expresiones regulares se pueden utilizar para realizar todo tipo de operaciones de b\u00fasqueda y reemplazo de texto.</p> <p>Java no tiene una clase de expresi\u00f3n regular incorporada, pero podemos importar el paquete java.util.regex para trabajar con expresiones regulares. El paquete incluye las siguientes clases:</p> <ul> <li>Clase Pattern: define un patr\u00f3n (que se utilizar\u00e1 en una b\u00fasqueda)</li> <li>Clase Matcher: se utiliza para buscar el patr\u00f3n</li> <li>Clase PatternSyntaxException: indica un error de sintaxis en un patr\u00f3n de expresi\u00f3n regular.</li> </ul> <p>\u00bfTienen algo en com\u00fan todos los n\u00fameros de DNI y de NIE? \u00bfPodr\u00edas hacer un programa que verificara si un DNI o un NIE es correcto? Seguro que s\u00ed. Si te fijas, los n\u00fameros de DNI y los de NIE tienen una estructura fija: X1234567Z (en el caso del NIE) y 1234567Z (en el caso del DNI). Ambos siguen un patr\u00f3n que podr\u00eda describirse como: una letra inicial opcional (solo presente en los NIE), seguida de una secuencia num\u00e9rica y finalizando con otra letra. \u00bfF\u00e1cil no?</p> <p>Pues esta es la funci\u00f3n de las expresiones regulares: permitir comprobar si una cadena sigue o no un patr\u00f3n preestablecido. Las expresiones regulares son un mecanismo para describir esos patrones, y se construyen de una forma relativamente sencilla. Existen muchas librer\u00edas diferentes para trabajar con expresiones regulares, y casi todas siguen, m\u00e1s o menos, una sintaxis similar, con ligeras variaciones. Dicha sintaxis nos permite indicar el patr\u00f3n de forma c\u00f3moda, como si de una cadena de texto se tratase, en la que determinados s\u00edmbolos tienen un significado especial. Por ejemplo \"<code>[01]+</code>\" es una expresi\u00f3n regular que permite comprobar si una cadena conforma un n\u00famero binario.</p> <p>Veamos cu\u00e1les son las reglas generales para construir una expresi\u00f3n regular:</p> <ul> <li>Podemos indicar que una cadena contiene un conjunto de s\u00edmbolos fijo, simplemente poniendo dichos s\u00edmbolos en el patr\u00f3n, excepto para algunos s\u00edmbolos especiales que necesitar\u00e1n un car\u00e1cter de escape como veremos m\u00e1s adelante. Por ejemplo, el patr\u00f3n \"<code>aaa</code>\" admitir\u00e1 cadenas que contengan tres aes.</li> <li>\"<code>[xyz]</code>\". Entre corchetes podemos indicar opcionalidad. Solo uno de los s\u00edmbolos que hay entre los corchetes podr\u00e1 aparecer en el lugar donde est\u00e1n los corchetes. Por ejemplo, la expresi\u00f3n regular \"<code>aaa[xy]</code>\" admitir\u00e1 como v\u00e1lidas las cadenas \"<code>aaax</code>\" y la cadena \"<code>aaay</code>\". Los corchetes representan una posici\u00f3n de la cadena que puede tomar uno de varios valores posibles.</li> <li>\"<code>[a-z]</code>\" \"<code>[A-Z]</code>\" \"<code>[a-zA-Z]</code>\". Usando el gui\u00f3n y los corchetes podemos indicar que el patr\u00f3n admite cualquier car\u00e1cter entre la letra inicial y la final. Es importante que sepas que se diferencia entre letras may\u00fasculas y min\u00fasculas, no son iguales de cara a las expresiones regulares.</li> <li>\"<code>[0-9]</code>\". Y nuevamente, usando un gui\u00f3n, podemos indicar que se permite la presencia de un d\u00edgito num\u00e9rico entre 0 y 9, cualquiera de ellos, pero solo uno.</li> </ul> <p>Con las reglas anteriores podemos indicar el conjunto de s\u00edmbolos que admite el patr\u00f3n y el orden que deben tener. Si una cadena no contiene los s\u00edmbolos especificados en el patr\u00f3n, en el mismo orden, entonces la cadena no encajar\u00e1 con el patr\u00f3n. Veamos ahora como indicar repeticiones:</p> <ul> <li>\"<code>a?</code>\". Usaremos el interrogante para indicar que un s\u00edmbolo puede aparecer una vez o ninguna. De esta forma la letra \"<code>a</code>\" podr\u00e1 aparecer una vez o simplemente no aparecer.</li> <li>\"<code>a*</code>\". Usaremos el asterisco para indicar que un s\u00edmbolo puede aparecer una vez o muchas veces, pero tambi\u00e9n ninguna. Cadenas v\u00e1lidas para esta expresi\u00f3n regular ser\u00edan \"<code>aa</code>\", \"<code>aaa</code>\" o \"<code>aaaaaaaa</code>\".</li> <li>\"<code>a+</code>\". Usaremos el s\u00edmbolo de suma para indicar que otro s\u00edmbolo debe aparecer al menos una vez, pudiendo repetirse cuantas veces quiera.</li> <li>\"<code>a{1,4}</code>\" . Usando las llaves, podemos indicar el n\u00famero m\u00ednimo y m\u00e1ximo de veces que un s\u00edmbolo podr\u00e1 repetirse. El primer n\u00famero del ejemplo es el n\u00famero 1, y quiere decir que la letra \"<code>a</code>\" debe aparecer al menos una vez. El segundo n\u00famero, 4, indica que como m\u00e1ximo puede repetirse cuatro veces.</li> <li>\"<code>a{2,}</code>\". Tambi\u00e9n es posible indicar solo el n\u00famero m\u00ednimo de veces que un car\u00e1cter debe aparecer (sin determinar el m\u00e1ximo), haciendo uso de las llaves, indicando el primer n\u00famero y poniendo la coma (no la olvides).</li> <li>\"<code>a{5}</code>\". A diferencia de la forma anterior, si solo escribimos un n\u00famero entre llaves, sin poner la coma detr\u00e1s, significar\u00e1 que el s\u00edmbolo debe aparecer un n\u00famero exacto de veces. En este caso, la \"<code>a</code>\" debe aparecer exactamente 5 veces.</li> <li>\"<code>[a-z]{1,4}[0-9]+</code>\". Los indicadores de repetici\u00f3n se pueden usar tambi\u00e9n con corchetes, dado que los corchetes representan, b\u00e1sicamente, un s\u00edmbolo. En el ejemplo anterior se permitir\u00eda de una a cuatro letras min\u00fasculas, seguidas de al menos un d\u00edgito num\u00e9rico.</li> </ul> JavaKotlinPython <pre><code>import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Main {\n    public static void main(String[] args) {\n        Pattern pattern = Pattern.compile(\"tres tristes tigres\", Pattern.CASE_INSENSITIVE);\n        Matcher matcher = pattern.matcher(\"Tres tristes tigres comian trigo en un trigal\");\n        boolean matchFound = matcher.find();\n        if(matchFound) {\n            System.out.println(\"Coincidencia encontrada\");\n        } else {\n            System.out.println(\"Coincidencia no encontrada\");\n        }\n    }\n}\n</code></pre> <pre><code>import java.util.regex.Pattern\n\nfun main() {\n    val pattern = Pattern.compile(\"tres tristes tigres\", Pattern.CASE_INSENSITIVE)\n    val matcher = pattern.matcher(\"Tres tristes tigres comian trigo en un trigal\")\n    val matchFound = matcher.find()\n    if (matchFound) {\n        println(\"Coincidencia encontrada\")\n    } else {\n        println(\"Coincidencia no encontrada\")\n    }\n}\n</code></pre> <pre><code>import re\n\npattern = re.compile(r\"tres tristes tigres\", re.IGNORECASE)\nmatcher = pattern.search(\"Tres tristes tigres comian trigo en un trigal\")\nif matcher:\n    print(\"Coincidencia encontrada\")\nelse:\n    print(\"Coincidencia no encontrada\")\n</code></pre> <p>Ejemplo explicado En este ejemplo, se busca la secuencia de palabras \"tres tristes tigres\" en una texto.</p> <p>Primero, se crea el patr\u00f3n utilizando el m\u00e9todo Pattern.compile(). El primer par\u00e1metro indica qu\u00e9 patr\u00f3n se est\u00e1 buscando y el segundo par\u00e1metro tiene un indicador que indica que la b\u00fasqueda no debe distinguir entre may\u00fasculas y min\u00fasculas. El segundo par\u00e1metro es opcional.</p> <p>El m\u00e9todo matcher() se utiliza para buscar el patr\u00f3n en una cadena. Devuelve un objeto Matcher que contiene informaci\u00f3n sobre la b\u00fasqueda realizada.</p> <p>El m\u00e9todo find() devuelve verdadero si se encontr\u00f3 el patr\u00f3n en la cadena y falso si no se encontr\u00f3.</p> <p>Flags Los flags del m\u00e9todo compile() cambian la forma en que se realiza la b\u00fasqueda. A continuaci\u00f3n, se muestran algunas de ellas:</p> <ul> <li>Pattern.CASE_INSENSITIVE: se ignorar\u00e1 el uso de may\u00fasculas y min\u00fasculas en las letras al realizar una b\u00fasqueda.</li> <li>Pattern.LITERAL: los caracteres especiales del patr\u00f3n no tendr\u00e1n ning\u00fan significado especial y se tratar\u00e1n como caracteres comunes al realizar una b\u00fasqueda.</li> <li>Pattern.UNICODE_CASE: se usa junto con la bandera CASE_INSENSITIVE para ignorar tambi\u00e9n el uso de may\u00fasculas y min\u00fasculas en las letras que no pertenecen al alfabeto ingl\u00e9s.</li> </ul> <p>Patrones de expresiones regulares</p> <p>El primer par\u00e1metro del m\u00e9todo Pattern.compile() es el patr\u00f3n. Describe lo que se busca.</p> <p>Los corchetes se utilizan para buscar un rango de caracteres:</p> Expresi\u00f3n Descripci\u00f3n [abc] Encuentra un car\u00e1cter de las opciones entre corchetes. [^abc] Encuentra un caracter que NO est\u00e9 entre corchetes [0-9] Encuentra un car\u00e1cter del rango 0 a 9 <p>Metacaracteres</p> <p>Los metacaracteres son caracteres con un significado especial:</p> Metacar\u00e1cter Descripci\u00f3n | Encuentra una coincidencia para cualquiera de los patrones separados por . Encuentra solo una instancia de cualquier car\u00e1cter ^ Encuentra una coincidencia como el comienzo de una cadena como en: ^Hola $ Encuentra una coincidencia al final de la cadena como en: World$ \\d Encuentra un d\u00edgito \\s Encontrar un car\u00e1cter de espacio en blanco \\b Busque una coincidencia al principio de una palabra como esta: \\bPALABRA, o al final de una palabra como esta: PALABRA\\b \\uxxxx Busque el car\u00e1cter Unicode especificado por el n\u00famero hexadecimal xxxx <p>Cuantificadores</p> <p>Los cuantificadores definen cantidades:</p> Cuantificador Descripci\u00f3n n+ Coincide con cualquier cadena que contenga al menos un n n* Coincide con cualquier cadena que contenga cero o m\u00e1s ocurrencias de n n? Coincide con cualquier cadena que contenga cero o una ocurrencia de n n{x} Coincide con cualquier cadena que contenga una secuencia de X n's n{x,y} Coincide con cualquier cadena que contenga una secuencia de X a Y n's n{x,} Coincide con cualquier cadena que contenga una secuencia de al menos X n's"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#uso-de-expresiones-regulares-i","title":"Uso de expresiones regulares I","text":"<p>\u00bfY c\u00f3mo uso las expresiones regulares en un programa? Pues de una forma sencilla. Para su uso, Java ofrece las clases <code>Pattern</code> y <code>Matcher</code> contenidas en el paquete <code>java.util.regex.*</code>. La clase <code>Pattern</code> se utiliza para procesar la expresi\u00f3n regular y \"compilarla\", lo cual significa verificar que es correcta y dejarla lista para su utilizaci\u00f3n. La clase <code>Matcher</code> sirve para comprobar si una cadena cualquiera sigue o no un patr\u00f3n. Veamoslo con un ejemplo:</p> JavaKotlinPython <pre><code>import java.util.regex.Pattern;\nimport java.util.regex.Matcher;\n\nPattern p = Pattern.compile(\"[01]+\");\nMatcher m = p.matcher(\"00001010\");\nif (m.matches()) {\n    System.out.println(\"Si, contiene el patr\u00f3n\");\n} else {\n    System.out.println(\"No, no contiene el patr\u00f3n\");\n}\n</code></pre> <pre><code>import java.util.regex.Pattern\n\nval p = Pattern.compile(\"[01]+\")\nval m = p.matcher(\"00001010\")\nif (m.matches()) {\n    println(\"Si, contiene el patr\u00f3n\")\n} else {\n    println(\"No, no contiene el patr\u00f3n\")\n}\n</code></pre> <pre><code>import re\n\np = re.compile(r\"[01]+\")\nm = p.fullmatch(\"00001010\")\nif m:\n    print(\"Si, contiene el patr\u00f3n\")\nelse:\n    print(\"No, no contiene el patr\u00f3n\")\n</code></pre> <p>En el ejemplo, el m\u00e9todo est\u00e1tico <code>compile</code> de la clase <code>Pattern</code> permite crear un patr\u00f3n, dicho m\u00e9todo compila la expresi\u00f3n regular pasada por par\u00e1metro y genera una instancia de <code>Pattern</code> (<code>p</code> en el ejemplo). El patr\u00f3n <code>p</code> podr\u00e1 ser usado m\u00faltiples veces para verificar si una cadena coincide o no con el patr\u00f3n, dicha comprobaci\u00f3n se hace invocando el m\u00e9todo <code>matcher</code>, el cual combina el patr\u00f3n con la cadena de entrada y genera una instancia de la clase <code>Matcher</code> (<code>m</code> en el ejemplo). La clase <code>Matcher</code> contiene el resultado de la comprobaci\u00f3n y ofrece varios m\u00e9todos para analizar la forma en la que la cadena ha encajado con un patr\u00f3n:</p> <ul> <li><code>m.matches()</code>. Devolver\u00e1 <code>true</code> si toda la cadena (de principio a fin) encaja con el patr\u00f3n o <code>false</code> en caso contrario.</li> <li><code>m.lookingAt()</code>. Devolver\u00e1 <code>true</code> si el patr\u00f3n se ha encontrado al principio de la cadena. A diferencia del m\u00e9todo <code>matches()</code>, la cadena podr\u00e1 contener al final caracteres adicionales a los indicados por el patr\u00f3n, sin que ello suponga un problema.</li> <li><code>m.find()</code>. Devolver\u00e1 <code>true</code> si el patr\u00f3n existe en alg\u00fan lugar la cadena (no necesariamente toda la cadena debe coincidir con el patr\u00f3n) y <code>false</code> en caso contrario, pudiendo tener m\u00e1s de una coincidencia. Para obtener la posici\u00f3n exacta donde se ha producido la coincidencia con el patr\u00f3n podemos usar los m\u00e9todos <code>m.start()</code> y <code>m.end()</code>, para saber la posici\u00f3n inicial y final donde se ha encontrado. Una segunda invocaci\u00f3n del m\u00e9todo <code>find()</code> ir\u00e1 a la segunda coincidencia (si existe), y as\u00ed sucesivamente. Podemos reiniciar el m\u00e9todo <code>find()</code>, para que vuelva a comenzar por la primera coincidencia, invocando el m\u00e9todo <code>m.reset()</code>.</li> </ul> <p>Veamos algunas construcciones adicionales que pueden ayudarnos a especificar expresiones regulares m\u00e1s complejas:</p> <ul> <li>\"<code>[^abc]</code>\". El s\u00edmbolo <code>\"^\"</code>, cuando se pone justo detr\u00e1s del corchete de apertura, significa \"negaci\u00f3n\". La expresi\u00f3n regular admitir\u00e1 cualquier s\u00edmbolo diferente a los puestos entre corchetes. En este caso, cualquier s\u00edmbolo diferente de \"a\", \"b\" o \"c\".</li> <li>\"<code>^[01]+$</code>\". Cuando el s\u00edmbolo <code>\"^\"</code> aparece al comienzo de la expresi\u00f3n regular, permite indicar comienzo de l\u00ednea o de entrada. El s\u00edmbolo \"<code>$</code>\" permite indicar fin de l\u00ednea o fin de entrada. Us\u00e1ndolos podemos verificar que una l\u00ednea completa (de principio a fin) encaje con la expresi\u00f3n regular, es muy \u00fatil cuando se trabaja en modo multil\u00ednea y con el m\u00e9todo <code>find()</code>.</li> <li>\"<code>.</code>\". El punto simboliza cualquier car\u00e1cter.</li> <li>\"<code>\\\\d</code>\". Un d\u00edgito num\u00e9rico. Equivale a \"<code>[0-9]</code>\".</li> <li>\"<code>\\\\D</code>\". Cualquier cosa excepto un d\u00edgito num\u00e9rico. Equivale a \"<code>[^0-9]</code>\".</li> <li>\"<code>\\\\s</code>\". Un espacio en blanco (incluye tabulaciones, saltos de l\u00ednea y otras formas de espacio).</li> <li>\"<code>\\\\S</code>\". Cualquier cosa excepto un espacio en blanco.</li> <li>\"<code>\\\\w</code>\". Cualquier car\u00e1cter que podr\u00edas encontrar en una palabra. Equivale a \"<code>[a-zA-Z_0-9]</code>\".</li> </ul>"},{"location":"Unidad%205%20Estructuras%20de%20datos%20din%C3%A1micas/Unidad%205%20-%20Estructuras%20de%20datos%20din%C3%A1micas_New/#uso-de-expresiones-regulares-ii","title":"Uso de expresiones regulares II","text":"<p>\u00bfTe resultan dif\u00edciles las expresiones regulares? Al principio siempre lo son, pero no te preocupes. Hasta ahora has visto como las expresiones regulares permiten verificar datos de entrada, permitiendo comprobar si un dato indicado sigue el formato esperado: que un DNI tenga el formato esperado, que un email sea un email y no otra cosa, etc. Pero ahora vamos a dar una vuelta de tuerca adicional.</p> <p>Los par\u00e9ntesis, de los cuales no hemos hablado hasta ahora, tienen un significado especial, permiten indicar repeticiones para un conjunto de s\u00edmbolos, por ejemplo: \"<code>(#[01]){2,3}</code>\". En el ejemplo anterior, la expresi\u00f3n \"<code>#[01]</code>\" admitir\u00eda cadenas como \"<code>#0</code>\" o \"<code>#1</code>\", pero al ponerlo entre par\u00e9ntesis e indicar los contadores de repetici\u00f3n, lo que estamos diciendo es que la misma secuencia se tiene que repetir entre dos y tres veces, con lo que las cadenas que admitir\u00eda ser\u00edan del estilo a: \"<code>#0#1</code>\" o \"<code>#0#1#0</code>\".</p> <p>Pero los par\u00e9ntesis tienen una funci\u00f3n adicional, y es la de permitir definir grupos. Un grupo comienza cuando se abre un par\u00e9ntesis y termina cuando se cierra el par\u00e9ntesis. Los grupos permiten acceder de forma c\u00f3moda a las diferentes partes de una cadena cuando esta coincide con una expresi\u00f3n regular. Lo mejor es verlo con un ejemplo (seguro que te resultar\u00e1 familiar):</p> JavaKotlinPython <pre><code>import java.util.regex.Pattern;\nimport java.util.regex.Matcher;\n\nPattern p = Pattern.compile(\"([XY]?)([0-9]{1,9})([A-Za-z])\");\nMatcher m = p.matcher(\"X123456789Z Y00110011M 999999T\");\nwhile (m.find()) {\n    System.out.println(\"Letra inicial (opcional):\" + m.group(1));\n    System.out.println(\"N\u00famero:\" + m.group(2));\n    System.out.println(\"Letra NIF:\" + m.group(3));\n}\n</code></pre> <pre><code>import java.util.regex.Pattern\n\nval p = Pattern.compile(\"([XY]?)([0-9]{1,9})([A-Za-z])\")\nval m = p.matcher(\"X123456789Z Y00110011M 999999T\")\nwhile (m.find()) {\n    println(\"Letra inicial (opcional): ${m.group(1)}\")\n    println(\"N\u00famero: ${m.group(2)}\")\n    println(\"Letra NIF: ${m.group(3)}\")\n}\n</code></pre> <pre><code>import re\n\np = re.compile(r\"([XY]?)([0-9]{1,9})([A-Za-z])\")\nm = p.finditer(\"X123456789Z Y00110011M 999999T\")\nfor match in m:\n    print(f\"Letra inicial (opcional): {match.group(1)}\")\n    print(f\"N\u00famero: {match.group(2)}\")\n    print(f\"Letra NIF: {match.group(3)}\")\n</code></pre> <p>Usando los grupos, podemos obtener por separado el texto contenido en cada uno de los grupos. En el ejemplo anterior, en el patr\u00f3n hay tres grupos: uno para la letra inicial (grupo 1), otro para el n\u00famero del DNI o NIE (grupo 2), y otro para la letra final o letra NIF (grupo 3). Al ponerlo en grupos, usando el m\u00e9todo <code>group()</code>, podemos extraer la informaci\u00f3n de cada grupo y usarla a nuestra conveniencia.</p> <p>Ten en cuenta que el primer grupo es el 1, y no el 0. Si pones <code>m.group(0)</code> obtendr\u00e1s una cadena con toda la ocurrencia o coincidencia del patr\u00f3n en la cadena, es decir, obtendr\u00e1s la secuencia entera de s\u00edmbolos que coincide con el patr\u00f3n.</p> <p>En el ejemplo anterior se usa el m\u00e9todo <code>find</code>, \u00e9ste buscar\u00e1 una a una, cada una de las ocurrencias del patr\u00f3n en la cadena. Cada vez que se invoca, busca la siguiente ocurrencia del patr\u00f3n y devolver\u00e1 <code>true</code> si ha encontrado una ocurrencia. Si no encuentra en una iteraci\u00f3n ninguna ocurrencia es porque no existen m\u00e1s, y retornar\u00e1 <code>false</code>, saliendo del bucle. Esta construcci\u00f3n <code>while</code> es muy t\u00edpica para este tipo de m\u00e9todos y para las iteraciones, que veremos m\u00e1s adelante.</p> <p>Lo \u00faltimo importante de las expresiones regulares que debes conocer son las secuencias de escape. Cuando en una expresi\u00f3n regular necesitamos especificar que lo que tiene que haber en la cadena es un par\u00e9ntesis, una llave, o un corchete, tenemos que usar una secuencia de escape, dado que esos s\u00edmbolos tienen un significado especial en los patrones. Para ello, simplemente antepondremos \"<code>\\\\</code>\" al s\u00edmbolo. Por ejemplo, \"<code>\\\\(</code>\" significar\u00e1 que debe haber un par\u00e9ntesis en la cadena y se omitir\u00e1 el significado especial del par\u00e9ntesis. Lo mismo ocurre con \"<code>\\\\[</code>\", \"<code>\\\\]</code>\", \"<code>\\\\)</code>\", etc. Lo mismo para el significado especial del punto, \u00e9ste, tiene un significado especial (\u00bfLo recuerdas del apartado anterior?) salvo que se ponga \"<code>\\\\.</code>\", que pasar\u00e1 a significar \"un punto\" en vez de \"cualquier car\u00e1cter\". La excepci\u00f3n son las comillas, que se pondr\u00edan con una sola barra: \"<code>\\\"</code>\".</p>"},{"location":"Unidad%206%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Avanzada%29/Unidad%206%20POO.%20Uso%20avanzado%20de%20clases%20-%20Herencia%2C%20polimorfismo%20y%20clases%20abstractas_2026/","title":"Unidad 6 - POO. Uso avanzado de clases: Herencia, polimorfismo y clases abstractas e interfaces","text":""},{"location":"Unidad%206%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Avanzada%29/Unidad%206%20POO.%20Uso%20avanzado%20de%20clases%20-%20Herencia%2C%20polimorfismo%20y%20clases%20abstractas_2026/#1-introduccion-a-la-herencia","title":"1. Introducci\u00f3n a la herencia","text":"<p>Las clases representan un tipo de dato complejo y est\u00e1n compuestas por atributos y m\u00e9todos. A diferencia de los arrays, las clases agrupan datos de diferentes  tipos que se denominan atributos y tambi\u00e9n m\u00e9todos que nos permiten  trabajar con esos atributos.</p> <p>Una clase por tanto, especifica las caracter\u00edsticas comunes de un conjunto de objetos. Sin embargo, cuando queramos utilizar ese tipo de dato en nuestros  programas tendremos que crear un objeto. De esta forma los programas que escribas estar\u00e1n formados por un conjunto de clases a partir de las cuales ir\u00e1s creando objetos que se interrelacionar\u00e1n unos con otros. En muchos casos tambi\u00e9n se  habla de las clases como de las plantillas o planos a partir de los  cuales se crean los objetos.</p> <p>Adem\u00e1s de ellos, veremos que las clases nos van a permitir organizar  nuestros programas de otra manera. Es a lo que vamos a llamar  programaci\u00f3n orientada a objetos (POO). La herencia es uno de los conceptos fundamentales que introduce la programaci\u00f3n orientada a objetos. La idea fundamental es permitir crear nuevas clases aprovechando las caracter\u00edsticas (atributos y m\u00e9todos) de otras clases ya creadas evitando as\u00ed tener que volver a definir esas caracter\u00edsticas (reutilizaci\u00f3n).</p> <p>A una clase que hereda de otra se le llama subclase o clase hija y aquella de la que se hereda es conocida como superclase o clase padre. Tambi\u00e9n se puede hablar en general de clases descendientes o clases ascendientes. Al heredar, la subclase adquiere todas las caracter\u00edsticas (atributos y m\u00e9todos) de su superclase, aunque algunas de ellas pueden ser sobrescritas o modificadas dentro de la subclase (a eso se le suele llamar especializaci\u00f3n).</p> <p>Una clase puede heredar de otra que a su vez ha podido heredar de una tercera y as\u00ed sucesivamente. Esto significa que las clases van tomando todas las caracter\u00edsticas de sus clases ascendientes (no s\u00f3lo de su superclase o clase padre inmediata) a lo largo de toda la rama del \u00e1rbol de la jerarqu\u00eda de clases en la que se encuentre.</p> <p>Imagina que quieres modelar el funcionamiento de algunos veh\u00edculos para trabajar con ellos en un programa de simulaci\u00f3n. Lo primero que haces es pensar en una clase Veh\u00edculo que tendr\u00e1 un conjunto de atributos (por ejemplo: posici\u00f3n actual, velocidad actual y velocidad m\u00e1xima que puede alcanzar el veh\u00edculo) y de m\u00e9todos (por ejemplo: detener, acelerar, frenar, establecerDirecci\u00f3n, establecer sentido).</p> <p>Dado que vas a trabajar con muchos tipos de veh\u00edculos, no tendr\u00e1s suficiente con esas caracter\u00edsticas, as\u00ed que seguramente vas a necesitar nuevas clases que las incorporen. Pero las caracter\u00edsticas b\u00e1sicas que has definido en la clase Veh\u00edculo van a ser compartidas por cualquier nuevo veh\u00edculo que vayas a modelar. Esto significa que si creas otra clase podr\u00edas heredar de Veh\u00edculo todas esos atributos y propiedades y tan solo tendr\u00edas que a\u00f1adir las nuevas.</p> <p>Si vas a trabajar con veh\u00edculos que se desplazan por tierra, agua y aire, tendr\u00e1s que idear nuevas clases con caracter\u00edsticas adicionales. Por ejemplo, podr\u00edas crear una clase VehiculoTerrestre, que herede las caracter\u00edsticas de Veh\u00edculo, pero que tambi\u00e9n incorpore atributos como el n\u00famero de ruedas o la altura de los bajos). A su vez, podr\u00eda idearse una nueva clase que herede de VehiculoTerrestre y que incorpore nuevos atributos y m\u00e9todos como, por ejemplo, una clase Coche. Y as\u00ed sucesivamente con toda la jerarqu\u00eda de clases heredadas que consideres oportunas para representar lo mejor posible el entorno y la informaci\u00f3n sobre la que van a trabajar tus programas.os a utilizar los mismos  elementos que hemos utilizado hasta ahora pero organizados en base a  clases.</p> <p></p>"},{"location":"Unidad%206%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Avanzada%29/Unidad%206%20POO.%20Uso%20avanzado%20de%20clases%20-%20Herencia%2C%20polimorfismo%20y%20clases%20abstractas_2026/#11-creacion-y-utilizacion-de-clases-heredadas","title":"1.1 Creaci\u00f3n y utilizaci\u00f3n de clases heredadas","text":"<p>\u00bfC\u00f3mo se indica en Java que una clase hereda de otra? Para indicar que una clase hereda de otra es necesario utilizar la palabra reservada <code>extends</code> junto con el nombre de la clase de la que se quieren heredar sus caracter\u00edsticas:</p> <pre><code>class &lt;NombreClase&gt; extends &lt;nombreSuperClase&gt; {\n...\n} \n</code></pre> <p>En el ejemplo anterior de los veh\u00edculos, la clase VehiculoTerrestre podr\u00eda quedar as\u00ed al ser declarada:</p> <pre><code>class VehiculoTerrestre extends Veh\u00edculo {\n...\n} \n</code></pre> <p>Y en el caso de la clase Coche:</p> <pre><code>java\nclass Coche extends Veh\u00edculoTerrestre {\n...\n}\n</code></pre> <p>En unidades posteriores estudiar\u00e1s detalladamente c\u00f3mo crear una jerarqu\u00eda de clases y qu\u00e9 relaci\u00f3n existe entre la herencia y los distintos modificadores de clases, atributos y m\u00e9todos. Por ahora es suficiente con que entiendas el concepto de herencia y sepas reconocer cu\u00e1ndo una clase hereda de otra (uso de la palabra reservada <code>extends</code>).</p> <p></p> <p>Puedes comprobar que en las bibliotecas proporcionadas por Java aparecen jerarqu\u00edas bastante complejas de clases heredadas en las cuales se han ido aprovechando cada uno de los miembros de una clase base para ir construyendo las distintas clases derivadas a\u00f1adiendo (y a veces modificando) poco a poco nueva funcionalidad. Eso suele suceder en cualquier proyecto de software conforme se van a analizando, descomponiendo y modelando los datos con los que hay que trabajar. La idea es poder representar de una manera eficiente toda la informaci\u00f3n que es manipulada por el sistema que se desea automatizar. Una jerarqu\u00eda de clases suele ser una buena forma de hacerlo.</p> <p>En el caso de Java, cualquier clase con la que trabajes tendr\u00e1 un ascendiente. Si en la declaraci\u00f3n de clase no indicas la clase de la que se hereda (no se incluye un <code>extends</code>), el compilador considerar\u00e1 autom\u00e1ticamente que se hereda de la clase <code>Object</code>, que es la clase que se encuentra en el nivel superior de toda la jerarqu\u00eda de clases en Java (y que es la \u00fanica que no hereda de nadie).</p> <p>Tambi\u00e9n ir\u00e1s viendo al estudiar distintos componentes de las bibliotecas de Java (por ejemplo en el caso de las interfaces gr\u00e1ficas) que para poder crear objetos basados en las clases proporcionadas por esas bibliotecas tendr\u00e1s que crear tus propias clases que hereden de algunas de esas clases. Para ellos tendr\u00e1s que hacer uso de la palabra reservada <code>extends</code>.</p> <p>En Java todas las clases son descendientes (de manera expl\u00edcita o impl\u00edcita) de la clase <code>Object</code>.</p> Comparaci\u00f3n entre lenguajes: Herencia JavaPythonKotlin <pre><code>java class Vehiculo {} \nclass Coche extends Vehiculo {}\n</code></pre> <pre><code>class Vehiculo:\n    pass\n\nclass Coche(Vehiculo):\n    pass\n</code></pre> <pre><code>open class Vehiculo\nclass Coche : Vehiculo()\n</code></pre>"},{"location":"Unidad%206%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Avanzada%29/Unidad%206%20POO.%20Uso%20avanzado%20de%20clases%20-%20Herencia%2C%20polimorfismo%20y%20clases%20abstractas_2026/#2-la-herencia","title":"2. La Herencia","text":"<p>Como ya has estudiado, la herencia es el mecanismo que permite definir una nueva clase a partir de otra, pudiendo a\u00f1adir nuevas caracter\u00edsticas, sin tener que volver a escribir todo el c\u00f3digo de la clase base.</p> <p></p> <p>La clase de la que se hereda suele ser llamada clase padre. A la clase que hereda se le suele llamar clase hija.</p> <p>Una clase derivada puede ser a su vez clase padre de otra que herede de ella y as\u00ed sucesivamente dando lugar a una jerarqu\u00eda de clases, excepto aquellas que est\u00e9n en la parte de arriba de la jerarqu\u00eda (s\u00f3lo ser\u00e1n clases padre) o en la parte de abajo (s\u00f3lo ser\u00e1n clases hijas).</p> <p>Una clase hija no tiene acceso a los miembros privados de su clase padre, tan solo a los p\u00fablicos (como cualquier parte del c\u00f3digo tendr\u00eda) y los protegidos (a los que s\u00f3lo tienen acceso las clases derivadas y las del mismo paquete). Aquellos miembros que sean privados en la clase base tambi\u00e9n habr\u00e1n sido heredados, pero el acceso a ellos estar\u00e1 restringido al propio funcionamiento de la superclase y s\u00f3lo se podr\u00e1 acceder a ellos si la superclase ha dejado alg\u00fan medio indirecto para hacerlo (por ejemplo a trav\u00e9s de alg\u00fan m\u00e9todo).</p> <p>Todos los miembros de la superclase, tanto atributos como m\u00e9todos, son heredados por la subclase. Algunos de estos miembros heredados podr\u00e1n ser redefinidos o sobrescritos (overriden) y tambi\u00e9n podr\u00e1n a\u00f1adirse nuevos miembros. De alguna manera podr\u00eda decirse que est\u00e1s \u201campliando\u201d la clase base con caracter\u00edsticas adicionales o modificando algunas de ellas (proceso de especializaci\u00f3n).</p> <p>Una clase derivada extiende la funcionalidad de la clase base sin tener que volver a escribir el c\u00f3digo de la clase base.</p> <p>La idea de la herencia no es complicar los programas, sino todo lo contrario: simplificarlos al m\u00e1ximo. Procurar que haya que escribir la menor cantidad posible de c\u00f3digo repetitivo e intentar facilitar en lo posible la realizaci\u00f3n de cambios (bien para corregir errores bien para incrementar la funcionalidad).</p>"},{"location":"Unidad%206%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Avanzada%29/Unidad%206%20POO.%20Uso%20avanzado%20de%20clases%20-%20Herencia%2C%20polimorfismo%20y%20clases%20abstractas_2026/#21-sintaxis-de-la-herencia","title":"2.1 Sintaxis de la herencia","text":"<p>En Java la herencia se indica mediante la palabra reservada <code>extends</code>:</p> <pre><code>[modificador] class ClasePadre {\n    \u2026\n}\n\n[modificador] class ClaseHija extends ClasePadre {\n    \u2026\n}\n</code></pre> <p>Imagina que tienes una clase Persona que contiene atributos como nombre, apellidos y fecha de nacimiento:</p> <p><pre><code>public class Persona {\n     String nombre;\n     String apellidos;\n     LocalDate fechaNacim;\n     \u2026\n}\n</code></pre> </p> <p>Es posible que, m\u00e1s adelante, necesites una clase Alumno que compartir\u00e1 esos atributos (dado que todo alumno es una persona, pero con algunas caracter\u00edsticas espec\u00edficas que lo especializan). En tal caso tendr\u00edas la posibilidad de crear una clase Alumno que repitiera todos esos atributos o bien heredar de la clase Persona:</p> <pre><code>public class Alumno extends Persona {\n     String grupo;\n     double notaMedia; \n     \u2026\n}\n</code></pre> <p></p> <p>A partir de ahora, un objeto de la clase <code>Alumno</code> contendr\u00e1 los atributos <code>grupo</code> y <code>notaMedia</code> (propios de la clase <code>Alumno</code>), pero tambi\u00e9n <code>nombre</code>, <code>apellidos</code> y <code>fechaNacim</code> (propios de su clase base <code>Persona</code> y que por tanto ha heredado).</p>"},{"location":"Unidad%206%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Avanzada%29/Unidad%206%20POO.%20Uso%20avanzado%20de%20clases%20-%20Herencia%2C%20polimorfismo%20y%20clases%20abstractas_2026/#ejercicio-1","title":"Ejercicio 1","text":"<p>Imagina que tambi\u00e9n necesitas una clase Profesor, que contar\u00e1 con atributos como nombre, apellidos, fecha de nacimiento, salario y especialidad. \u00bfC\u00f3mo crear\u00edas esa nueva clase y qu\u00e9 atributos le a\u00f1adir\u00edas?</p>"},{"location":"Unidad%206%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Avanzada%29/Unidad%206%20POO.%20Uso%20avanzado%20de%20clases%20-%20Herencia%2C%20polimorfismo%20y%20clases%20abstractas_2026/#22-acceso-a-miembros-heredados","title":"2.2 Acceso a miembros heredados","text":"<p>Como ya has visto anteriormente, no es posible acceder a miembros privados de una superclase. Para poder acceder a ellos podr\u00edas pensar en hacerlos p\u00fablicos, pero entonces estar\u00edas dando la opci\u00f3n de acceder a ellos a cualquier objeto externo y es probable que tampoco sea eso lo deseable. Para ello se invent\u00f3 el modificador <code>protected</code> (protegido) que permite el acceso desde clases heredadas, pero no desde fuera de las clases (estrictamente hablando, desde fuera del paquete), que ser\u00edan como miembros privados.</p> <p>En la unidad dedicada a la utilizaci\u00f3n de clases ya estudiaste los posibles modificadores de acceso que pod\u00eda tener un miembro: sin modificador (acceso de paquete), p\u00fablico, privado o protegido. Aqu\u00ed tienes de nuevo el resumen:</p> <p>Cuadro de niveles accesibilidad a los atributos de una clase</p> Misma clase Subclase Mismo paquete Otro paquete Sin modificador (paquete) X X public X X X X private X protected X X X <p>Si en el ejemplo anterior de la clase <code>Persona</code> se hubieran definido sus atributos como <code>private</code>:Si en el ejemplo anterior de la clase Persona se hubieran definido sus atributos como private:</p> <pre><code>public class Persona {\n     private String nombre;\n     private String apellidos;\n     \u2026\n}\n</code></pre> <p></p> <p>Al definir la clase <code>Alumno</code> como heredera de <code>Persona</code>, no habr\u00edas tenido acceso a esos atributos, pudiendo ocasionar un grave problema de operatividad al intentar manipular esa informaci\u00f3n. Por tanto, en estos casos lo m\u00e1s recomendable habr\u00eda sido declarar esos atributos como <code>protected</code> o bien sin modificador (para que tambi\u00e9n tengan acceso a ellos otras clases del mismo paquete, si es que se considera oportuno):</p> <pre><code>public class Persona {\n     protected String nombre;\n     protected String apellidos;\n     \u2026\n}\n</code></pre> Comparaci\u00f3n entre lenguajes: Acceso protegido <p>S\u00f3lo en aquellos casos en los que se desea expl\u00edcitamente que un miembro de una clase no pueda ser accesible desde una clase derivada deber\u00eda utilizarse el modificador <code>private</code>. En el resto de casos es recomendable utilizar <code>protected</code>, o bien no indicar modificador (acceso a nivel de paquete).</p>"},{"location":"Unidad%206%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Avanzada%29/Unidad%206%20POO.%20Uso%20avanzado%20de%20clases%20-%20Herencia%2C%20polimorfismo%20y%20clases%20abstractas_2026/#ejercicio-2","title":"Ejercicio 2","text":"<p>Rescribe las clases <code>Alumno</code> y <code>Profesor</code> utilizando el modificador <code>protected</code> para sus atributos del mismo modo que se ha hecho para su superclase <code>Persona</code></p> <p>Comparaci\u00f3n entre lenguajes: Acceso protegido</p> JavaPythonKotlin <pre><code>public class Persona { \n\nprotected String nombre; \n\n} \n\nclass Alumno extends Persona {\n\n// acceso a nombre permitido\n\n}\n</code></pre> <pre><code>class Persona:\n    def __init__(self):\n        self._nombre = \"\"  # Convenci\u00f3n para \"protegido\"\n        class Alumno(Persona):\n    def __init__(self):\n        super().__init__()\n        # acceso a self._nombre permitido\n</code></pre> <pre><code>    open class Persona {\n        protected var nombre: String = \"\"\n    }\n    class Alumno : Persona() {\n        // acceso a nombre permitido\n    }\n</code></pre>"},{"location":"Unidad%206%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Avanzada%29/Unidad%206%20POO.%20Uso%20avanzado%20de%20clases%20-%20Herencia%2C%20polimorfismo%20y%20clases%20abstractas_2026/#23-utilizacion-de-miembros-heredados-i-atributos","title":"2.3 Utilizaci\u00f3n de miembros heredados (I). Atributos","text":"<p>Los atributos heredados por una clase son, a efectos pr\u00e1cticos, iguales que aquellos que sean definidos espec\u00edficamente en la nueva clase derivada.</p> <p>En el ejemplo anterior la clase <code>Persona</code> dispon\u00eda de tres atributos y la clase <code>Alumno</code>, que heredaba de ella, a\u00f1ad\u00eda dos atributos m\u00e1s. Desde un punto de vista funcional podr\u00edas considerar que la clase <code>Alumno</code> tiene cinco atributos: tres por ser <code>Persona</code> (nombre, apellidos, fecha de nacimiento) y otros dos m\u00e1s por ser <code>Alumno</code>(grupo y nota media).</p>"},{"location":"Unidad%206%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Avanzada%29/Unidad%206%20POO.%20Uso%20avanzado%20de%20clases%20-%20Herencia%2C%20polimorfismo%20y%20clases%20abstractas_2026/#ejercicio-3","title":"Ejercicio 3","text":"<p>Dadas las clases <code>Alumno</code> y <code>Profesor</code> que has utilizado anteriormente, implementa m\u00e9todos get y set en las clases <code>Alumno</code> y <code>Profesor</code> para trabajar con sus cinco atributos (tres heredados m\u00e1s dos espec\u00edficos).</p>"},{"location":"Unidad%206%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Avanzada%29/Unidad%206%20POO.%20Uso%20avanzado%20de%20clases%20-%20Herencia%2C%20polimorfismo%20y%20clases%20abstractas_2026/#231-utilizacion-de-miembros-heredados-ii-metodos","title":"2.3.1 Utilizaci\u00f3n de miembros heredados (II). M\u00e9todos","text":"<p>Del mismo modo que se heredan los atributos, tambi\u00e9n se heredan los m\u00e9todos, convirti\u00e9ndose a partir de ese momento en otros m\u00e9todos m\u00e1s de la clase derivada, junto a los que hayan sido definidos espec\u00edficamente.</p> <p>En el ejemplo de la clase <code>Persona</code>, si dispusi\u00e9ramos de m\u00e9todos get y set para cada uno de sus tres atributos (<code>nombre</code>, <code>apellidos</code>, <code>fechaNacim</code>), tendr\u00edas seis m\u00e9todos que podr\u00edan ser heredados por sus clases derivadas. Podr\u00edas decir entonces que la clase <code>Alumno</code>, derivada de <code>Persona</code>, tiene diez m\u00e9todos:</p> <ul> <li>Seis por ser <code>Persona</code> (<code>getNombre</code>, <code>getApellidos</code>, <code>getFechaNacim</code>, <code>setNombre</code>, <code>setApellidos</code>, <code>setFechaNacim</code>).</li> <li>Oros cuatro m\u00e1s por ser <code>Alumno</code> (<code>getGrupo</code>, <code>setGrupo</code>, <code>getNotaMedia</code>, <code>setNotaMedia</code>).</li> </ul> <p>Sin embargo, s\u00f3lo tendr\u00edas que definir esos cuatro \u00faltimos (los espec\u00edficos) pues los gen\u00e9ricos ya los has heredado de la superclase.</p>"},{"location":"Unidad%206%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Avanzada%29/Unidad%206%20POO.%20Uso%20avanzado%20de%20clases%20-%20Herencia%2C%20polimorfismo%20y%20clases%20abstractas_2026/#ejercicio-4","title":"Ejercicio 4","text":"<p>Dadas las clases <code>Persona</code>, <code>Alumno</code> y <code>Profesor</code> que has utilizado anteriormente, implementa m\u00e9todos get y set en la clase <code>Persona</code> para trabajar con sus tres atributos y en las clases <code>Alumno</code> y <code>Profesor</code> para manipular sus cinco atributos (tres heredados m\u00e1s dos espec\u00edficos), teniendo en cuenta que los m\u00e9todos que ya hayas definido para <code>Persona</code> van a ser heredados en <code>Alumno</code> y en <code>Profesor</code>.</p>"},{"location":"Unidad%206%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Avanzada%29/Unidad%206%20POO.%20Uso%20avanzado%20de%20clases%20-%20Herencia%2C%20polimorfismo%20y%20clases%20abstractas_2026/#24-redefinicion-de-metodos-heredados","title":"2.4 Redefinici\u00f3n de m\u00e9todos heredados","text":"<p>Una clase puede redefinir algunos de los m\u00e9todos que ha heredado de su clase base. En tal caso, el nuevo m\u00e9todo (especializado) sustituye al heredado. Este procedimiento tambi\u00e9n es conocido como de sobrescritura de m\u00e9todos.</p> <p></p> <p>En cualquier caso, aunque un m\u00e9todo sea sobrescrito o redefinido, a\u00fan es posible acceder a \u00e9l a trav\u00e9s de la referencia <code>super</code>, aunque s\u00f3lo se podr\u00e1 acceder a m\u00e9todos de la clase padre y no a m\u00e9todos de clases superiores en la jerarqu\u00eda de herencia.</p> <p>Los m\u00e9todos redefinidos pueden ampliar su accesibilidad con respecto a la que ofrezca el m\u00e9todo original de la superclase, pero nunca restringirla. Por ejemplo, si un m\u00e9todo es declarado como <code>protected</code> o de paquete en la clase base, podr\u00eda ser redefinido como <code>public</code> en una clase derivada.</p> <p>Los m\u00e9todos est\u00e1ticos o de clase no pueden ser sobrescritos. Los originales de la clase base permanecen inalterables a trav\u00e9s de toda la jerarqu\u00eda de herencia.</p> <p>En el ejemplo de la clase <code>Alumno</code>, podr\u00edan redefinirse algunos de los m\u00e9todos heredados. Por ejemplo, imagina que el m\u00e9todo <code>getApellidos</code> devuelva la cadena \"Alumno:\" junto con los apellidos del alumno. En tal caso habr\u00eda que rescribir ese m\u00e9todo para realizara esa modificaci\u00f3n:</p> JavaPythonKotlin <pre><code>public String getApellidos() {\n    return \"Alumno: \" + apellidos;\n}\n</code></pre> <pre><code>class Alumno(Persona):\n    def __init__(self, nombre, apellidos, fecha_nacim, grupo, nota_media):\n        super().__init__(nombre, apellidos, fecha_nacim)\n        self.grupo = grupo\n        self.nota_media = nota_media\n</code></pre> <pre><code>class Alumno(nombre: String, apellidos: String, fechaNacim: LocalDate, val grupo: String, val notaMedia: Double) :\n        Persona(nombre, apellidos, fechaNacim)\n</code></pre> <p>Cuando sobrescribas un m\u00e9todo heredado en Java puedes incluir la anotaci\u00f3n <code>@Override</code>. Esto indicar\u00e1 al compilador que tu intenci\u00f3n es sobrescribir el m\u00e9todo de la clase padre. De este modo, si te equivocas (por ejemplo, al escribir el nombre del m\u00e9todo) y no lo est\u00e1s realmente sobrescribiendo, el compilador producir\u00e1 un error y as\u00ed podr\u00e1s darte cuenta del fallo. En cualquier caso, no es necesario indicar <code>@Override</code>, pero puede resultar de ayuda a la hora de localizar este tipo de errores (crees que has sobrescrito un m\u00e9todo heredado y al confundirte en una letra est\u00e1s realmente creando un nuevo m\u00e9todo diferente). En el caso del ejemplo anterior quedar\u00eda:</p> Java <pre><code>@Override\npublic String getApellidos()\n</code></pre>"},{"location":"Unidad%206%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Avanzada%29/Unidad%206%20POO.%20Uso%20avanzado%20de%20clases%20-%20Herencia%2C%20polimorfismo%20y%20clases%20abstractas_2026/#ejercicio-5","title":"Ejercicio 5","text":"<p>Dadas las clases <code>Persona</code>, <code>Alumno</code> y <code>Profesor</code> que has utilizado anteriormente, redefine el m\u00e9todo <code>getNombre</code> para que devuelva la cadena \u201c<code>Alumno:</code>\u201c, junto con el nombre del alumno, si se trata de un objeto de la clase <code>Alumno</code> o bien \u201c<code>Profesor</code> \u201c, junto con el nombre del profesor, si se trata de un objeto de la clase <code>Profesor</code>.</p> <p>Comparaci\u00f3n entre lenguajes: Sobrescritura de m\u00e9todos</p> JavaPythonKotlin <pre><code>@Override\npublic String getNombre()\n{ \nreturn \"Alumno: \" + nombre; \n}\n</code></pre> <pre><code>def get_nombre(self):\n    return f\"Alumno: {self._nombre}\"\n</code></pre> <pre><code>override fun getNombre(): String {\n    return \"Alumno: $nombre\"\n}\n</code></pre>"},{"location":"Unidad%206%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Avanzada%29/Unidad%206%20POO.%20Uso%20avanzado%20de%20clases%20-%20Herencia%2C%20polimorfismo%20y%20clases%20abstractas_2026/#25-ampliacion-de-metodos-heredados","title":"2.5 Ampliaci\u00f3n de m\u00e9todos heredados","text":"<p>Hasta ahora, has visto que para redefinir o sustituir un m\u00e9todo de una superclase es suficiente con crear otro m\u00e9todo en la subclase que tenga el mismo nombre que el m\u00e9todo que se desea sobrescribir. Pero, en otras ocasiones, puede que lo que necesites no sea sustituir completamente el comportamiento del m\u00e9todo de la superclase, sino simplemente ampliarlo.</p> <p>Para poder hacer esto necesitas poder preservar el comportamiento antiguo (el de la superclase) y a\u00f1adir el nuevo (el de la subclase). Para ello, puedes invocar desde el m\u00e9todo \u201campliador\u201d de la clase derivada al m\u00e9todo \u201campliado\u201d de la clase superior (teniendo ambos m\u00e9todos el mismo nombre). \u00bfC\u00f3mo se puede conseguir eso? Puedes hacerlo mediante el uso de la referencia <code>super</code>.</p> <p>La palabra reservada <code>super</code> es una referencia a la clase padre de la clase en la que te encuentres en cada momento (es algo similar a <code>this</code>, que representaba una referencia a la clase actual). De esta manera, podr\u00edas invocar a cualquier m\u00e9todo de tu superclase (si es que se tiene acceso a \u00e9l).</p> <p>Por ejemplo, imagina que la clase <code>Persona</code> dispone de un m\u00e9todo que permite mostrar el contenido de algunos datos personales de los objetos de este tipo (nombre, apellidos, etc.). Por otro lado, la clase <code>Alumno</code> tambi\u00e9n necesita un m\u00e9todo similar, pero que muestre tambi\u00e9n su informaci\u00f3n especializada (grupo, nota media, etc.). \u00bfC\u00f3mo podr\u00edas aprovechar el m\u00e9todo de la superclase para no tener que volver a escribir su contenido en la subclase?</p> <p>Podr\u00eda hacerse de una manera tan sencilla como la siguiente:</p> Java <pre><code>public void mostrar() {\n    super.mostrar();     // Llamada al m\u00e9todo \u201cmostrar\u201d de la superclase\n    // A continuaci\u00f3n mostramos la informaci\u00f3n \u201cespecializada\u201d de esta subclase\n    System.out.printf(\"Grupo: %s\\n\", this.grupo);\n    System.out.printf(\"Nota media: %5.2f\\n\", this.notaMedia); \n}\n</code></pre> <p>Este tipo de ampliaciones de m\u00e9todos resultan especialmente \u00fatiles por ejemplo en el caso de los constructores, donde se podr\u00eda ir llamando a los constructores de cada superclase encadenadamente hasta el constructor de la clase en la c\u00faspide de la jerarqu\u00eda (el constructor de la clase <code>Object</code>).</p>"},{"location":"Unidad%206%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Avanzada%29/Unidad%206%20POO.%20Uso%20avanzado%20de%20clases%20-%20Herencia%2C%20polimorfismo%20y%20clases%20abstractas_2026/#ejercicio-6","title":"Ejercicio 6","text":"<p>Dadas las clases <code>Persona</code>, <code>Alumno</code> y <code>Profesor</code>, define un m\u00e9todo toString para la clase <code>Persona</code>, que devuelva una cadena de caracteres con el contenido de los atributos (datos personales) de un objeto de la clase <code>Persona</code>. A continuaci\u00f3n, define sendos m\u00e9todos toString especializados para las clases <code>Alumno</code> y <code>Profesor</code> que \u201campl\u00eden\u201d la funcionalidad del m\u00e9todo original de la clase <code>Persona</code>.</p> <p>Comparaci\u00f3n entre lenguajes: Llamada al m\u00e9todo de la superclase</p> JavaPythonKotlin <pre><code>public void mostrar() { \nsuper.mostrar(); \n}\n</code></pre> <pre><code>def mostrar(self):\n    super().mostrar()\n</code></pre> <pre><code>override fun mostrar() {\n    super.mostrar()\n    }\n</code></pre>"},{"location":"Unidad%206%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Avanzada%29/Unidad%206%20POO.%20Uso%20avanzado%20de%20clases%20-%20Herencia%2C%20polimorfismo%20y%20clases%20abstractas_2026/#26-constructores-y-herencia","title":"2.6 Constructores y herencia","text":"<p>Recuerda que cuando estudiaste los constructores viste que un constructor de una clase puede llamar a otro constructor de la misma clase, previamente definido, a trav\u00e9s de la referencia <code>this</code>. En estos casos, la utilizaci\u00f3n de <code>this</code> s\u00f3lo pod\u00eda hacerse en la primera l\u00ednea de c\u00f3digo del constructor.</p> <p>Como ya has visto, un constructor de una clase derivada puede hacer algo parecido para llamar al constructor de su clase base mediante el uso de la palabra <code>super</code>. De esta manera, el constructor de una clase derivada puede llamar primero al constructor de su superclase para que inicialice los atributos heredados y posteriormente se inicializar\u00e1n los atributos espec\u00edficos de la clase: los no heredados. Nuevamente, esta llamada tambi\u00e9n debe ser la primera sentencia de un constructor (con la \u00fanica excepci\u00f3n de que exista una llamada a otro constructor de la clase mediante <code>this</code>).</p> <p>Si no se incluye una llamada a <code>super()</code> dentro del constructor, el compilador incluye autom\u00e1ticamente una llamada al constructor por defecto de clase base (llamada a <code>super()</code>). Esto da lugar a una llamada en cadena de constructores de superclase hasta llegar a la clase m\u00e1s alta de la jerarqu\u00eda (que en Java es la clase <code>Object</code>).</p> <p>En el caso del constructor por defecto (el que crea el compilador si el programador no ha escrito ninguno), el compilador a\u00f1ade lo primero de todo, antes de la inicializaci\u00f3n de los atributos a sus valores por defecto, una llamada al constructor de la clase base mediante la referencia <code>super</code>.</p> <p>A la hora de destruir un objeto (m\u00e9todo <code>finalize</code>) es importante llamar a los finalizadores en el orden inverso a como fueron llamados los constructores (primero se liberan los recursos de la clase derivada y despu\u00e9s los de la clase base mediante la llamada <code>super.finalize()</code>).</p> <p>Si la clase <code>Persona</code> tuviera un constructor de este tipo:</p> Java <pre><code>public Persona(String nombre, String apellidos, LocalDate fechaNacim) {\n    this.nombe = nombre;\n    this.apellidos = apellidos;\n    this.fechaNacim = LocalDate;\n}\n</code></pre> <p>Podr\u00edas llamarlo desde un constructor de una clase derivada (por ejemplo <code>Alumno</code>) de la siguiente forma:</p> Java <pre><code>public Alumno(String nombre, String apellidos, LocalDate fechaNacim, String grupo, double notaMedia) {\n    super(nombre, apellidos, fechaNacim);\n    this.grupo = grupo;\n    this.notaMedia = notaMedia;\n}\n</code></pre> <p>En realidad se trata de otro recurso m\u00e1s para optimizar la reutilizaci\u00f3n de c\u00f3digo, en este caso el del constructor, que aunque no es heredado, s\u00ed puedes invocarlo para no tener que rescribirlo.</p>"},{"location":"Unidad%206%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Avanzada%29/Unidad%206%20POO.%20Uso%20avanzado%20de%20clases%20-%20Herencia%2C%20polimorfismo%20y%20clases%20abstractas_2026/#ejercicio-7","title":"Ejercicio 7","text":"<p>Escribe un constructor para la clase Profesor que realice una llamada al constructor de su clase base para inicializar sus atributos heredados. Los atributos espec\u00edficos (no heredados) s\u00ed deber\u00e1n ser inicializados en el propio constructor de la clase Profesor.</p> <p>Comparaci\u00f3n entre lenguajes: Constructores y herencia</p> Java <pre><code>public Alumno(String nombre, String apellidos, LocalDate fechaNacim, String grupo, double notaMedia) \n{ \n    super(nombre, apellidos, fechaNacim); \n    this.grupo = grupo; \n    this.notaMedia = notaMedia; \n}\n</code></pre>"},{"location":"Unidad%206%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Avanzada%29/Unidad%206%20POO.%20Uso%20avanzado%20de%20clases%20-%20Herencia%2C%20polimorfismo%20y%20clases%20abstractas_2026/#27-herencia-multiple","title":"2.7 Herencia m\u00faltiple","text":"<p>En determinados casos podr\u00edas considerar la posibilidad de que se necesite heredar de m\u00e1s de una clase, para as\u00ed disponer de los miembros de dos (o m\u00e1s) clases disjuntas (que no derivan una de la otra). La herencia m\u00faltiple permite hacer eso: recoger las distintas caracter\u00edsticas (atributos y m\u00e9todos) de clases diferentes formando una nueva clase derivada de varias clases base.</p> <p>El problema en estos casos es la posibilidad que existe de que se produzcan ambig\u00fcedades, as\u00ed, si tuvi\u00e9ramos miembros con el mismo identificador en clases base diferentes, en tal caso, \u00bfqu\u00e9 miembro se hereda? Para evitar esto, los compiladores suelen solicitar que ante casos de ambig\u00fcedad, se especifique de manera expl\u00edcita la clase de la cual se quiere utilizar un determinado miembro que pueda ser ambiguo.</p> <p>Ahora bien, la posibilidad de herencia m\u00faltiple no est\u00e1 disponible en todos los lenguajes orientados a objetos, \u00bflo estar\u00e1 en Java? La respuesta es negativa.</p> <p>Comparaci\u00f3n entre lenguajes: Herencia m\u00faltiple</p> JavaPythonKotlin <pre><code>// No permitido\n// class Coche extends Vehiculo, Motor { } \n// Se usan interfaces para simular herencia m\u00faltiple\n</code></pre> <pre><code># Permitido\nclass Coche(Vehiculo, Motor):\n    pass\n</code></pre> <pre><code>// No permitido directamente\n// class Coche : Vehiculo(), Motor()\n// Se usan interfaces para simular herencia m\u00faltiple\n</code></pre>"},{"location":"Unidad%206%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Avanzada%29/Unidad%206%20POO.%20Uso%20avanzado%20de%20clases%20-%20Herencia%2C%20polimorfismo%20y%20clases%20abstractas_2026/#3-clases-abstractas","title":"3. Clases abstractas","text":"<p>En determinadas ocasiones, es posible que necesites definir una clase que represente un concepto lo suficientemente abstracto como para que nunca vayan a existir instancias de ella (objetos). \u00bfTendr\u00eda eso sentido? \u00bfQu\u00e9 utilidad podr\u00eda tener?</p> <p>Imagina una aplicaci\u00f3n para un centro educativo que utilice las clases de ejemplo <code>Alumno</code> y <code>Profesor</code>, ambas subclases de Persona. Es m\u00e1s que probable que esa aplicaci\u00f3n nunca llegue a necesitar objetos de la clase <code>Persona</code>, pues ser\u00edan demasiado gen\u00e9ricos como para poder ser utilizados (no contendr\u00edan suficiente informaci\u00f3n espec\u00edfica). Podr\u00edas llegar entonces a la conclusi\u00f3n de que la clase Persona ha resultado de utilidad como clase base para construir otras clases que hereden de ella, pero no como una clase instanciable de la cual vayan a existir objetos. A este tipo de clases se les llama clases abstractas.</p> <p>\ud83d\udce2En algunos casos puede resultar \u00fatil disponer de clases que nunca ser\u00e1n instanciadas, sino que proporcionan un marco o modelo a seguir por sus clases derivadas dentro de una jerarqu\u00eda de herencia. Son las clases abstractas.</p> <p>La posibilidad de declarar clases abstractas es una de las caracter\u00edsticas m\u00e1s \u00fatiles de los lenguajes orientados a objetos, pues permiten dar unas l\u00edneas generales de c\u00f3mo es una clase sin tener que implementar todos sus m\u00e9todos o implementando solamente algunos de ellos. Esto resulta especialmente \u00fatil cuando las distintas clases derivadas deban proporcionar los mismos m\u00e9todos indicados en la clase base abstracta, pero su implementaci\u00f3n sea espec\u00edfica para cada subclase.</p> <p>Imagina que est\u00e1s trabajando en un entorno de manipulaci\u00f3n de objetos gr\u00e1ficos y necesitas trabajar con l\u00edneas, c\u00edrculos, rect\u00e1ngulos, etc. Estos objetos tendr\u00e1n en com\u00fan algunos atributos que representen su estado (ubicaci\u00f3n, color del contorno, color de relleno, etc.) y algunos m\u00e9todos que modelen su comportamiento (dibujar, rellenar con un color, escalar, desplazar, rotar, etc.). Algunos de ellos ser\u00e1n comunes para todos ellos (por ejemplo la ubicaci\u00f3n o el desplazamiento) y sin embargo otros (como por ejemplo dibujar) necesitar\u00e1n una implementaci\u00f3n espec\u00edfica dependiendo del tipo de objeto.</p> <p>Pero, en cualquier caso, todos ellos necesitan esos m\u00e9todos (tanto un c\u00edrculo como un rect\u00e1ngulo necesitan el m\u00e9todo dibujar, aunque se lleven a cabo de manera diferente). En este caso resultar\u00eda muy \u00fatil disponer de una clase abstracta objeto gr\u00e1fico donde se definir\u00edan las l\u00edneas generales (algunos atributos concretos comunes, algunos m\u00e9todos concretos comunes implementados y algunos m\u00e9todos gen\u00e9ricos comunes sin implementar) de un objeto gr\u00e1fico y m\u00e1s adelante, seg\u00fan se vayan definiendo clases especializadas (l\u00edneas, c\u00edrculos, rect\u00e1ngulos), se ir\u00e1n concretando en cada subclase aquellos m\u00e9todos que se dejaron sin implementar en la clase abstracta.</p>"},{"location":"Unidad%206%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Avanzada%29/Unidad%206%20POO.%20Uso%20avanzado%20de%20clases%20-%20Herencia%2C%20polimorfismo%20y%20clases%20abstractas_2026/#31-declaracion-de-una-clase-abstracta","title":"3.1. Declaraci\u00f3n de una clase abstracta","text":"<p>Ya has visto que una clase abstracta es una clase que no se puede instanciar, es decir, que no se pueden crear objetos a partir de ella. La idea es permitir que otras clases deriven de ella, proporcionando un modelo gen\u00e9rico y algunos m\u00e9todos de utilidad general.</p> <p>Las clases abstractas se declaran mediante el modificador <code>abstract</code>:</p> Java <pre><code>[modificador_acceso] abstract class nombreClase  [herencia] [interfaces] {\n\n}\n</code></pre> <p>Una clase puede contener en su interior m\u00e9todos declarados como <code>abstract</code> (m\u00e9todos para los cuales s\u00f3lo se indica la cabecera, pero no se proporciona su implementaci\u00f3n). En tal caso, la clase tendr\u00e1 que ser necesariamente tambi\u00e9n <code>abstract</code>. Esos m\u00e9todos tendr\u00e1n que ser posteriormente implementados en sus clases derivadas.</p> <p>Por otro lado, una clase tambi\u00e9n puede contener m\u00e9todos totalmente implementados (no abstractos), los cuales ser\u00e1n heredados por sus clases derivadas y podr\u00e1n ser utilizados sin necesidad de definirlos (pues ya est\u00e1n implementados).</p> <p>Cuando trabajes con clases abstractas debes tener en cuenta:</p> <ul> <li>Una clase abstracta s\u00f3lo puede usarse para crear nuevas clases derivadas. No se puede hacer un new de una clase abstracta. Se producir\u00eda un error de compilaci\u00f3n.</li> <li>Una clase abstracta puede contener m\u00e9todos totalmente definidos (no abstractos) y m\u00e9todos sin definir (m\u00e9todos abstractos).</li> </ul>"},{"location":"Unidad%206%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Avanzada%29/Unidad%206%20POO.%20Uso%20avanzado%20de%20clases%20-%20Herencia%2C%20polimorfismo%20y%20clases%20abstractas_2026/#ejercicio-8","title":"Ejercicio 8","text":"<p>Bas\u00e1ndote en la jerarqu\u00eda de clases de ejemplo (<code>Persona</code>, <code>Alumno</code>, <code>Profesor</code>), que ya has utilizado en otras ocasiones, modifica lo que consideres oportuno para que <code>Persona</code> sea, a partir de ahora, una clase abstracta (no instanciable) y las otras dos clases sigan siendo clases derivadas de ella, pero s\u00ed instanciables.</p> <p>Clases abstractas</p> JavaPythonKotlin <pre><code>java public abstract class Persona { // ... }\n</code></pre> <pre><code>from abc import ABC, abstractmethod\nclass Persona(ABC):\n@abstractmethod\ndef mostrar(self):\n    pass\n</code></pre> <pre><code>abstract class Persona {\n    abstract fun mostrar()\n    }\n</code></pre>"},{"location":"Unidad%206%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Avanzada%29/Unidad%206%20POO.%20Uso%20avanzado%20de%20clases%20-%20Herencia%2C%20polimorfismo%20y%20clases%20abstractas_2026/#32-metodos-abstractos","title":"3.2. M\u00e9todos abstractos","text":"<p>Un m\u00e9todo abstracto es un m\u00e9todo cuya implementaci\u00f3n no se define, sino que se declara \u00fanicamente su interfaz (cabecera) para que su cuerpo sea implementado m\u00e1s adelante en una clase derivada.</p> <p></p> <p>Un m\u00e9todo se declara como abstracto mediante el uso del modificador abstract (como en las clases abstractas):</p> <pre><code>[modificador_acceso] abstract  &lt;tipo&gt; &lt;nombreMetodo&gt; ([par\u00e1metros]) [excepciones]; \n</code></pre> <p>Estos m\u00e9todos tendr\u00e1n que ser obligatoriamente redefinidos (en realidad \u201cdefinidos\u201d, pues a\u00fan no tienen contenido) en las clases derivadas. Si en una clase derivada se deja alg\u00fan m\u00e9todo abstracto sin implementar, esa clase derivada ser\u00e1 tambi\u00e9n una clase abstracta.</p> <p>\ud83d\udce3 Cuando una clase contiene un m\u00e9todo abstracto tiene que declararse como abstracta obligatoriamente</p> <p>Imagina que tienes una clase Empleado gen\u00e9rica para diversos tipos de empleado y tres clases derivadas: EmpleadoFijo (tiene un salario fijo m\u00e1s ciertos complementos), EmpleadoTemporal (salario fijo m\u00e1s otros complementos diferentes) y EmpleadoComercial (una parte de salario fijo y unas comisiones por cada operaci\u00f3n). La clase Empleado podr\u00eda contener un m\u00e9todo abstracto calcularNomina, pues sabes que ese m\u00e9todo ser\u00e1 necesario para cualquier tipo de empleado (todo empleado cobra una n\u00f3mina). Sin embargo el c\u00e1lculo en s\u00ed de la n\u00f3mina ser\u00e1 diferente si se trata de un empleado fijo, un empleado temporal o un empleado comercial, y ser\u00e1 dentro de las clases especializadas de Empleado (EmpleadoFijo\u00b8 EmpleadoTemporal, EmpleadoComercial) donde se implementen de manera espec\u00edfica el c\u00e1lculo de las mismas.</p> <p>Debes tener en cuenta al trabajar con m\u00e9todos abstractos:</p> <ul> <li>Un m\u00e9todo abstracto implica que la clase a la que pertenece tiene que ser abstracta, pero eso no significa que todos los m\u00e9todos de esa clase tengan que ser abstractos.</li> <li>Un m\u00e9todo abstracto no puede ser privado (no se podr\u00eda implementar, dado que las clases derivadas no tendr\u00edan acceso a \u00e9l).</li> <li>Los m\u00e9todos abstractos no pueden ser est\u00e1ticos, pues los m\u00e9todos est\u00e1ticos no pueden ser redefinidos (y los m\u00e9todos abstractos necesitan ser redefinidos).</li> </ul>"},{"location":"Unidad%206%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Avanzada%29/Unidad%206%20POO.%20Uso%20avanzado%20de%20clases%20-%20Herencia%2C%20polimorfismo%20y%20clases%20abstractas_2026/#ejercicio-9","title":"Ejercicio 9","text":"<p>Bas\u00e1ndote en la jerarqu\u00eda de clases <code>Persona</code>, <code>Alumno</code>, <code>Profesor</code>, crea un m\u00e9todo abstracto llamado mostrar para la clase <code>Persona</code>. Dependiendo del tipo de persona (alumno o profesor) el m\u00e9todo mostrar tendr\u00e1 que mostrar unos u otros datos personales (habr\u00e1 que hacer implementaciones espec\u00edficas en cada clase derivada).</p> <p>Una vez hecho esto, implementa completamente las tres clases (con todos sus atributos y m\u00e9todos) y util\u00edzalas en un peque\u00f1o programa de ejemplo que cree un objeto de tipo <code>Alumno</code> y otro de tipo <code>Profesor</code>, los rellene con informaci\u00f3n y muestre esa informaci\u00f3n en la pantalla a trav\u00e9s del m\u00e9todo <code>mostrar</code>.</p>"},{"location":"Unidad%206%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Avanzada%29/Unidad%206%20POO.%20Uso%20avanzado%20de%20clases%20-%20Herencia%2C%20polimorfismo%20y%20clases%20abstractas_2026/#33-clases-y-metodos-finales","title":"3.3. Clases y m\u00e9todos finales","text":"<p>En unidades anteriores has visto el modificador <code>final</code>, aunque s\u00f3lo lo has utilizado por ahora para atributos y variables (por ejemplo para declarar atributos constantes, que una vez que toman un valor ya no pueden ser modificados). Pero este modificador tambi\u00e9n puede ser utilizado con clases y con m\u00e9todos (con un comportamiento que no es exactamente igual, aunque puede encontrarse cierta analog\u00eda: no se permite heredar o no se permite redefinir).</p> <p>Una clase declarada como <code>final</code> no puede ser heredada, es decir, no puede tener clases derivadas. La jerarqu\u00eda de clases a la que pertenece acaba en ella (no tendr\u00e1 clases hijas):</p> <pre><code>[modificador_acceso] final class nombreClase  [herencia] [interfaces]\n</code></pre> <p>Un m\u00e9todo tambi\u00e9n puede ser declarado como final, en tal caso, ese m\u00e9todo no podr\u00e1 ser redefinido en una clase derivada:</p> <pre><code>[modificador_acceso] final &lt;tipo&gt; &lt;nombreMetodo&gt; ([par\u00e1metros]) [excepciones]\n</code></pre> <p>\ud83d\udce3 Si intentas redefinir un m\u00e9todo <code>final</code> en una subclase se producir\u00e1 un error de compilaci\u00f3n.</p> <p>Adem\u00e1s de en la declaraci\u00f3n de atributos, clases y m\u00e9todos, el modificador <code>final</code> tambi\u00e9n podr\u00eda aparecer acompa\u00f1ando a un m\u00e9todo de un par\u00e1metro. En tal caso no se podr\u00e1 modificar el valor del par\u00e1metro dentro del c\u00f3digo del m\u00e9todo. Por ejemplo: <code>public final metodoEscribir (int par1, final int par2)</code>.</p> <p>Debes conocer</p> <p>Dada la gran cantidad de contextos diferentes en los que se puede encontrar el modificador <code>final</code>, vale la pena que hagas un repaso de todos los lugares donde puede aparecer y cu\u00e1l ser\u00eda su funci\u00f3n en cada uno.</p> <p>Comparaci\u00f3n entre lenguajes: Clases y m\u00e9todos finales/no heredables</p> JavaPythonKotlin <pre><code>public final class ClaseFinal { } public final void metodoFinal() { }\n</code></pre> <pre><code>No hay equivalente directo para clases\n    # Se puede usar convenciones o decoradores personalizados\n</code></pre> <pre><code>final class ClaseFinal { }\n// En Kotlin los m\u00e9todos son final por defecto\n// Para permitir sobrescritura se usa 'open'\nopen fun metodoSobrescribible() { }\n</code></pre>"},{"location":"Unidad%206%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Avanzada%29/Unidad%206%20POO.%20Uso%20avanzado%20de%20clases%20-%20Herencia%2C%20polimorfismo%20y%20clases%20abstractas_2026/#4-interfaces","title":"4. Interfaces","text":"<p>Has visto c\u00f3mo la herencia permite definir especializaciones (o extensiones) de una clase base que ya existe sin tener que volver a repetir de todo el c\u00f3digo de \u00e9sta. Este mecanismo da la oportunidad de que la nueva clase especializada (o extendida) disponga de toda la interfaz que tiene su clase base.</p> <p>Tambi\u00e9n has estudiado c\u00f3mo los m\u00e9todos abstractos permiten establecer una interfaz para marcar las l\u00edneas generales de un comportamiento com\u00fan de superclase que deber\u00edan compartir de todas las subclases.</p> <p></p> <p>Si llevamos al l\u00edmente esta idea de interfaz, podr\u00edas llegar a tener una clase abstracta donde todos sus m\u00e9todos fueran abstractos. De este modo estar\u00edas dando \u00fanicamente el marco de comportamiento, sin ning\u00fan m\u00e9todo implementado, de las posibles subclases que heredar\u00e1n de esa clase abstracta. La idea de una interfaz (o interface) es precisamente \u00e9sa: disponer de un mecanismo que permita especificar cu\u00e1l debe ser el comportamiento que deben tener todos los objetos que formen parte de una determinada clasificaci\u00f3n (no necesariamente jer\u00e1rquica).</p> <p>Una interfaz consiste principalmente en una lista de declaraciones de m\u00e9todos sin implementar, que caracterizan un determinado comportamiento. Si se desea que una clase tenga ese comportamiento, tendr\u00e1 que implementar esos m\u00e9todos establecidos en la interfaz. En este caso no se trata de una relaci\u00f3n de herencia (la clase A es una especializaci\u00f3n de la clase B, o la subclase A es del tipo de la superclase B), sino m\u00e1s bien una relaci\u00f3n \"de implementaci\u00f3n de comportamientos\" (la clase A implementa los m\u00e9todos establecidos en la interfaz B, o los comportamientos indicados por B son llevados a cabo por A; pero no que A sea de clase B).</p> <p>Imagina que est\u00e1s dise\u00f1ando una aplicaci\u00f3n que trabaja con clases que representan distintos tipos de animales. Algunas de las acciones que quieres que lleven a cabo est\u00e1n relacionadas con el hecho de que algunos animales sean depredadores (por ejemplo: observar una presa , perseguirla , com\u00e9rsela , etc.) o sean presas ( observar , huir , esconderse , etc.). Si creas la clase Le\u00f3n , esta clase podr\u00eda implementar una interfaz Depredador , mientras que otras clases como Gacela implementar\u00edan las acciones de la interfaz Presa . Por otro lado, podr\u00edas tener tambi\u00e9n el caso de la clase Rana , que implementar\u00eda las acciones de la interfaz Depredador (pues es cazador de peque\u00f1os insectos), pero tambi\u00e9n la de Presa (pues puede ser cazado y necesita las acciones necesarias para protegerse).</p> <p></p>"},{"location":"Unidad%206%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Avanzada%29/Unidad%206%20POO.%20Uso%20avanzado%20de%20clases%20-%20Herencia%2C%20polimorfismo%20y%20clases%20abstractas_2026/#41-concepto-de-interfaz","title":"4.1 Concepto de interfaz","text":"<p>Una interfaz en Java consiste esencialmente en una lista de declaraciones de m\u00e9todos sin implementar, junto con un conjunto de constantes.</p> <p>Estos m\u00e9todos sin implementar indican un comportamiento, un tipo de conducta, aunque no especifican c\u00f3mo ser\u00e1 ese comportamiento (implementaci\u00f3n), pues eso depender\u00e1 de las caracter\u00edsticas espec\u00edficas de cada clase que decida implementar esa interfaz. Podr\u00eda decirse que una interfaz se encarga de establecer qu\u00e9 comportamientos hay que tener (qu\u00e9 m\u00e9todos), pero no dice nada de c\u00f3mo deben llevarse a cabo esos comportamientos (implementaci\u00f3n). Se indica s\u00f3lo la forma, no la implementaci\u00f3n.</p> <p></p> <p>En cierto modo podr\u00edas imaginar el concepto de interfaz como un gui\u00f3n que dice: \"\u00e9ste es el protocolo de comunicaci\u00f3n que deben presentar todas las clases que implementen esta interfaz\". Se proporciona una lista de m\u00e9todos p\u00fablicos y, si quieres dotar a tu clase de esa interfaz, tendr\u00e1s que definir todos y cada uno de esos m\u00e9todos p\u00fablicos.</p> <p>En conclusi\u00f3n: una interfaz se encarga de establecer unas l\u00edneas generales sobre los comportamientos (m\u00e9todos) que deber\u00edan tener los objetos de toda clase que implemente esa interfaz, es decir, que no indican lo que el objeto es (de eso se encarga la clase y sus superclases), sino acciones (capacidades) que el objeto deber\u00eda ser capaz de realizar. Es por esto que el nombre de muchas interfaces en Java termina con sufijos del tipo \"-able\", \"-or\", \"-ente\" y cosas del estilo, que significan algo as\u00ed como capacidad o habilidad para hacer o ser receptores de algo (configurable, serializable, modificable, clonable, ejecutable, administrador, servidor, buscador, etc.), dando as\u00ed la idea de que se tiene la capacidad de llevar a cabo el conjunto de acciones especificadas en la interfaz.</p> <p>Imag\u00ednate por ejemplo la clase Coche, subclase de Veh\u00edculo. Los coches son veh\u00edculos a motor, lo cual implica una serie de acciones como, por ejemplo, arrancar el motor o detener el motor. Esa acci\u00f3n no la puedes heredar de Veh\u00edculo, pues no todos los veh\u00edculos tienen porqu\u00e9 ser a motor (piensa por ejemplo en una clase Bicicleta o un coche el\u00e9ctrico), y no puedes heredar de otra clase pues ya heredas de Veh\u00edculo. Una soluci\u00f3n podr\u00eda ser crear una interfaz Arrancable, que proporcione los m\u00e9todos t\u00edpicos de un objeto a motor (no necesariamente veh\u00edculos). De este modo la clase Coche sigue siendo subclase de Veh\u00edculo, pero tambi\u00e9n implementar\u00eda los comportamientos de la interfaz Arrancable, los cuales podr\u00edan ser tambi\u00e9n implementados por otras clases, hereden o no de Veh\u00edculo (por ejemplo una clase Motocicleta o bien una clase Motosierra). La clase Coche implementar\u00e1 su m\u00e9todo arrancar de una manera, la clase Motocicleta lo har\u00e1 de otra (aunque bastante parecida) y la clase Motosierra de otra forma probablemente muy diferente, pero todos tendr\u00e1n su propia versi\u00f3n del m\u00e9todo arrancar como parte de la interfaz Arrancable.</p> <p>Seg\u00fan esta concepci\u00f3n, podr\u00edas hacerte la siguiente pregunta: \u00bfpodr\u00e1 una clase implementar varias interfaces? La respuesta en este caso s\u00ed es afirmativa.</p> <p>\ud83d\udce3 Una clase puede adoptar distintos modelos de comportamiento establecidos en diferentes interfaces. Es decir una clase puede implementar varias interfaces.</p>"},{"location":"Unidad%206%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Avanzada%29/Unidad%206%20POO.%20Uso%20avanzado%20de%20clases%20-%20Herencia%2C%20polimorfismo%20y%20clases%20abstractas_2026/#411-clase-abstracta-o-interfaz","title":"4.1.1 \u00bfClase abstracta o interfaz?","text":"<p>Observando el concepto de interfaz que se acaba de proponer, podr\u00eda caerse en la tentaci\u00f3n de pensar que es pr\u00e1cticamente lo mismo que una clase abstracta en la que todos sus m\u00e9todos sean abstractos.</p> <p>Es cierto que en ese sentido existe un gran parecido formal entre una clase abstracta y una interfaz, pudi\u00e9ndose en ocasiones utilizar indistintamente una u otra para obtener un mismo fin. Pero, a pesar de ese gran parecido, existen algunas diferencias, no s\u00f3lo formales, sino tambi\u00e9n conceptuales, muy importantes:</p> <ul> <li>Una clase no puede heredar de varias clases, aunque sean abstractas (herencia m\u00faltiple). Sin embargo s\u00ed puede implementar una o varias interfaces y adem\u00e1s seguir heredando de una clase.</li> <li>Una interfaz no puede definir m\u00e9todos (no implementa su contenido), tan solo los declara o enumera.</li> <li>Una interfaz puede hacer que dos clases tengan un mismo comportamiento independientemente de sus ubicaciones en una determinada jerarqu\u00eda de clases (no tienen que heredar las dos de una misma superclase, pues no siempre es posible seg\u00fan la naturaleza y propiedades de cada clase).</li> <li>Una interfaz permite establecer un comportamiento de clase sin apenas dar detalles, pues esos detalles a\u00fan no son conocidos (depender\u00e1n del modo en que cada clase decida implementar la interfaz).</li> <li>Las interfaces tienen su propia jerarqu\u00eda, diferente e independiente de la jerarqu\u00eda de clases.</li> </ul> <p>De todo esto puede deducirse que una clase abstracta proporciona una interfaz disponible s\u00f3lo a trav\u00e9s de la herencia. S\u00f3lo quien herede de esa clase abstracta dispondr\u00e1 de esa interfaz. Si una clase no pertenece a esa misma jerarqu\u00eda (no hereda de ella) no podr\u00e1 tener esa interfaz. Eso significa que para poder disponer de la interfaz podr\u00edas:</p> <p></p> <ol> <li>Volver a escribirla para esa jerarqu\u00eda de clases. Lo cual no parece una buena soluci\u00f3n.</li> <li>Hacer que la clase herede de la superclase que proporciona la interfaz que te interesa, sac\u00e1ndola de su jerarqu\u00eda original y convirti\u00e9ndola en clase derivada de algo de lo que conceptualmente no deber\u00eda ser una subclase. Es decir, estar\u00edas forzando una relaci\u00f3n \"es un\" cuando en realidad lo m\u00e1s probable es que esa relaci\u00f3n no exista. Tampoco parece la mejor forma de resolver el problema.</li> </ol> <p>Sin embargo, una interfaz s\u00ed puede ser implementada por cualquier clase, permitiendo que clases que no tengan ninguna relaci\u00f3n entre s\u00ed (pertenecen a distintas jerarqu\u00edas) puedan compartir un determinado comportamiento (una interfaz) sin tener que forzar una relaci\u00f3n de herencia que no existe entre ellas.</p> <p>A partir de ahora podemos hablar de otra posible relaci\u00f3n entre clases: la de compartir un determinado comportamiento (interfaz) . Dos clases podr\u00edan tener en com\u00fan un determinado conjunto de comportamientos sin que necesariamente exista una relaci\u00f3n jer\u00e1rquica entre ellas. Tan solo cuando haya realmente una relaci\u00f3n de tipo \" es un \" se producir\u00e1 herencia .</p>"},{"location":"Unidad%206%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Avanzada%29/Unidad%206%20POO.%20Uso%20avanzado%20de%20clases%20-%20Herencia%2C%20polimorfismo%20y%20clases%20abstractas_2026/#recomendacion","title":"Recomendaci\u00f3n","text":"<p>Si s\u00f3lo vas a proporcionar una lista de m\u00e9todos abstractos (interfaz), sin definiciones de m\u00e9todos ni atributos de objeto, suele ser recomendable definir una interfaz antes que clase abstracta. Es m\u00e1s, cuando vayas a definir una supuesta clase base, puedes comenzar declar\u00e1ndola como interfaz y s\u00f3lo cuando veas que necesitas definir m\u00e9todos o variables miembro, puedes entonces convertirla en clase abstracta (no instanciable) o incluso en una clase instanciable.</p> <p>Comparaci\u00f3n entre lenguajes: Interfaces</p> JavaPythonKotlin <pre><code>public interface Depredador { \nvoid cazar(); \n}\n</code></pre> <pre><code>from abc import ABC, abstractmethod\nclass Depredador(ABC):\n@abstractmethod\ndef cazar(self):\n    pass\n</code></pre> <pre><code>interface Depredador {\n    fun cazar()\n}\n</code></pre> <p>4.2 Definici\u00f3n de interfaces</p> <p>La declaraci\u00f3n de una interfaz en Java es similar a la declaraci\u00f3n de una clase, aunque con algunas variaciones:</p> <ul> <li>Se utiliza la palabra reservada <code>interface</code> en lugar de <code>class</code>.</li> <li>Puede utilizarse el modificador <code>public</code>. Si incluye este modificador la interfaz debe tener el mismo nombre que el archivo .java en el que se encuentra (exactamente igual que suced\u00eda con las clases). Si no se indica el modificador <code>public</code>, el acceso ser\u00e1 por omisi\u00f3n o \"de paquete\" (como suced\u00eda con las clases).</li> <li>Todos los miembros de la interfaz (atributos y m\u00e9todos) son <code>public</code> de manera impl\u00edcita. No es necesario indicar el modificador <code>public</code>, aunque puede hacerse.</li> <li>Todos los atributos son de tipo <code>final</code> y <code>public</code> (tampoco es necesario especificarlo), es decir, constantes y p\u00fablicos. Hay que darles un valor inicial.</li> <li>Todos los m\u00e9todos son abstractos tambi\u00e9n de manera impl\u00edcita (tampoco hay que indicarlo). No tienen cuerpo, tan solo la cabecera.</li> </ul> <p>Como puedes observar, una interfaz consiste esencialmente en una lista de atributos finales (constantes) y m\u00e9todos abstractos (sin implementar). Su sintaxis quedar\u00eda entonces:</p> <pre><code>[public] interface &lt;NombreInterfaz&gt; {\n                [public] [final] &lt;tipo1&gt; &lt;atributo1&gt;= &lt;valor1&gt;;\n                [public] [final] &lt;tipo2&gt; &lt;atributo2&gt;= &lt;valor2&gt;;\n                ...\n                [public] [abstract] &lt;tipo_devuelto1&gt;  &lt;nombreMetodo1&gt; ([lista_par\u00e1metros]);\n                [public] [abstract] &lt;tipo_devuelto2&gt;  &lt;nombreMetodo2&gt; ([lista_par\u00e1metros]);\n                ...          \n}\n</code></pre> <p>Si te fijas, la declaraci\u00f3n de los m\u00e9todos termina en punto y coma, pues no tienen cuerpo, al igual que sucede con los m\u00e9todos abstractos de las clases abstractas.</p> <p>El ejemplo de la interfaz Depredador que hemos visto antes podr\u00eda quedar entonces as\u00ed:</p> <pre><code>public interface Depredador {\n    void localizar(Animal presa);\n    void cazar(Animal presa);\n    ...\n} \n</code></pre> <p></p> <p>Ser\u00e1n las clases que implementen esta interfaz (Le\u00f3n, Leopardo, Cocodrilo, Rana, Lagarto, Hombre, etc.) las que definan cada uno de los m\u00e9todos por dentro.</p>"},{"location":"Unidad%206%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Avanzada%29/Unidad%206%20POO.%20Uso%20avanzado%20de%20clases%20-%20Herencia%2C%20polimorfismo%20y%20clases%20abstractas_2026/#ejercicio-10","title":"Ejercicio 10","text":"<p>Crea una interfaz en Java cuyo nombre sea Imprimible y que contenga algunos m\u00e9todos \u00fatiles para mostrar el contenido de una clase:</p> <ol> <li>M\u00e9todo devolverContenidoString, que crea un <code>String</code> con una representaci\u00f3n de todo el contenido p\u00fablico (o que se decida que deba ser mostrado) del objeto y lo devuelve. El formato ser\u00e1 una lista de pares \"nombre=valor\" de cada atributo separado por comas y la lista completa encerrada entre llaves: \"{=, ..., =}\". <li>M\u00e9todo devolverContenidoArrayList, que crea un <code>ArrayList</code> de <code>String</code> con una representaci\u00f3n de todo el contenido p\u00fablico (o que se decida que deba ser mostrado) del objeto y lo devuelve.</li> <li>M\u00e9todo devolverContenidoHashtable, similar al anterior, pero en lugar devolver en un <code>ArrayList</code> los valores de los atributos, se devuelve en una <code>Hashtable</code> en forma de pares (nombre, valor).</li>"},{"location":"Unidad%206%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Avanzada%29/Unidad%206%20POO.%20Uso%20avanzado%20de%20clases%20-%20Herencia%2C%20polimorfismo%20y%20clases%20abstractas_2026/#43-implementacion-de-interfaces","title":"4.3 Implementaci\u00f3n de interfaces","text":"<p>Como ya has visto, todas las clases que implementan una determinada interfaz est\u00e1n obligadas a proporcionar una definici\u00f3n (implementaci\u00f3n) de los m\u00e9todos de esa interfaz, adoptando el modelo de comportamiento propuesto por \u00e9sta.</p> <p>Dada una interfaz, cualquier clase puede especificar dicha interfaz mediante el mecanismo denominado implementaci\u00f3n de interfaces. Para ello se utiliza la palabra reservada <code>implements</code>:</p> <pre><code>class NombreClase implements NombreInterfaz {\n</code></pre> <p>De esta manera, la clase est\u00e1 diciendo algo as\u00ed como \"la interfaz indica los m\u00e9todos que debo implementar, pero voy a ser yo (la clase) quien los implemente\".</p> <p>Es posible indicar varios nombres de interfaces separ\u00e1ndolos por comas:</p> <pre><code>class NombreClase implements NombreInterfaz1, NombreInterfaz2,... {\n</code></pre> <p>Cuando una clase implementa una interfaz, tiene que redefinir sus m\u00e9todos nuevamente con acceso p\u00fablico. Con otro tipo de acceso se producir\u00e1 un error de compilaci\u00f3n. Es decir, que del mismo modo que no se pod\u00edan restringir permisos de acceso en la herencia de clases, tampoco se puede hacer en la implementaci\u00f3n de interfaces.</p> <p>Una vez implementada una interfaz en una clase, los m\u00e9todos de esa interfaz tienen exactamente el mismo tratamiento que cualquier otro m\u00e9todo, sin ninguna diferencia, pudiendo ser invocados, heredados, redefinidos, etc.</p> <p>En el ejemplo de los depredadores, al definir la clase Le\u00f3n, habr\u00eda que indicar que implementa la interfaz Depredador:</p> <pre><code>class Leon implements Depredador {\n</code></pre> <p>Y en su interior habr\u00eda que implementar aquellos m\u00e9todos que contenga la interfaz:</p> <pre><code>// Implementaci\u00f3n del m\u00e9todo localizar para un le\u00f3n\nvoid localizar(Animal presa) { \n    ...\n} \n</code></pre> <p>En el caso de clases que pudieran ser a la vez Depredador y Presa, tendr\u00edan que implementar ambas interfaces, como podr\u00eda suceder con la clase Rana:</p> <pre><code>class Rana implements Depredador, Presa {\n</code></pre> <p>Y en su interior habr\u00eda que implementar aquellos m\u00e9todos que contengan ambas interfaces , tanto las de Depredador ( localizar , cazar , etc.) como las de Presa ( observar , huir , etc.).</p> <p>Ejercicio 11</p> <p>Haz que las clases <code>Alumno</code> y <code>Profesor</code> implementen la interfaz <code>Imprimible</code> que se ha escrito en el ejercicio anterior.</p> <p>Comparaci\u00f3n entre lenguajes: Implementaci\u00f3n de interfaces</p> JavaPythonKotlin <pre><code>class Leon implements Depredador { \n    public void localizar(Animal presa) { } \n}\n</code></pre> <pre><code>class Leon(Depredador):\n    def localizar(self, presa):\n        pass\n</code></pre> <pre><code>class Leon : Depredador {\n    override fun localizar(presa: Animal) { }\n}\n</code></pre>"},{"location":"Unidad%206%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Avanzada%29/Unidad%206%20POO.%20Uso%20avanzado%20de%20clases%20-%20Herencia%2C%20polimorfismo%20y%20clases%20abstractas_2026/#44-simulacion-de-la-herencia-multiple-mediante-el-uso-de-interfaces","title":"4.4 Simulaci\u00f3n de la herencia m\u00faltiple mediante el uso de interfaces","text":"<p>Una interfaz no tiene espacio de almacenamiento asociado (no se van a declarar objetos de un tipo de interfaz), es decir, no tiene implementaci\u00f3n.</p> <p>En algunas ocasiones es posible que interese representar la situaci\u00f3n de que \"una clase X es de tipo A, de tipo B, y de tipo C\", siendo A, B, C clases disjuntas (no heredan unas de otras). Hemos visto que ser\u00eda un caso de herencia m\u00faltiple que Java no permite.</p> <p>Para poder simular algo as\u00ed, podr\u00edas definir tres interfaces A, B, C que indiquen los comportamientos (m\u00e9todos) que se deber\u00edan tener seg\u00fan se pertenezca a una supuesta clase A, B, o C, pero sin implementar ning\u00fan m\u00e9todo concreto ni atributos de objeto (s\u00f3lo interfaz).</p> <p></p> <p>De esta manera la clase X podr\u00eda a la vez:</p> <ol> <li>Implementar las interfaces A, B, C, que la dotar\u00edan de los comportamientos que deseaba heredar de las clases A, B, C.</li> <li>Heredar de otra clase Y, que le proporcionar\u00eda determinadas caracter\u00edsticas dentro de su taxonom\u00eda o jerarqu\u00eda de objeto (atributos, m\u00e9todos implementados y m\u00e9todos abstractos).</li> </ol> <p>En el ejemplo que hemos visto de las interfaces Depredador y Presa, tendr\u00edas un ejemplo de esto: la clase Rana, que es subclase de Anfibio, implementa una serie de comportamientos propios de un Depredador y, a la vez, otros m\u00e1s propios de una Presa. Esos comportamientos (m\u00e9todos) no forman parte de la superclase Anfibio, sino de las interfaces. Si se decide que la clase Rana debe de llevar a cabo algunos otros comportamientos adicionales, podr\u00edan a\u00f1adirse a una nueva interfaz y la clase Rana implementar\u00eda una tercera interfaz.</p> <p>De este modo, con el mecanismo \"una herencia pero varias interfaces\", podr\u00edan conseguirse resultados similares a los obtenidos con la herencia m\u00faltiple.</p> <p>Ahora bien, del mismo modo que suced\u00eda con la herencia m\u00faltiple, puede darse el problema de la colisi\u00f3n de nombres al implementar dos interfaces que tengan un m\u00e9todo con el mismo identificador. En tal caso puede suceder lo siguiente:</p> <ul> <li>Si los dos m\u00e9todos tienen diferentes par\u00e1metros no habr\u00e1 problema aunque tengan el mismo nombre pues se realiza una sobrecarga de m\u00e9todos.</li> <li>Si los dos m\u00e9todos tienen un valor de retorno de un tipo diferente, se producir\u00e1 un error de compilaci\u00f3n (al igual que sucede en la sobrecarga cuando la \u00fanica diferencia entre dos m\u00e9todos es \u00e9sa).</li> </ul> <p>Si los dos m\u00e9todos son exactamente iguales en identificador, par\u00e1metros y tipo devuelto , entonces solamente se podr\u00e1 implementar uno de los dos m\u00e9todos . En realidad se trata de un solo m\u00e9todo pues ambos tienen la misma interfaz (mismo identificador, mismos par\u00e1metros y mismo tipo devuelto).</p>"},{"location":"Unidad%206%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Avanzada%29/Unidad%206%20POO.%20Uso%20avanzado%20de%20clases%20-%20Herencia%2C%20polimorfismo%20y%20clases%20abstractas_2026/#recomendacion_1","title":"Recomendaci\u00f3n","text":"<p>La utilizaci\u00f3n de nombres id\u00e9nticos en diferentes interfaces que pueden ser implementadas a la vez por una misma clase puede causar, adem\u00e1s del problema de la colisi\u00f3n de nombres, dificultades de legibilidad en el c\u00f3digo, pudiendo dar lugar a confusiones. Si es posible intenta evitar que se produzcan este tipo de situaciones.</p>"},{"location":"Unidad%206%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Avanzada%29/Unidad%206%20POO.%20Uso%20avanzado%20de%20clases%20-%20Herencia%2C%20polimorfismo%20y%20clases%20abstractas_2026/#45-herencia-de-interfaces","title":"4.5 Herencia de interfaces","text":"<p>Las interfaces, al igual que las clases, tambi\u00e9n permiten la herencia. Para indicar que una interfaz hereda de otra se indica nuevamente con la palabra reservada <code>extends</code>. Pero en este caso s\u00ed se permite la herencia m\u00faltiple de interfaces. Si se hereda de m\u00e1s de una interfaz se indica con la lista de interfaces separadas por comas.</p> <p>Por ejemplo, dadas las interfaces InterfazUno e InterfazDos:</p> <pre><code>public interface InterfazUno {\n\n    // M\u00e9todos y constantes de la interfaz Uno\n\n}\n</code></pre> <pre><code>public interface InterfazDos {\n\n    // M\u00e9todos y constantes de la interfaz Dos\n\n}\n</code></pre> <p>Podr\u00eda definirse una nueva interfaz que heredara de ambas:</p> <pre><code>public interface InterfazCompleja extends InterfazUno, InterfazDos {\n\n    // M\u00e9todos y constantes de la interfaz compleja\n\n}\n</code></pre> <p>Comparaci\u00f3n entre lenguajes: Herencia de interfaces</p> JavaPythonKotlin <pre><code>public interface InterfazCompleja extends InterfazUno, InterfazDos { }\n</code></pre> <pre><code>class InterfazCompleja(InterfazUno, InterfazDos):\n    pass\n</code></pre> <pre><code>    interface InterfazCompleja : InterfazUno, InterfazDos\n</code></pre> <p>\u200b    </p>"},{"location":"Unidad%206%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Avanzada%29/Unidad%206%20POO.%20Uso%20avanzado%20de%20clases%20-%20Herencia%2C%20polimorfismo%20y%20clases%20abstractas_2026/#5-interfaces-para-comparar-objetos","title":"5. Interfaces para comparar objetos","text":"<p>Hasta ahora hemos visto que las clases Arrays y Collections disponen de un conjunto de operaciones t\u00edpicas asociadas que son habituales:</p> <ul> <li>Ordenar listas y arrays.</li> <li>Desordenar listas y arrays.</li> <li>B\u00fasqueda binaria en listas y arrays.</li> <li>Conversi\u00f3n de arrays a listas y de listas a array.</li> <li>Partir cadenas y almacenar el resultado en un array.</li> </ul> <p>Estos algoritmos est\u00e1n recogidos como m\u00e9todos est\u00e1ticos de las <code>clases java.util.Collections</code> y <code>java.util.Arrays.</code></p> <p>Uno de estos m\u00e9todos es el m\u00e9todo sort. Permite ordenar los elementos pero \u00fanicamente funciona con objetos de la clase String, no con otro tipo de objetos.</p> <p>Los algoritmos de ordenaci\u00f3n ordenan los elementos en orden natural, siempre que Java sepa como ordenarlos. Los tipos \"ordenables\" de forma natural son los enteros, las cadenas (orden alfab\u00e9tico) y las fechas, y por defecto su orden es ascendente. Con el resto de clases, hay que facilitar un mecanismo para que se pueda producir esa ordenaci\u00f3n.</p> <p>En este apartado, vamos a ver c\u00f3mo hacerlo en Java y lo aplicaremos a los ArrayList pero funcionar\u00e1 igual con los Arrays. En concreto, estudiaremos las interfaces Comparable y Comparator; c\u00f3mo se implementan y c\u00f3mo se utilizan.</p>"},{"location":"Unidad%206%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Avanzada%29/Unidad%206%20POO.%20Uso%20avanzado%20de%20clases%20-%20Herencia%2C%20polimorfismo%20y%20clases%20abstractas_2026/#51-interfaz-comparable-i","title":"5.1 Interfaz Comparable (I)","text":"<p>En Java hay dos mecanismos para cambiar la forma en la que los elementos se ordenan. Imaginemos que los alumnos los tenemos almacenados en una lista llamada \"ListaAlumnos\" y necesitamos ordenarlos por nombre.</p> <pre><code>public class Alumno {\n    String nombre;\n    String apellidos;\n    String [] telefono = new String [3];\n    int edad;\n}\n</code></pre> <p>La primera forma de ordenar una lista consiste en crear un procedimiento bien definido para poder decidir dados 2 valores su orden relativo. Es decir, si uno de los valores es menor, igual o mayor que el otro. El orden impuesto en ese procedimiento se conoce como orden natural de la clase.</p> <p>Como hemos visto, no todas las clases tienen ese orden natural. Para que una clase sea ordenable deber\u00e1 implementar la interfaz comparable.</p> <p>La interfaz comparable tendr\u00e1 un \u00fanico m\u00e9todo, el m\u00e9todo compareTo. Con definir ese m\u00e9todo ser\u00e1 suficiente para que el m\u00e9todo sort funcione:</p> <pre><code>public interface Comparable&lt;T&gt; {\n    public int compareTo(T otro);\n}\n</code></pre> <p>En este caso, se utiliza  para indicar que es una interfaz gener\u00edca para un tipo (Type) o clase concreta. El m\u00e9todo compareTo se definir\u00e1 para toda la clase. Se usar\u00e1 un entero en vez de un boolean porque tenemos 3 casos diferentes para distinguir: menor, igual o mayor. <p>Por convenio, compareTo recibir\u00e1 un objeto y devolver\u00e1:</p> <ul> <li>Un valor negativo para indicar que el objeto es menor que el pasado como par\u00e1metro.</li> <li>0 cuando sean iguales.</li> <li>Un valor mayor que 0 para indicar que es mayor que el pasado como par\u00e1metro.</li> </ul> <pre><code>// Comparar objetos\nif (s1.compareTo(s2) &lt; 0) {\n    System.out.println(\"s1 es menor que s2\");\n}\n</code></pre> <p>En este caso, se utiliza  para indicar que es un interfaz gen\u00e9rica para un tipo (Type) o clase concreta: <pre><code>public class Alumno implements Comparable&lt;Alumno&gt; {\n    String nombre;\n    String apellidos;\n    String [] telefono = new String [3];\n    int edad;\n    @Override\n    public int compareTo(Alumno o) {\n\n        return this.nombre.compareTo(o.nombre);\n    }\n}\n</code></pre> <p>Aqu\u00ed podemos ver como implementamos el m\u00e9todo comparable directamente. Este va a realizar una ordenaci\u00f3n ascendente, de menor a mayor.</p> <p>Si queremos realizar una ordenaci\u00f3n de mayor a menor lo podemos realizar as\u00ed:</p> <pre><code>public class Alumno implements Comparable&lt;Alumno&gt; {\n    String nombre;\n    String apellidos;\n    String [] telefono = new String [3];\n    int edad;\n    @Override\n    public int compareTo(Alumno o) {\n\n        if (this.nombre.compareTo(o.nombre)==0)\n            return 0;\n        else if(this.nombre.compareTo(o.nombre)&gt;0)\n            return -1;\n        else\n            return 1;\n    }\n}\n</code></pre> <p>Y utilizando la misma estrategia podemos realizar una ordenaci\u00f3n por cualquier otro criterio de la clase Alumno.</p> <p>El funcionamiento del m\u00e9todo <code>compareTo</code> es el mismo que el m\u00e9todo compare de la interfaz <code>Comparator</code>: si la clase que se pasa por par\u00e1metro es igual al objeto, se tendr\u00eda que retornar 0; si es menor o anterior, se deber\u00eda retornar un n\u00famero menor que cero; si es mayor o posterior, se deber\u00eda retornar un n\u00famero mayor que 0.</p> <p>Ordenar ahora la lista de art\u00edculos es sencillo, f\u00edjate que f\u00e1cil: \"<code>Collections.sort(Alumnos);</code>\"</p> <pre><code>public class Main {\n\n    public static void main(String[] args) {\n\n        ArrayList&lt;Alumno&gt; Alumnos = new ArrayList&lt;Alumno&gt;();\n        Alumno a1 = new Alumno();\n        Alumno a2 = new Alumno();\n        Alumno a3 = new Alumno();\n        Alumno a4 = new Alumno();\n        Alumno a5 = new Alumno();\n        Alumno a6 = new Alumno();\n        a3.nombre=\"Loren\";\n        a4.nombre =\"Alejo\";\n        a1.nombre = \"Miquel Josep\";\n        a1.apellidos = \"Garcia\";\n        a1.edad = 25;\n        a1.telefono[0] = \"961712222\";\n        a1.telefono[1] = \"961702299\";\n        a2.nombre=\"Pepe\";\n        a5.nombre=\"Manu\";\n        a5.apellidos=\"Romero\";\n        a5.edad=40;\n        a6.nombre=\"Jose\";\n        a6.apellidos=\"Abad\";\n        a6.edad=30;\n\n        Alumnos.add(a1);\n        Alumnos.add(a2);\n        Alumnos.add(a3);\n        Alumnos.add(a4);\n        Alumnos.add(a5);\n        Alumnos.add(a6);\n\n        System.out.println(\"Impresi\u00f3n normal\");\n        System.out.println(\"************************************\");\n        for(Alumno a: Alumnos)\n            System.out.println(a.nombre);\n        System.out.println(\"************************************\");\n        System.out.println(\"Impresi\u00f3n ordenada\");\n        // Realizamos la ordenaci\u00f3n.\n        Collections.sort(Alumnos);\n        for(Alumno a: Alumnos)\n            System.out.println(a.nombre);\n    }\n\n}\n</code></pre> <p>Del ejemplo anterior se pueden mencionar 3 cosas importantes:</p> <ul> <li>La interfaz <code>Comparable</code> es gen\u00e9rica y para que funcione sin problemas hay que indicar la clase sobre la que se permite la comparaci\u00f3n. En este caso, el objeto <code>Alumno</code> debe compararse consigo mismo.</li> <li>El m\u00e9todo <code>compareTo</code> solo admite un par\u00e1metro, dado que comparar\u00e1 el objeto actual con el objeto que se pasa por par\u00e1metro.</li> <li>Dentro de compareTo tenemos que comparar 2 cadenas de caracteres. Para ello, utilizaremos el m\u00e9todo compareTo de la clase String.</li> <li>Si queremos comparar otros valores, deberemos redefinir la funci\u00f3n compareTo en la clase que implementamos la interfaz Comparable.</li> </ul> <p>Como ya se ha comentado, si el objeto que se pasa por par\u00e1metro es igual al objeto, se retornar\u00e1 0; si es menor, se retornar\u00e1 un n\u00famero menor que cero; si es mayor, se retornar\u00e1 un n\u00famero mayor que 0.</p> <p>Ordenar ahora la lista de art\u00edculos es tan sencillo como ejecutar la siguiente l\u00ednea de c\u00f3digo: \"<code>Collections.sort(Alumnos);</code>\"</p> <p>Comparaci\u00f3n entre lenguajes: Interfaz Comparable</p> JavaPythonKotlin <pre><code>public class Alumno implements Comparable&lt;Alumno&gt; { \n    @Override public int compareTo(Alumno o) { \n        return this.nombre.compareTo(o.nombre);\n        } \n    }\n</code></pre> <pre><code>class Alumno:\n    def __lt__(self, other):\n        return self.nombre &lt; other.nombre\n    # Tambi\u00e9n se pueden definir __le__, __gt__, __ge__, __eq__, __ne__\n</code></pre> <pre><code>class Alumno : Comparable&lt;Alumno&gt; {\n    override fun compareTo(other: Alumno): Int {\n        return this.nombre.compareTo(other.nombre)\n    }\n}\n</code></pre>"},{"location":"Unidad%206%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Avanzada%29/Unidad%206%20POO.%20Uso%20avanzado%20de%20clases%20-%20Herencia%2C%20polimorfismo%20y%20clases%20abstractas_2026/#5-2-interfaz-comparator-i","title":"5. 2 Interfaz Comparator (I)","text":"<p>Con la interfaz comparable definimos el orden natural de ordenaci\u00f3n, pero \u00bfse podr\u00eda cambiar ese orden de ordenaci\u00f3n? Hay casos en los que nos puede interesar cambiar la forma de ordenar los elementos. Esto es especialmente \u00fatil cuando el tipo de objeto que se almacena no es un simple n\u00famero, sino algo m\u00e1s complejo, un Alumno por ejemplo. Podr\u00edamos ordenarlo por la edad del alumno.</p> <p>Para indicarle a una colecci\u00f3n c\u00f3mo tiene que ordenar los elementos, debemos decirle cu\u00e1ndo un elemento va antes o despu\u00e9s que otro, y cu\u00e1ndo son iguales. Para ello, utilizamos la interfaz gen\u00e9rica <code>java.util.Comparator</code>, usada en algoritmos de ordenaci\u00f3n.</p> <p>Se trata de crear una clase que implemente dicha interfaz. Dicha interfaz requiere de un \u00fanico m\u00e9todo que debe calcular si un objeto pasado por par\u00e1metro es mayor, menor o igual que otro del mismo tipo.</p> <p>Veamos un ejemplo general de c\u00f3mo implementar un comparador para una hipot\u00e9tica clase \"<code>Objeto</code>\":</p> <pre><code>class ComparadorDeObjetos implements Comparator&lt;Clase&gt; {\n    public int compare(Objeto o1, Objeto o2) {\n        ...\n    }    \n}\n</code></pre> <p>La interfaz <code>Comparator</code> obliga a implementar un \u00fanico m\u00e9todo, es el m\u00e9todo compare, el cual tiene dos par\u00e1metros: los dos elementos a comparar. Las reglas son sencillas, a la hora de personalizar dicho m\u00e9todo:</p> <ul> <li>Si el primer objeto (<code>o1</code>) es menor que el segundo (<code>o2</code>), debe retornar un n\u00famero entero negativo.</li> <li>Si el primer objeto (<code>o1</code>) es mayor que el segundo (<code>o2</code>), debe retornar un n\u00famero entero positivo.</li> <li>Si ambos son iguales, debe retornar 0.</li> </ul> <p>A veces, cuando el orden que deben tener los elementos es diferente al orden real (por ejemplo cuando ordenamos los n\u00fameros en orden inverso), la definici\u00f3n de antes puede ser un poco liosa, as\u00ed que es recomendable en tales casos pensar de la siguiente forma:</p> <ul> <li>Si el primer objeto (<code>o1</code>) debe ir antes que el segundo objeto (<code>o2</code>), retornar entero negativo.</li> <li>Si el primer objeto (<code>o1</code>) debe ir despu\u00e9s que el segundo objeto (<code>o2</code>), retornar entero positivo.</li> <li>Si ambos son iguales, debe retornar 0.</li> </ul> <p>Una vez creado el comparador simplemente tenemos que pasarlo como par\u00e1metro en el momento de la creaci\u00f3n de la colecci\u00f3n, y los datos internamente mantendr\u00e1n dicha ordenaci\u00f3n:</p> <pre><code>Collections.sort(ListaObjetos, new comparadorObjetos());\n</code></pre> <p>Comparaci\u00f3n entre lenguajes: Interfaz Comparator</p> JavaPythonKotlin <pre><code>class ComparadorAlumnos implements Comparator&lt;Alumno&gt; { \n    public int compare(Alumno a1, Alumno a2) { \n    return a1.edad - a2.edad; \n    } \n} // Uso: Collections.sort(alumnos, new ComparadorAlumnos());`\n</code></pre> <pre><code>from functools import cmp_to_key\n\ndef comparar_alumnos(a1, a2):\n    return a1.edad - a2.edad\n\nalumnos.sort(key=cmp_to_key(comparar_alumnos))\n# O usar una lambda para criterios simples:\nalumnos.sort(key=lambda a: a.edad)\n</code></pre> <pre><code>val comparador = Comparator&lt;Alumno&gt; { a1, a2 -&gt;\n    a1.edad - a2.edad\n}\nalumnos.sortWith(comparador)\n// O m\u00e1s simple:\nalumnos.sortedBy { it.edad }\n</code></pre>"},{"location":"Unidad%206%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Avanzada%29/Unidad%206%20POO.%20Uso%20avanzado%20de%20clases%20-%20Herencia%2C%20polimorfismo%20y%20clases%20abstractas_2026/#6-polimorfismo","title":"6. Polimorfismo","text":"<p>El polimorfismo es otro de los grandes pilares sobre los que se sustenta la Programaci\u00f3n Orientada a Objetos (junto con la encapsulaci\u00f3n y la herencia). Se trata nuevamente de otra forma m\u00e1s de establecer diferencias entre interfaz e implementaci\u00f3n, es decir, entre el qu\u00e9 y el c\u00f3mo.</p> <p></p> <p>La encapsulaci\u00f3n te ha permitido agrupar caracter\u00edsticas (atributos) y comportamientos (m\u00e9todos) dentro de una misma unidad (clase), pudiendo darles un mayor o menor componente de visibilidad, y permitiendo separar al m\u00e1ximo posible la interfaz de la implementaci\u00f3n. Por otro lado la herencia te ha proporcionado la posibilidad de tratar a los objetos como pertenecientes a una jerarqu\u00eda de clases. Esta capacidad va a ser fundamental a la hora de poder manipular muchos posibles objetos de clases diferentes como si fueran de la misma clase (polimorfismo).</p> <p>El polimorfismo te va a permitir mejorar la organizaci\u00f3n y la legibilidad del c\u00f3digo as\u00ed como la posibilidad de desarrollar aplicaciones que sean m\u00e1s f\u00e1ciles de ampliar a la hora de incorporar nuevas funcionalidades. Si la implementaci\u00f3n y la utilizaci\u00f3n de las clases es lo suficientemente gen\u00e9rica y extensible ser\u00e1 m\u00e1s sencillo poder volver a este c\u00f3digo para incluir nuevos requerimientos.</p>"},{"location":"Unidad%206%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Avanzada%29/Unidad%206%20POO.%20Uso%20avanzado%20de%20clases%20-%20Herencia%2C%20polimorfismo%20y%20clases%20abstractas_2026/#61-concepto-de-polimorfismo","title":"6.1 Concepto de Polimorfismo","text":"<p>El polimorfismo consiste en la capacidad de poder utilizar una referencia a un objeto de una determinada clase como si fuera de otra clase (en concreto una subclase). Es una manera de decir que una clase podr\u00eda tener varias (poli) formas (morfismo).</p> <p>Un m\u00e9todo \"polim\u00f3rfico\" ofrece la posibilidad de ser distinguido (saber a qu\u00e9 clase pertenece) en tiempo de ejecuci\u00f3n en lugar de en tiempo de compilaci\u00f3n. Para poder hacer algo as\u00ed es necesario utilizar m\u00e9todos que pertenecen a una superclase y que en cada subclase se implementan de una forma en particular. En tiempo de compilaci\u00f3n se invocar\u00e1 al m\u00e9todo sin saber exactamente si ser\u00e1 el de una subclase u otra (pues se est\u00e1 invocando al de la superclase). S\u00f3lo en tiempo de ejecuci\u00f3n (una vez instanciada una u otra subclase) se conocer\u00e1 realmente qu\u00e9 m\u00e9todo (de qu\u00e9 subclase) es el que finalmente va a ser invocado.</p> <p>Esta forma de trabajar te va a permitir hasta cierto punto \"desentenderte\" del tipo de objeto espec\u00edfico (subclase) para centrarte en el tipo de objeto gen\u00e9rico (superclase). De este modo podr\u00e1s manipular objetos hasta cierto punto \"desconocidos\" en tiempo de compilaci\u00f3n y que s\u00f3lo durante la ejecuci\u00f3n del programa se sabr\u00e1 exactamente de qu\u00e9 tipo de objeto (subclase) se trata.</p> <p>\ud83d\udce3 El polimorfismo ofrece la posibilidad de que toda referencia a un objeto de una superclase pueda tomar la forma de una referencia a un objeto de una de sus subclases. Esto te va a permitir escribir programas que procesen objetos de clases que formen parte de la misma jerarqu\u00eda como si todos fueran objetos de sus superclases.</p> <p>\ud83d\udce3 El polimorfismo puede llevarse a cabo tanto con superclases (abstractas o no) como con interfaces.</p> <p>Dada una superclase X, con un m\u00e9todo m, y dos subclases A y B, que redefinen ese m\u00e9todo m, podr\u00edas declarar un objeto O de tipo X que en durante la ejecuci\u00f3n podr\u00e1 ser de tipo A o de tipo B (algo desconocido en tiempo de compilaci\u00f3n). Esto significa que al invocarse el m\u00e9todo m de X (superclase), se estar\u00e1 en realidad invocando al m\u00e9todo m de A o de B (alguna de sus subclases). Por ejemplo:</p> <pre><code>// Declaraci\u00f3n de una referencia a un objeto de tipo X\nClaseX obj;  // Objeto de tipo X (superclase)\n...\n\n// Zona del programa donde se instancia un objeto de tipo A (subclase) y se le asigna a la referencia obj.\n\n// La variable obj adquiere la forma de la subclase A.\nobj = ClaseA();\n...\n\n// Otra zona del programa.\n\n// Aqu\u00ed se instancia un objeto de tipo B (subclase) y se le asigna a la referencia obj.\n\n// La variable obj adquiere la forma de la subclase B.\nobj = ClaseB();\n...\n\n// Zona donde se utiliza el m\u00e9todo m sin saber realmente qu\u00e9 subclase se est\u00e1 utilizando.\n\n// (S\u00f3lo se sabr\u00e1 durante la ejecuci\u00f3n del programa)\nobj.m()  // Llamada al m\u00e9todo m (sin saber si ser\u00e1 el m\u00e9todo m de A o de B).\n...\n</code></pre> <p>Imagina que est\u00e1s trabajando con las clases <code>Alumno</code> y <code>Profesor</code> y que en determinada zona del c\u00f3digo podr\u00edas tener objetos, tanto de un tipo como de otro, pero eso s\u00f3lo se sabr\u00e1 seg\u00fan vaya discurriendo la ejecuci\u00f3n del programa. En algunos casos, es posible que un determinado objeto pudiera ser de la clase <code>Alumno</code> y en otros de la clase <code>Profesor</code>, pero en cualquier caso ser\u00e1n objetos de la clase <code>Persona</code>. Eso significa que la llamada a un m\u00e9todo de la clase <code>Persona</code> (por ejemplo <code>devolverContenidoString</code>) en realidad ser\u00e1 en unos casos a un m\u00e9todo (con el mismo nombre) de la clase <code>Alumno</code> y, en otros, a un m\u00e9todo (con el mismo nombre tambi\u00e9n) de la clase <code>Profesor</code>. Esto ser\u00e1 posible hacerlo gracias a la ligadura din\u00e1mica.</p> <p>Comparaci\u00f3n entre lenguajes: Polimorfismo</p> JavaPythonKotlin <pre><code>Persona p = new Alumno(); \n// Polimorfismo p.mostrar(); \n// Se ejecuta Alumno.mostrar()`\n</code></pre> <pre><code>p = Alumno()  # Polimorfismo impl\u00edcito\np.mostrar()   # Se ejecuta Alumno.mostrar()\n</code></pre> <pre><code>val p: Persona = Alumno() // Polimorfismo\np.mostrar() // Se ejecuta Alumno.mostrar()\n</code></pre>"},{"location":"Unidad%206%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Avanzada%29/Unidad%206%20POO.%20Uso%20avanzado%20de%20clases%20-%20Herencia%2C%20polimorfismo%20y%20clases%20abstractas_2026/#62-ligadura-dinamica","title":"6.2 Ligadura din\u00e1mica","text":"<p>La conexi\u00f3n que tiene lugar durante una llamada a un m\u00e9todo suele ser llamada ligadura, vinculaci\u00f3n o enlace (en ingl\u00e9s binding). Si esta vinculaci\u00f3n se lleva a cabo durante el proceso de compilaci\u00f3n, se le suele llamar ligadura est\u00e1tica (tambi\u00e9n conocido como vinculaci\u00f3n temprana). En los lenguajes tradicionales, no orientados a objetos, \u00e9sta es la \u00fanica forma de poder resolver la ligadura (en tiempo de compilaci\u00f3n). Sin embargo, en los lenguajes orientados a objetos existe otra posibilidad: la ligadura din\u00e1mica (tambi\u00e9n conocida como vinculaci\u00f3n tard\u00eda, enlace tard\u00edo o late binding).</p> <p>La ligadura din\u00e1mica hace posible que sea el tipo de objeto instanciado (obtenido mediante el constructor finalmente utilizado para crear el objeto) y no el tipo de la referencia (el tipo indicado en la declaraci\u00f3n de la variable que apuntar\u00e1 al objeto) lo que determine qu\u00e9 versi\u00f3n del m\u00e9todo va a ser invocada. El tipo de objeto al que apunta la variable de tipo referencia s\u00f3lo podr\u00e1 ser conocido durante la ejecuci\u00f3n del programa y por eso el polimorfismo necesita la ligadura din\u00e1mica.</p> <p>En el ejemplo anterior de la clase X y sus subclases A y B, la llamada al m\u00e9todo m s\u00f3lo puede resolverse mediante ligadura din\u00e1mica, pues es imposible saber en tiempo de compilaci\u00f3n si el m\u00e9todo m que debe ser invocado ser\u00e1 el definido en la subclase A o el definido en la subclase B:</p> <pre><code>// Llamada al m\u00e9todo m (sin saber si ser\u00e1 el m\u00e9todo m de A o de B).\nobj.m()  // Esta llamada ser\u00e1 resuelta en tiempo de ejecuci\u00f3n (ligadura din\u00e1mica)\n</code></pre> <p>Ejercicio 12</p> <p>Imag\u00ednate una clase que represente a instrumento musical gen\u00e9rico (Instrumento) y dos subclases que representen tipos de instrumentos espec\u00edficos (por ejemplo Flauta y Piano). Todas las clases tendr\u00e1n un m\u00e9todo tocarNota, que ser\u00e1 espec\u00edfico para cada subclase.</p> <p>Haz un peque\u00f1o programa de ejemplo en Java que utilice el polimorfismo (referencias a la superclase que se convierten en instancias espec\u00edficas de subclases) y la ligadura din\u00e1mica (llamadas a un m\u00e9todo que a\u00fan no est\u00e1n resueltas en tiempo de compilaci\u00f3n) con estas clases que representan instrumentos musicales. Puedes implementar el m\u00e9todo tocarNota mediante la escritura de un mensaje en pantalla.</p>"},{"location":"Unidad%206%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Avanzada%29/Unidad%206%20POO.%20Uso%20avanzado%20de%20clases%20-%20Herencia%2C%20polimorfismo%20y%20clases%20abstractas_2026/#63-limitaciones-de-la-ligadura-dinamica","title":"6.3 Limitaciones de la ligadura din\u00e1mica","text":"<p>Como has podido comprobar, el polimorfismo se basa en la utilizaci\u00f3n de referencias de un tipo m\u00e1s \"amplio\" (superclases) que los objetos a los que luego realmente van a apuntar (subclases). Ahora bien, existe una importante restricci\u00f3n en el uso de esta capacidad, pues el tipo de referencia limita cu\u00e1les son los m\u00e9todos que se pueden utilizar y los atributos a los que se pueden acceder.</p> <p>No se puede acceder a los miembros espec\u00edficos de una subclase a trav\u00e9s de una referencia a una superclase. S\u00f3lo se pueden utilizar los miembros declarados en la superclase, aunque la definici\u00f3n que finalmente se utilice en su ejecuci\u00f3n ser\u00e1 la de la subclase.</p> <p>En el ejemplo de las clases Persona , Profesor y Alumno , el polimorfismo nos permitir\u00eda declarar variables de tipo Persona y m\u00e1s tarde hacer con ellas referencia a objetos de tipo Profesor o Alumno , pero no deber\u00edamos intentar acceder con esa variable a m\u00e9todos que sean espec\u00edficos de la clase Profesor o de la clase Alumno , tan solo a m\u00e9todos que sabemos que van a existir seguro en ambos tipos de objetos (m\u00e9todos de la superclase Persona ).</p> <p>Ejercicio 13</p> <p>Haz un peque\u00f1o programa en Java en el que se declare una variable de tipo <code>Persona</code>, se pidan algunos datos sobre esa persona (nombre, apellidos y si es alumno o si es profesor), y se muestren nuevamente esos datos en pantalla, teniendo en cuenta que esa variable no puede ser instanciada como un objeto de tipo <code>Persona</code> (es una clase abstracta) y que tendr\u00e1s que instanciarla como <code>Alumno</code> o como <code>Profesor</code>. Recuerda que para poder recuperar sus datos necesitar\u00e1s hacer uso de la ligadura din\u00e1mica y que tan solo deber\u00edas acceder a m\u00e9todos que sean de la superclase.</p> <p>Comparaci\u00f3n entre lenguajes: Limitaciones del polimorfismo</p> JavaPythonKotlin <pre><code>Persona p = new Alumno(); \n// p.getGrupo(); \n// Error: no se puede acceder a m\u00e9todo espec\u00edfico de Alumno\n</code></pre> <pre><code>p = Alumno()\np.get_grupo()  # Funciona en Python (tipado din\u00e1mico)\n</code></pre> <pre><code>val p: Persona = Alumno()\n// p.grupo // Error: no se puede acceder a propiedad espec\u00edfica de Alumno\n</code></pre>"},{"location":"Unidad%206%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Avanzada%29/Unidad%206%20POO.%20Uso%20avanzado%20de%20clases%20-%20Herencia%2C%20polimorfismo%20y%20clases%20abstractas_2026/#64-interfaces-y-polimorfismo","title":"6.4 Interfaces y polimorfismo","text":"<p>Es posible tambi\u00e9n llevar a cabo el polimorfismo mediante el uso de interfaces. Un objeto puede tener una referencia cuyo tipo sea una interfaz, pero para que el compilador te lo permita, la clase cuyo constructor se utilice para crear el objeto deber\u00e1 implementar esa interfaz (bien por si misma o bien porque la implemente alguna superclase). Un objeto cuya referencia sea de tipo interfaz s\u00f3lo puede utilizar aquellos m\u00e9todos definidos en la interfaz, es decir, que no podr\u00e1n utilizarse los atributos y m\u00e9todos espec\u00edficos de su clase, tan solo los de la interfaz.</p> <p>Las referencias de tipo interfaz permiten unificar de una manera bastante estricta la forma de utilizarse de objetos que pertenezcan a clases muy diferentes (pero que todas ellas implementan la misma interfaz). De este modo podr\u00edas hacer referencia a diferentes objetos que no tienen ninguna relaci\u00f3n jer\u00e1rquica entre s\u00ed utilizando la misma variable (referencia a la interfaz). Lo \u00fanico que los distintos objetos tendr\u00edan en com\u00fan es que implementan la misma interfaz. En este caso s\u00f3lo podr\u00e1s llamar a los m\u00e9todos de la interfaz y no a los espec\u00edficos de las clases.</p> <p></p> <p>Por ejemplo, si ten\u00edas una variable de tipo referencia a la interfaz Arrancable, podr\u00edas instanciar objetos de tipo Coche o Motosierra y asignarlos a esa referencia (teniendo en cuenta que ambas clases no tienen una relaci\u00f3n de herencia). Sin embargo, tan solo podr\u00e1s usar en ambos casos los m\u00e9todos y los atributos de la interfaz Arrancable (por ejemplo arrancar) y no los de Coche o los de Motosierra (s\u00f3lo los gen\u00e9ricos, nunca los espec\u00edficos).</p> <p>En el caso de las clases <code>Persona</code>, <code>Alumno</code> y <code>Profesor</code>, podr\u00edas declarar, por ejemplo, variables del tipo <code>Imprimible</code>:</p> <pre><code>Imprimible obj;                 // Imprimible es una interfaz y no una clase\n</code></pre> <p>Con este tipo de referencia podr\u00edas luego apuntar a objetos tanto de tipo Profesor como de tipo Alumno, pues ambos implementan la interfaz Imprimible:</p> <pre><code>// En algunas circunstancias podr\u00eda suceder esto:\nobj = new  Alumno(nombre, apellidos, fecha, grupo, nota); // Polimorfismo con interfaces\n...\n// En otras circunstancias podr\u00eda suceder esto:\nobj = new  Profesor(nombre, apellidos, fecha, especialidad, salario); // Polimorfismo con interfaces\n...\n</code></pre> <p>Y m\u00e1s adelante hacer uso de la ligadura din\u00e1mica:</p> <pre><code>// Llamadas s\u00f3lo a m\u00e9todos de la interfaz\nString contenido;\ncontenido = obj.devolverContenidoString();  // Ligadura din\u00e1mica con interfaces\n</code></pre> <p>Comparaci\u00f3n entre lenguajes: Polimorfismo con interfaces</p> JavaPythonKotlin <pre><code>Imprimible obj = new Alumno(); String s = obj.devolverContenidoString();\n</code></pre> <pre><code>obj: Imprimible = Alumno()  # Notaci\u00f3n de tipo (opcional)\ns = obj.devolver_contenido_string()\n</code></pre> <pre><code>val obj: Imprimible = Alumno()\nval s = obj.devolverContenidoString()\n</code></pre>"},{"location":"Unidad%206%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Avanzada%29/Unidad%206%20POO.%20Uso%20avanzado%20de%20clases%20-%20Herencia%2C%20polimorfismo%20y%20clases%20abstractas_2026/#65-conversion-de-objetos","title":"6.5 Conversi\u00f3n de Objetos","text":"<p>Como ya has visto, en principio no se puede acceder a los miembros espec\u00edficos de una subclase a trav\u00e9s de una referencia a una superclase. Si deseas tener acceso a todos los m\u00e9todos y atributos espec\u00edficos del objeto subclase tendr\u00e1s que realizar una conversi\u00f3n expl\u00edcita (casting) que convierta la referencia m\u00e1s general (superclase) en la del tipo espec\u00edfico del objeto (subclase).</p> <p></p> <p>Para que puedas realizar conversiones entre distintas clases es obligatorio que exista una relaci\u00f3n de herencia entre ellas (una debe ser clase derivada de la otra). Se realizar\u00e1 una conversi\u00f3n impl\u00edcita o autom\u00e1tica de subclase a superclase siempre que sea necesario, pues un objeto de tipo subclase siempre contendr\u00e1 toda la informaci\u00f3n necesaria para ser considerado un objeto de la superclase.</p> <p>Ahora bien, la conversi\u00f3n en sentido contrario (de superclase a subclase) debe hacerse de forma expl\u00edcita y seg\u00fan el caso podr\u00eda dar lugar a errores por falta de informaci\u00f3n (atributos) o de m\u00e9todos. En tales casos se produce una *excepci\u00f3n* de tipo <code>ClassCastException</code>.</p> <p>Por ejemplo, imagina que tienes una clase A y una clase B, subclase de A:</p> <pre><code>class ClaseA {\n     public int atrib1;\n} \n\nclass ClaseB extends ClaseA {\n     public int atrib2;\n} \n</code></pre> <p>A continuaci\u00f3n declaras una variable referencia a la clase A (superclase) pero sin embargo le asignas una referencia a un objeto de la clase B (subclase) haciendo uso del polimorfismo:</p> <pre><code>ClaseA obj;          // Referencia a objetos de la clase A\nobj = new ClaseB();  // Referencia a objetos clase A, pero apunta realmente a objeto clase B (polimorfismo)\n</code></pre> <p>El objeto que acabas de crear como instancia de la clase B (subclase de A) contiene m\u00e1s informaci\u00f3n que la que la referencia obj te permite en principio acceder sin que el compilador genere un error (pues es de clase A). En concreto los objetos de la clase B disponen de atrib1 y atrib2, mientras que los objetos de la clase A s\u00f3lo de atrib1. Para acceder a esa informaci\u00f3n adicional de la clase especializada (atrib2) tendr\u00e1s que realizar una conversi\u00f3n expl\u00edcita (casting):</p> <pre><code>// Casting del tipo A al tipo B (funcionar\u00e1 bien porque el objeto es realmente del tipo B)\nClaseB objetoClaseB = (ClaseB) obj; \nSystem.out.printf(\"obj.atrib2 = %d\\n\", objetoClaseB.atrib2);\n</code></pre> <p>Sin embargo si se hubiera tratado de una instancia de la clase A y hubieras intentado acceder al miembro atrib2, se habr\u00eda producido una excepci\u00f3n de tipo <code>ClassCastException</code>:</p> <pre><code>ClaseA obj;          // Referencia a objetos de la clase A\nobj = new ClaseA();  // Referencia a objetos de la clase A, y apunta realmente a un objeto de la clase A\n\n// Casting del tipo A al tipo B (puede dar problemas porque el objeto es realmente del tipo A)\n// Convendr\u00eda usar la sentencia instanceof\nClaseB objetoClaseB = (ClaseB) obj; \n// Funciona (la clase A tiene atrib1)\nSystem.out.printf(\"obj.atrib1 = %d\\n\", obj.atrib1); \n\n// \u00a1Error en ejecuci\u00f3n! (la clase A no tiene atrib2). Producir\u00e1 una ClassCastException.\nSystem.out.printf (\"obj.atrib2 = %d\\n\", objetoClaseB.atrib2); \n</code></pre> <p>Comparaci\u00f3n entre lenguajes: Conversi\u00f3n de objetos</p> JavaPythonKotlin <pre><code>// Casting expl\u00edcito if (obj instanceof ClaseB) { ClaseB b = (ClaseB) obj; }`\n</code></pre> <pre><code># Casting generalmente no necesario en Python\nif isinstance(obj, ClaseB):\n    b = obj  # Ya es de tipo ClaseB\n</code></pre> <pre><code>// Casting seguro con 'as?'\nval b = obj as? ClaseB\nif (b != null) {\n    // Usar b\n}\n// O con 'is'\nif (obj is ClaseB) {\n    // obj se convierte autom\u00e1ticamente a ClaseB en este scope\n}\n</code></pre>"},{"location":"Unidad%206%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Avanzada%29/Unidad%206%20POO.%20Uso%20avanzado%20de%20clases%20-%20Herencia%2C%20polimorfismo%20y%20clases%20abstractas_2026/#7-la-clase-object-en-java","title":"7. La clase Object en Java","text":"<p>Todas las clases en Java son descendientes (directos o indirectos) de la clase <code>Object</code>. Esta clase define los estados y comportamientos b\u00e1sicos que deben tener todos los objetos. Entre estos comportamientos, se encuentran:</p> <ul> <li>La posibilidad de compararse.</li> <li>La capacidad de convertirse a cadenas.</li> <li>La habilidad de devolver la clase del objeto.</li> </ul> <p></p> <p>Entre los m\u00e9todos que incorpora la clase <code>Object</code> y que por tanto hereda cualquier clase en Java tienes:</p> <p>Principales m\u00e9todos de la clase Object</p> M\u00e9todo Descripci\u00f3n <code>Object()</code> Constructor. <code>clone()</code> M\u00e9todo clonador: crea y devuelve una copia del objeto (\"clona\" el objeto). ~~<code>void finalize()</code>~~ ~~M\u00e9todo llamado por el recolector de basura cuando considera que no queda ninguna referencia a este objeto.~~ <code>int hashCode()</code> Devuelve un c\u00f3digo hash para el objeto. <code>toString()</code> Devuelve una representaci\u00f3n del objeto en forma de <code>String</code>. boolean equals(Object obj) Indica si un objeto es igual o no al objeto pasado como par\u00e1metro. <p>La clase <code>Object</code> representa la superclase que se encuentra en la c\u00faspide de la jerarqu\u00eda de herencia en Java. Cualquier clase (incluso las que t\u00fa implementes) acaban heredando de ella.</p> <p></p> <p>Para saber m\u00e1s</p> <p>Para obtener m\u00e1s informaci\u00f3n sobre la clase <code>Object</code>, sus m\u00e9todos y propiedades, puedes consultar la documentaci\u00f3n de la API de Java en el sitio web de Oracle. Documentaci\u00f3n de la clase <code>Object</code>.</p> <p>Comparaci\u00f3n entre lenguajes: Clase base universal</p> JavaPythonKotlin <pre><code>// Todas las clases heredan de Object class MiClase { }\n// impl\u00edcitamente extiende Object`\n</code></pre> <pre><code># Todas las clases heredan de object\nclass MiClase:  # impl\u00edcitamente extiende object\n    pass\n</code></pre> <pre><code>// Todas las clases heredan de Any\nclass MiClase  // impl\u00edcitamente extiende Any\n</code></pre>"},{"location":"Unidad%206%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Avanzada%29/Unidad%206%20POO.%20Uso%20avanzado%20de%20clases%20-%20Herencia%2C%20polimorfismo%20y%20clases%20abstractas_2026/#71-el-metodo-equals","title":"7.1 El m\u00e9todo equals","text":"<p>Cuando explicamos las clases, ya vimos como se pod\u00eda reescribir el m\u00e9todo toString. Ahora sabemos que un m\u00e9todo que se hereda de la clase Object y que podemos reescribirlos para que muestre la informaci\u00f3n de nuestras clases siguiendo el formato que nos interesa.</p> <p>Tambi\u00e9n hemos visto que el operador \"==\" funcionaba correctamente con los tipos primitivos pero no con los objetos. Dos objetos solo son iguales cuando hacen referencia al mismo objeto. Si hacen referencia a 2 objetos diferentes, aunque tengan el mismo contenido, se consideran diferentes.</p> <p></p> <p>En este caso, por ejemplo, p1 y p2 ser\u00e1n diferentes, hacen referencia a 2 objetos con el mismo contenido, miestras que p2 y p3 ser\u00e1n iguales, hacen referencia al mismo objeto.</p> <p>Cuando hemos trabajado con objetos de la clase String y quer\u00edamos comparar si ten\u00edan el mismo contenido hemos usado el m\u00e9todo equals.</p> <p>Ahora vemos, que el m\u00e9todo equals se hereda de la clase Object y nos va a permitir comparar el estado de 2 objetos. Podemos comparar si todos los atributos de 2 objetos son iguales pero, igual que hac\u00edamos con toString, tendremos que reescribirlo.</p> <p>Debes conocer</p> <p>Para que m\u00e9todos como cotains(Object o), indexOf(Object o) o remove(Object o) funcionen correctamente, equals debe estar correctamente definido para la clase que estamos comparando.</p>"},{"location":"Unidad%206%20Programaci%C3%B3n%20Orientada%20a%20Objetos%20%28Avanzada%29/Unidad%206%20POO.%20Uso%20avanzado%20de%20clases%20-%20Herencia%2C%20polimorfismo%20y%20clases%20abstractas_2026/#72-reescribir-el-metodo-equals","title":"7.2 Reescribir el m\u00e9todo equals","text":"<p>Para reescribir el m\u00e9todo equals se debe seguir la estructura utilizada en el siguiente ejemplo realizado para la clase punto:</p> <pre><code>public boolean equals(Object o) {\n    if (o instanceof Punto) {\n        Punto objeto = (Punto) o;\n        return x == objeto.x &amp;&amp; y == objeto.y;\n    }\n    return false;\n}\n</code></pre> <p>Tened en cuenta que:</p> <ul> <li>El par\u00e1metro del m\u00e9todo equals es de la clase Object. Por ello, al hacer la llamada podemos pasarle un objeto de cualquier clase.</li> <li>Para compararlo con objetos de la clase que nos interesa hay que convertirlo a esa clase realizando un casting igual que hac\u00edamos con n\u00fameros enteros y double.</li> </ul> <pre><code>Punto objeto = (Punto) o;\n</code></pre> <ul> <li>Antes de hacer el casting debemos comprobar si el objeto es de esa clase para evitar excepciones. Utilizaremos la sentencia instanceof</li> </ul> <pre><code>  if (o instanceof Punto) {\n</code></pre> <ul> <li>Podemos devolver directamente la comparaci\u00f3n. No necesitamos un if-else.</li> </ul> <p>La versi\u00f3n gen\u00e9rica para cualquier clase quedar\u00eda:</p> <pre><code>public boolean equals(Object o) {\n    if (o instanceof &lt;clase&gt;) {\n        &lt;clase&gt; &lt;name&gt; = (&lt;clase&gt;) o;\n        &lt;Comparamos los atributos que nos interesan y hacemos el return&gt;\n    }\n    return false;\n}\n</code></pre> <p>Comparaci\u00f3n entre lenguajes: M\u00e9todo equals</p> JavaPythonKotlin <pre><code>@Override \npublic boolean equals(Object o) { \n    if (o instanceof Punto) { \n        Punto p = (Punto) o; \n        return this.x == p.x &amp;&amp; this.y == p.y; \n        } \n    return false; \n    }\n</code></pre> <pre><code>def __eq__(self, other):\n    if isinstance(other, Punto):\n        return self.x == other.x and self.y == other.y\n    return False\n</code></pre> <pre><code> // En Kotlin, data classes generan autom\u00e1ticamente equals, hashCode, toString\ndata class Punto(val x: Int, val y: Int)\n// Si no es data class:\noverride \nfun equals(other: Any?): Boolean {\n    if (other is Punto) {\n        return this.x == other.x &amp;&amp; this.y == other.y\n    }\n    return false\n}\n</code></pre>"}]}