{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Inicio","text":""},{"location":"#desarrollo-de-aplicaciones-multiplataforma-web-programacion","title":"Desarrollo de Aplicaciones Multiplataforma / Web  -- Programaci\u00f3n","text":""},{"location":"#2025-2026","title":"2025 - 2026","text":"<p>Imagen de Artur Shamsutdinov en Pixabay</p> <p>Profesores:</p> <ul> <li>Jos\u00e9 Manuel Romero Mart\u00ednez</li> <li>jm.romeromartinez@edu.gva.es</li> <li>Vicente Javier Esalava Mu\u00f1oz</li> <li>vj.eslavamunoz@edu.gva.es</li> </ul>"},{"location":"Unidad%201%20Introducci%C3%B3n%20a%20la%20Programaci%C3%B3n/1_Introducci%C3%B3n%20a%20la%20programacion/","title":"1 Introducci\u00f3n a la programacion","text":""},{"location":"Unidad%201%20Introducci%C3%B3n%20a%20la%20Programaci%C3%B3n/1_Introducci%C3%B3n%20a%20la%20programacion/#1-algoritmos-y-programas","title":"1. Algoritmos y Programas","text":"<p>Algoritmo: secuencia ordenada de pasos, descrita sin ambig\u00fcedades, que conducen a la soluci\u00f3n de un problema dado.</p> <p>Los algoritmos son independientes de los lenguajes de programaci\u00f3n y de las computadoras donde se ejecutan. Un mismo algoritmo puede ser expresado en diferentes lenguajes de programaci\u00f3n y podr\u00eda ser ejecutado en diferentes dispositivos. Piensa en una receta de cocina, \u00e9sta puede ser expresada en castellano, ingl\u00e9s o franc\u00e9s, podr\u00eda ser cocinada en fog\u00f3n o vitrocer\u00e1mica, por un cocinero o m\u00e1s, etc. Pero independientemente de todas estas circunstancias, el plato se preparar\u00e1 siguiendo los mismos pasos.</p> <p>La diferencia fundamental entre algoritmo y programa es que, en el segundo, los pasos que permiten resolver el problema, deben escribirse en un determinado lenguaje de programaci\u00f3n para que puedan ser ejecutados en el ordenador y as\u00ed obtener la soluci\u00f3n.</p> <p>Los lenguajes de programaci\u00f3n son s\u00f3lo un medio para expresar el algoritmo y el ordenador un procesador para ejecutarlo. Mediante el lenguaje creramos programas que ejecutan uno o m\u00e1s algoritmos en un sistema espec\u00edfico.</p> <p>En esencia, todo problema se puede describir por medio de un algoritmo y las caracter\u00edsticas fundamentales que \u00e9stos deben cumplir son:</p> <ul> <li>Debe ser preciso e indicar el orden de realizaci\u00f3n paso a paso.</li> <li>Debe estar definido, si se ejecuta dos o m\u00e1s veces, debe obtener el mismo resultado cada vez.</li> <li>Debe ser finito, debe tener un n\u00famero finito de pasos.</li> </ul>"},{"location":"Unidad%201%20Introducci%C3%B3n%20a%20la%20Programaci%C3%B3n/1_Introducci%C3%B3n%20a%20la%20programacion/#2-paradigmas-de-programacion","title":"2. Paradigmas de Programaci\u00f3n","text":"<p>Paradigma de programaci\u00f3n: es un modelo b\u00e1sico para el dise\u00f1o y la implementaci\u00f3n de programas. Este modelo determinar\u00e1 como ser\u00e1 el proceso de dise\u00f1o y la estructura final de un programa. Son las reglas del juego. Tienes una pelota o bal\u00f3n y una porter\u00eda, pero no es lo mismo jugar al f\u00fatbol que al balonmano. Pero en ambos tu objetivo es introducir el bal\u00f3n en la porter\u00eda y anotar m\u00e1s que tu rival. Igual pasa con los lenguajes, existen reglas y seg\u00fan las usemos podremos hacer unas cosas u otras. Tipos: Programaci\u00f3n Estructurada, Programaci\u00f3n Modular, Programaci\u00f3n Declarativa Programaci\u00f3n Orientada a Objetos, Programaci\u00f3n Reactiva, etc.</p>"},{"location":"Unidad%201%20Introducci%C3%B3n%20a%20la%20Programaci%C3%B3n/1_Introducci%C3%B3n%20a%20la%20programacion/#3-fases-de-programacion","title":"3. Fases de Programaci\u00f3n","text":"<p>El proceso de creaci\u00f3n de software puede dividirse en diferentes fases: - Fase de resoluci\u00f3n del problema: An\u00e1lisis y Dise\u00f1o. - Fase de implementaci\u00f3n: Codificaci\u00f3n y Pruebas. - Fase de explotaci\u00f3n y mantenimiento.</p>"},{"location":"Unidad%201%20Introducci%C3%B3n%20a%20la%20Programaci%C3%B3n/1_Introducci%C3%B3n%20a%20la%20programacion/#4-tipos-de-lenguajes","title":"4. Tipos de Lenguajes","text":""},{"location":"Unidad%201%20Introducci%C3%B3n%20a%20la%20Programaci%C3%B3n/1_Introducci%C3%B3n%20a%20la%20programacion/#41-cercania-al-programador","title":"4.1. Cercan\u00eda al programador","text":"<ul> <li>Alto nivel: C, C++, Java, Kotlin, Python, etc.</li> <li>Bajo nivel: ensamblador, m\u00e1quina, etc.</li> </ul>"},{"location":"Unidad%201%20Introducci%C3%B3n%20a%20la%20Programaci%C3%B3n/1_Introducci%C3%B3n%20a%20la%20programacion/#42-generaciones","title":"4.2. Generaciones","text":"<ul> <li>Primera generaci\u00f3n: lenguaje maquina. </li> <li>Segunda generaci\u00f3n: se crearon los primeros lenguajes ensambladores. </li> <li>Tercera generaci\u00f3n: se crean los primeros lenguajes de alto nivel. Ej. C, Pascal, Cobol\u2026 </li> <li>Cuarta generaci\u00f3n: son los lenguajes capaces de generar c\u00f3digo por si solos, son los llamados RAD, con lo cuales se pueden realizar aplicaciones sin ser un experto en el lenguaje.</li> <li>Quinta generaci\u00f3n: aqu\u00ed se encuentran los lenguajes orientados a la inteligencia artificial. Ej. LISP </li> </ul>"},{"location":"Unidad%201%20Introducci%C3%B3n%20a%20la%20Programaci%C3%B3n/1_Introducci%C3%B3n%20a%20la%20programacion/#5-traductores-compiladores-e-interpretes","title":"5. Traductores: Compiladores e Int\u00e9rpretes","text":"<p>La traducci\u00f3n de un programa escrito en un lenguaje de programaci\u00f3n a un lenguaje de m\u00e1quina se realiza mediante un traductor. Este traductor puede ser un compilador o un int\u00e9rprete. Sus fases principales, son: - An\u00e1lisis l\u00e9xico: se analiza el programa fuente y se separa en tokens. - An\u00e1lisis sint\u00e1ctico: se analiza la estructura del programa y se comprueba que la sintaxis sea correcta. - An\u00e1lisis sem\u00e1ntico: se comprueba que el programa tenga sentido y que no haya errores. - Optimizaci\u00f3n: se realiza una serie de optimizaciones para mejorar el rendimiento del programa. - Enlazador: se enlazan las librer\u00edas necesarias para que el programa funcione.</p>"},{"location":"Unidad%201%20Introducci%C3%B3n%20a%20la%20Programaci%C3%B3n/1_Introducci%C3%B3n%20a%20la%20programacion/#51-lenguaje-compilado","title":"5.1. Lenguaje compilado","text":"<p>Gracias al compiladores se convierte el c\u00f3digo a binarios que se ejecutan en el sistema operativo.</p>"},{"location":"Unidad%201%20Introducci%C3%B3n%20a%20la%20Programaci%C3%B3n/1_Introducci%C3%B3n%20a%20la%20programacion/#52-lenguaje-interpretado","title":"5.2. Lenguaje interpretado","text":"<p>Los lenguaje interpretados, necesita de dicho int\u00e9rprete, que lea la instrucci\u00f3n que se necesita ejecutar, realice el proceso de traducci\u00f3n de la misma y la ejecute.</p>"},{"location":"Unidad%201%20Introducci%C3%B3n%20a%20la%20Programaci%C3%B3n/1_Introducci%C3%B3n%20a%20la%20programacion/#53-lenguaje-mixto-o-intermedio","title":"5.3. Lenguaje mixto o intermedio","text":"<p>Es un lenguaje que se compila a un c\u00f3digo objeto o intermedio y se interpreta en una m\u00e1quina virtual . Ej. Java o Kotlin.</p>"},{"location":"Unidad%201%20Introducci%C3%B3n%20a%20la%20Programaci%C3%B3n/1_Introducci%C3%B3n%20a%20la%20programacion/#6-paradigmas-de-programacion","title":"6. Paradigmas de Programaci\u00f3n","text":"<p>Los lenguajes de programaci\u00f3n tambi\u00e9n se pueden clasificar por paradigmas. Un paradigma de programaci\u00f3n es una forma de clasificar los lenguajes de programaci\u00f3n seg\u00fan las caracter\u00edsticas y estilos de programaci\u00f3n que promueven. Aqu\u00ed hay una descripci\u00f3n general de algunos de los paradigmas m\u00e1s comunes:</p> <p>Programaci\u00f3n Imperativa:</p> <p>En la programaci\u00f3n imperativa, los programas son una serie de comandos que la computadora ejecuta en orden. Los comandos cambian el estado del programa. Los lenguajes de programaci\u00f3n imperativa incluyen C, C++, Java y Python.</p> <p>Programaci\u00f3n Declarativa:</p> <p>En la programaci\u00f3n declarativa, los programas describen el resultado que se desea, no c\u00f3mo lograrlo. Los lenguajes de programaci\u00f3n declarativa incluyen SQL y HTML.</p> <p>Programaci\u00f3n Procedimental:</p> <p>La programaci\u00f3n procedimental es un subtipo de programaci\u00f3n imperativa. En la programaci\u00f3n procedimental, los programas son una serie de procedimientos o funciones que manipulan el estado del programa. Los lenguajes de programaci\u00f3n procedimental incluyen C, Pascal y BASIC.</p> <p>Programaci\u00f3n Orientada a Objetos (OOP):</p> <p>En la programaci\u00f3n orientada a objetos, los programas son una colecci\u00f3n de objetos que interact\u00faan entre s\u00ed. Los objetos son instancias de clases, que contienen datos y m\u00e9todos que operan en esos datos. Los lenguajes de programaci\u00f3n orientados a objetos incluyen Java, C++, Python y Ruby.</p> <p>Programaci\u00f3n Funcional:</p> <p>En la programaci\u00f3n funcional, los programas son una serie de funciones matem\u00e1ticas. Las funciones no tienen estado y no cambian ning\u00fan dato. Los lenguajes de programaci\u00f3n funcional incluyen Haskell, Erlang y Lisp.</p> <p>Programaci\u00f3n L\u00f3gica:</p> <p>En la programaci\u00f3n l\u00f3gica, los programas son una serie de afirmaciones en l\u00f3gica formal. La computadora deduce la respuesta a una pregunta utilizando estas afirmaciones. Los lenguajes de programaci\u00f3n l\u00f3gica incluyen Prolog y Datalog.</p> <p>Programaci\u00f3n de Eventos:</p> <p>En la programaci\u00f3n basada en eventos, el flujo del programa est\u00e1 determinado por eventos, como la entrada del usuario o los cambios en el estado del sistema. Este paradigma es com\u00fanmente utilizado en la programaci\u00f3n de interfaces gr\u00e1ficas de usuario y servidores. Los lenguajes que soportan la programaci\u00f3n basada en eventos incluyen JavaScript y Python.</p> <p>Estos son solo algunos de los paradigmas de programaci\u00f3n m\u00e1s comunes. Muchos lenguajes de programaci\u00f3n soportan m\u00faltiples paradigmas. Por ejemplo, Python admite tanto la programaci\u00f3n imperativa como la orientada a objetos. La elecci\u00f3n del paradigma depende del problema que se est\u00e9 tratando de resolver y de las preferencias del programador.</p>"},{"location":"Unidad%201%20Introducci%C3%B3n%20a%20la%20Programaci%C3%B3n/1_Introducci%C3%B3n%20a%20la%20programacion/#7-elementos-de-un-lenguaje-de-programacion","title":"7. Elementos de un Lenguaje de Programaci\u00f3n","text":"<p>Un lenguaje de programaci\u00f3n es un lenguaje formal que proporciona un conjunto de instrucciones que permiten a un programador escribir secuencias de comandos, que son interpretadas por una m\u00e1quina, para producir un comportamiento deseado. Estos lenguajes son utilizados para controlar el comportamiento de las m\u00e1quinas o para expresar algoritmos.</p> <p>Los lenguajes de programaci\u00f3n constan de varios elementos clave, que incluyen:</p> <p>1. Sintaxis:</p> <p>La sintaxis de un lenguaje de programaci\u00f3n se refiere a las reglas que rigen la estructura de las declaraciones y expresiones v\u00e1lidas en ese lenguaje. Por ejemplo, en el lenguaje de programaci\u00f3n Python, la indentaci\u00f3n es parte de la sintaxis y se utiliza para delimitar bloques de c\u00f3digo.</p> <p>2. Sem\u00e1ntica:</p> <p>La sem\u00e1ntica de un lenguaje de programaci\u00f3n se refiere al significado de las declaraciones y expresiones. Por ejemplo, en la mayor\u00eda de los lenguajes de programaci\u00f3n, la expresi\u00f3n \"a = b + c\" significa que el valor de \"b + c\" debe ser calculado y luego asignado a la variable \"a\".</p> <p>3. Tipos de Datos:</p> <p>Los tipos de datos son los diferentes tipos de valores que pueden ser representados y manipulados en un lenguaje de programaci\u00f3n. Los tipos de datos comunes incluyen n\u00fameros enteros, n\u00fameros de punto flotante, caracteres, cadenas y booleanos. Los tipos de datos es algo crucial para clasificar la informaci\u00f3n y reflejan:   - Conjunto de valores v\u00e1lidos admitidos: enteros, decimales, caracteres, cadenas y booleanos.   - Conjunto de operaciones v\u00e1lidas para ese conjunto de valores: adici\u00f3n, multiplicaci\u00f3n, comparaci\u00f3n de igualdad, etc. (por ejemplo es lo mismo la divisi\u00f3n entera que la divisi\u00f3n real, es decir, 3/2) </p> <p>4. Variables:</p> <p>Las variables son s\u00edmbolos que representan valores en el programa. Las variables tienen tipos, y un valor de un tipo particular puede ser asignado a una variable.</p> <p>5. Operadores:</p> <p>Los operadores son s\u00edmbolos que representan operaciones espec\u00edficas. Por ejemplo, \"+\" es un operador que representa la adici\u00f3n, y \"==\" es un operador que representa la comparaci\u00f3n de igualdad.</p> <p>6. Control de Flujo:</p> <p>Las estructuras de control de flujo determinan el orden en el que se ejecutan las instrucciones en un programa. Las estructuras de control de flujo comunes incluyen condicionales (como \"if\" y \"switch\" en C++) y bucles (como \"for\" y \"while\").</p> <p>7. Subrutinas y Funciones:</p> <p>Las subrutinas y funciones son bloques de c\u00f3digo que pueden ser definidos y llamados por nombre. Permiten la reutilizaci\u00f3n de c\u00f3digo y ayudan a hacer los programas m\u00e1s modulares y m\u00e1s f\u00e1ciles de entender y mantener.</p> <p>8. Comentarios:</p> <p>Los comentarios son notas que los programadores dejan en el c\u00f3digo para explicar lo que hace el c\u00f3digo o por qu\u00e9 se tom\u00f3 una decisi\u00f3n particular de programaci\u00f3n. Los comentarios no son ejecutados como parte del programa.</p> <p>Estos son solo algunos de los elementos b\u00e1sicos de un lenguaje de programaci\u00f3n. Los lenguajes de programaci\u00f3n pueden variar ampliamente en t\u00e9rminos de qu\u00e9 elementos soportan y c\u00f3mo se implementan estos elementos.</p>"},{"location":"Unidad%201%20Introducci%C3%B3n%20a%20la%20Programaci%C3%B3n/1_Introducci%C3%B3n%20a%20la%20programacion/#8-referencias","title":"8. Referencias","text":"<ul> <li>http://www.larevistainformatica.com/clasificacion-de-los-lenguajes-de-programacion.html</li> <li>https://programas.cuaed.unam.mx/repositorio/moodle/pluginfile.php/1023/mod_resource/content/1/contenido/index.html#:~:text=Un%20lenguaje%20de%20bajo%20nivel,programas%20de%20una%20manera%20sencilla.</li> <li>https://profile.es/blog/que-son-los-paradigmas-de-programacion/#:~:text=Un%20paradigma%20de%20programaci%C3%B3n%20es,resultados%20que%20necesitan%20los%20programadores.</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/","title":"Programaci\u00f3n - 02 Programaci\u00f3n Estructurada y Modular","text":"<p>UD2 Programaci\u00f3n Estructurada y Modular. 1DAM/DAW. Curso 2025/2026.</p>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#1-tipos-y-operaciones","title":"1. Tipos y Operaciones","text":"<p>Los tipos de datos nos sirven para clasificar nuestra informaci\u00f3n de entrada y salida y trabajar con ellos. Un tipo lo define en base al valor que puede almacenar y las operaciones que se pueden realizar con \u00e9l.</p> <ul> <li> <p>Tipos simples: Se llama tipo de dato a una clase concreta de objetos o valores: N\u00fameros, Caracter, L\u00f3gicos, etc.</p> </li> <li> <p>Tipos compuestos: arrays, listas, etc, que los veremos m\u00e1s adelante.</p> </li> </ul> kotlinJavaPython <pre><code>// Tipos de datos\n// Tipos simples\n// N\u00fameros\nvar numero: Int = 1\nvar numero: Double = 1.0\nvar numero: Float = 1.0f\nvar numero: Long = 1L\nvar numero: Short = 1\nvar numero: Byte = 1\n// Caracteres\nvar caracter: Char = 'a'\n// L\u00f3gicos\nvar logico: Boolean = true\n// Cadenas\nvar cadena: String = \"Hola\"\n// Tipos compuestos\n// Arrays\nvar array: Array&lt;Int&gt; = arrayOf(1, 2, 3)\nvar array: IntArray = intArrayOf(1, 2, 3)\nvar array: Array&lt;String&gt; = arrayOf(\"Hola\", \"Adi\u00f3s\")\nvar array: Array&lt;Boolean&gt; = arrayOf(true, false)\n// Matrices\nvar matriz: Array&lt;Array&lt;Int&gt;&gt; = arrayOf(arrayOf(1, 2, 3), arrayOf(4, 5, 6))\nvar matriz: Array&lt;IntArray&gt; = arrayOf(intArrayOf(1, 2, 3), intArrayOf(4, 5, 6))\n</code></pre> <pre><code>// Tipos de datos\n// Tipos simples\n// N\u00fameros\nint entero = 1;             // Entero (32 bits)\ndouble doble = 1.0;          // Punto flotante doble precisi\u00f3n (64 bits)\nfloat flotante = 1.0f;       // Punto flotante simple precisi\u00f3n (32 bits)\nlong largo = 1L;             // Entero largo (64 bits)\nshort corto = 1;             // Entero corto (16 bits)\nbyte byteValor = 1;          // Byte (8 bits)\n// Caracteres\nchar caracter = 'a';         // Car\u00e1cter Unicode (16 bits)\n// L\u00f3gicos\nboolean logico = true;       // Valor booleano (true/false)\n// Cadenas\nString cadena = \"Hola\";      // Cadena de caracteres (objeto inmutable)\n// Tipos compuestos\n// Arrays\nInteger[] arrayInteger = {1, 2, 3};          // Array de objetos Integer\nint[] arrayInt = {1, 2, 3};                  // Array de primitivos int\nString[] arrayString = {\"Hola\", \"Adi\u00f3s\"};    // Array de String\nboolean[] arrayBoolean = {true, false};      // Array de boolean\n// Matrices\nint[][] matriz = {{1, 2, 3}, {4, 5, 6}};     // Matriz de int\nInteger[][] matrizObjetos = {{1, 2, 3}, {4, 5, 6}}; // Matriz de Integer\n</code></pre> <pre><code># Tipos de datos en Python\nentero = 1                  # Equivalente a Int (enteros de precisi\u00f3n arbitraria)\nflotante = 1.0              # Equivalente a Double (float en Python)\nflotante_precision = 1.0    # Python solo tiene un tipo de flotante (64 bits)\nlargo = 1                   # En Python 3, todos los enteros son de largo alcance\n# No hay equivalente exacto a Short o Byte en Python b\u00e1sico\ncaracter = 'a'              # En Python, es un string de longitud 1\nlogico = True               # Bool (True o False)\ncadena = \"Hola\"             # String (cadena de caracteres)\n\nlista_enteros = [1, 2, 3]                   # Lista de enteros\nlista_strings = [\"Hola\", \"Adi\u00f3s\"]            # Lista de strings\nlista_booleanos = [True, False]              # Lista de booleanos\ntupla_enteros = (1, 2, 3)                   # Tupla de enteros\nmatriz = [[1, 2, 3], [4, 5, 6]]             # Matriz como lista de listas\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#11-lenguajes-tipados-y-no-tipados","title":"1.1. Lenguajes tipados y no tipados","text":"<ul> <li>Lenguajes tipados: Los lenguajes tipados son aquellos que requieren que el programador declare el tipo de dato que se va a utilizar en cada variable. En estos lenguajes, el compilador o int\u00e9rprete comprueba que el tipo de dato de cada variable coincida con el tipo de dato que se ha declarado. </li> <li>Lenguajes d\u00e9bilmente tipados y/o tipado din\u00e1mico: Los lenguajes debilmente tipados son aquellos que no requieren que el programador declare el tipo de dato que se va a utilizar en cada variable. El compilador o int\u00e9rprete deduce el tipo de dato de cada variable en tiempo de ejecuci\u00f3n.</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#12-operaciones","title":"1.2. Operaciones","text":"KotlinJavaPython <pre><code>// Aritm\u00e9ticos\nvar a = 5 + 3   // Suma: 8\na = 5 - 3       // Resta: 2\na = 5 * 3       // Multiplicaci\u00f3n: 15\na = 5 / 3       // Divisi\u00f3n entera: 1\nval b = 5.0 / 3 // Divisi\u00f3n flotante: 1.666...\nval c = 5 % 3   // M\u00f3dulo: 2\na++             // Incremento (postfijo)\n++a             // Incremento (prefijo)\na--             // Decremento (postfijo)\n--a             // Decremento (prefijo)\n\n// Relacionales\nval d = (5 == 3)  // Igualdad: false\nval e = (5 != 3)  // Desigualdad: true\nval f = (5 &gt; 3)   // Mayor que: true\nval g = (5 &lt; 3)   // Menor que: false\nval h = (5 &gt;= 3)  // Mayor o igual: true\nval i = (5 &lt;= 3)  // Menor o igual: false\n\n// L\u00f3gicos\nval j = true &amp;&amp; false  // AND: false\nval k = true || false  // OR: true\nval l = !true          // NOT: false\n\n// Asignaci\u00f3n\nvar m = 5       // Asignaci\u00f3n simple\nm += 3          // Suma y asignaci\u00f3n (m = m + 3)\nm -= 2          // Resta y asignaci\u00f3n\nm *= 2          // Multiplicaci\u00f3n y asignaci\u00f3n\nm /= 3          // Divisi\u00f3n y asignaci\u00f3n\nm %= 3          // M\u00f3dulo y asignaci\u00f3n\n</code></pre> <pre><code>// Aritm\u00e9ticos\nint a = 5 + 3;   // Suma: 8\na = 5 - 3;       // Resta: 2\na = 5 * 3;       // Multiplicaci\u00f3n: 15\na = 5 / 3;       // Divisi\u00f3n entera: 1\ndouble b = 5.0 / 3; // Divisi\u00f3n flotante: 1.666...\nint c = 5 % 3;   // M\u00f3dulo: 2\na++;             // Incremento (postfijo)\n++a;             // Incremento (prefijo)\na--;             // Decremento (postfijo)\n--a;             // Decremento (prefijo)\n\n// Relacionales\nboolean d = (5 == 3);  // Igualdad: false\nboolean e = (5 != 3);  // Desigualdad: true\nboolean f = (5 &gt; 3);   // Mayor que: true\nboolean g = (5 &lt; 3);   // Menor que: false\nboolean h = (5 &gt;= 3);  // Mayor o igual: true\nboolean i = (5 &lt;= 3);  // Menor o igual: false\n\n// L\u00f3gicos\nboolean j = true &amp;&amp; false;  // AND: false\nboolean k = true || false;  // OR: true\nboolean l = !true;          // NOT: false\n\n// Asignaci\u00f3n\nint m = 5;       // Asignaci\u00f3n simple\nm += 3;          // Suma y asignaci\u00f3n (m = m + 3)\nm -= 2;          // Resta y asignaci\u00f3n\nm *= 2;          // Multiplicaci\u00f3n y asignaci\u00f3n\nm /= 3;          // Divisi\u00f3n y asignaci\u00f3n\nm %= 3;          // M\u00f3dulo y asignaci\u00f3n\n</code></pre> <pre><code># Aritm\u00e9ticos\na = 5 + 3   # Suma: 8\na = 5 - 3   # Resta: 2\na = 5 * 3   # Multiplicaci\u00f3n: 15\na = 5 / 3   # Divisi\u00f3n flotante: 1.666...\na = 5 // 3  # Divisi\u00f3n entera: 1\na = 5 % 3   # M\u00f3dulo: 2\na = 5 ** 3  # Potencia: 125\n# Python no tiene ++ o --\na += 1      # Incremento alternativo\na -= 1      # Decremento alternativo\n\n# Relacionales\nd = (5 == 3)  # Igualdad: False\ne = (5 != 3)  # Desigualdad: True\nf = (5 &gt; 3)   # Mayor que: True\ng = (5 &lt; 3)   # Menor que: False\nh = (5 &gt;= 3)  # Mayor o igual: True\ni = (5 &lt;= 3)  # Menor o igual: False\n\n# L\u00f3gicos\nj = True and False  # AND: False\nk = True or False   # OR: True\nl = not True        # NOT: False\n\n# Asignaci\u00f3n\nm = 5       # Asignaci\u00f3n simple\nm += 3      # Suma y asignaci\u00f3n (m = m + 3)\nm -= 2      # Resta y asignaci\u00f3n\nm *= 2      # Multiplicaci\u00f3n y asignaci\u00f3n\nm /= 3      # Divisi\u00f3n y asignaci\u00f3n\nm %= 3      # M\u00f3dulo y asignaci\u00f3n\nm **= 2     # Potencia y asignaci\u00f3n\nm //= 2     # Divisi\u00f3n entera y asignaci\u00f3n\n</code></pre> Diferencias clave: <ul> <li> <p>Python usa and, or, not en lugar de &amp;&amp;, ||, !</p> </li> <li> <p>Python no tiene operadores de incremento/decremento (++, --)</p> </li> <li> <p>Python tiene operador de potencia (**) y divisi\u00f3n entera (//)</p> </li> <li> <p>Java/Kotlin requieren punto y coma y declaraciones de tipo expl\u00edcitas</p> </li> <li> <p>Kotlin usa === para igualdad referencial</p> </li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#13-precedencia-de-operadores-kotlin-vs-java-vs-python","title":"1.3. Precedencia de Operadores (Kotlin vs Java vs Python)","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#tabla-de-precedencia-completa","title":"Tabla de Precedencia Completa","text":"Nivel Categor\u00eda Kotlin/Java Python 1 Agrupaci\u00f3n <code>()</code> <code>()</code> 2 Acceso/Member <code>.</code>, <code>?.</code>, <code>[]</code>, <code>()</code> <code>.</code>, <code>[]</code>, <code>()</code> 3 Sufijo <code>++</code>, <code>--</code> (sufijo) N/A 4 Prefijo/Unario <code>-</code>, <code>+</code>, <code>!</code>, <code>++</code>, <code>--</code> (prefijo) <code>-</code>, <code>+</code>, <code>~</code>, <code>not</code> 5 Multiplicativo <code>*</code>, <code>/</code>, <code>%</code> <code>*</code>, <code>/</code>, <code>//</code>, <code>%</code>, <code>@</code> 6 Aditivo <code>+</code>, <code>-</code> <code>+</code>, <code>-</code> 7 Rangos <code>..</code>, <code>in</code>, <code>!in</code> N/A 8 Desplazamiento <code>shl</code>, <code>shr</code>, <code>ushr</code> <code>&lt;&lt;</code>, <code>&gt;&gt;</code> 9 AND bit a bit <code>and</code> (Kotlin), <code>&amp;</code> (Java) <code>&amp;</code> 10 XOR bit a bit <code>xor</code> (Kotlin), <code>^</code> (Java) <code>^</code> 11 OR bit a bit <code>or</code> (Kotlin), <code>\\|</code> (Java) <code>\\|</code> 12 Comparaci\u00f3n <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>==</code>, <code>!=</code>, <code>is</code>, <code>is not</code>, <code>in</code>, <code>not in</code> 13 Igualdad <code>==</code>, <code>!=</code>, <code>===</code>, <code>!==</code> <code>==</code>, <code>!=</code> 14 Conjunci\u00f3n l\u00f3gica <code>&amp;&amp;</code> <code>and</code> 15 Disyunci\u00f3n l\u00f3gica <code>\\|\\|</code> <code>or</code> 16 Elvis/Asignaci\u00f3n <code>?:</code>, <code>=</code>, <code>+=</code>, etc. <code>:=</code> (walrus), <code>=</code>, <code>+=</code>, etc."},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#diferencias-clave","title":"Diferencias Clave","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#1-operadores-bit-a-bit","title":"1. Operadores Bit a Bit","text":"<pre><code>// Kotlin usa palabras clave\nval a = 0b1010 and 0b1100  // 0b1000\nval b = 0b1010 or 0b1100   // 0b1110\n</code></pre> <pre><code>// Java usa s\u00edmbolos\nint a = 0b1010 &amp; 0b1100;  // 0b1000\nint b = 0b1010 | 0b1100;   // 0b1110\n</code></pre> <pre><code># Python usa s\u00edmbolos como Java\na = 0b1010 &amp; 0b1100  # 0b1000\nb = 0b1010 | 0b1100   # 0b1110\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#2-operadores-logicos","title":"2. Operadores L\u00f3gicos","text":"<pre><code>// Kotlin usa s\u00edmbolos\nif (a &gt; 5 &amp;&amp; b &lt; 10 || c == 0) { ... }\n</code></pre> <pre><code># Python usa palabras\nif a &gt; 5 and b &lt; 10 or c == 0: ...\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#3-operador-walrus-python-38","title":"3. Operador Walrus (Python 3.8+)","text":"<pre><code># Python tiene operador de asignaci\u00f3n en expresiones\nif (n := len(a)) &gt; 10:\n    print(f\"Lista larga con {n} elementos\")\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#ejemplos-practicos","title":"Ejemplos Pr\u00e1cticos","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#expresion-completa","title":"Expresi\u00f3n Completa","text":"KotlinJavaPython <pre><code>val result = 5 + 3 * 2 &lt; 15 &amp;&amp; (10 % 3 == 1 || 2 shl 3 &gt; 10)\n// Paso a paso:\n// 1. 3*2=6\n// 2. 5+6=11\n// 3. 10%3=1\n// 4. 2 shl 3=16\n// 5. 1==1 \u2192 true\n// 6. 16&gt;10 \u2192 true\n// 7. true||true \u2192 true\n// 8. 11&lt;15 \u2192 true\n// 9. true&amp;&amp;true \u2192 true\n</code></pre> <pre><code>boolean result = 5 + 3 * 2 &lt; 15 &amp;&amp; (10 % 3 == 1 || 2 &lt;&lt; 3 &gt; 10);\n// Mismo orden que Kotlin\n</code></pre> <pre><code>result = 5 + 3 * 2 &lt; 15 and (10 % 3 == 1 or 2 &lt;&lt; 3 &gt; 10)\n# Orden similar pero con palabras clave\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#reglas-mnemotecnicas","title":"Reglas Mnemot\u00e9cnicas","text":"<ol> <li>PEMDAS (Para matem\u00e1ticas b\u00e1sicas):</li> <li>Par\u00e9ntesis</li> <li>Exponentes (<code>**</code> en Python)</li> <li>Multiplicaci\u00f3n/Divisi\u00f3n</li> <li> <p>Adici\u00f3n/Sustracci\u00f3n</p> </li> <li> <p>Bit a Bit:</p> </li> <li>Kotlin: <code>and</code>/<code>or</code>/<code>xor</code> antes que comparaciones</li> <li> <p>Java/Python: <code>&amp;</code>/<code>|</code> antes que <code>==</code></p> </li> <li> <p>L\u00f3gicos:</p> </li> <li><code>not</code>/<code>!</code> antes que <code>and</code>/<code>&amp;&amp;</code></li> <li><code>and</code>/<code>&amp;&amp;</code> antes que <code>or</code>/<code>||</code></li> </ol>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#casos-peligrosos","title":"Casos Peligrosos","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#kotlinjava-vs-python","title":"Kotlin/Java vs Python","text":"<pre><code>// Kotlin/Java\nval a = true &amp;&amp; false || true  // true (&amp;&amp; tiene mayor precedencia)\n// Equivale a: (true &amp;&amp; false) || true\n</code></pre> <pre><code># Python\na = True and False or True  # True (and tiene mayor precedencia)\n# Equivale a: (True and False) or True\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#operador-walrus","title":"Operador Walrus","text":"<pre><code># Correcto\nif (x := 5 + 3) &gt; 7: ...\n\n# Peligroso (diferente significado)\nif x := 5 + 3 &gt; 7: ...  # x ser\u00e1 True/False, no 8\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#recomendaciones","title":"Recomendaciones","text":"<ol> <li>Usar par\u00e9ntesis cuando:</li> <li>Combines operadores l\u00f3gicos y aritm\u00e9ticos</li> <li>Tengas dudas sobre el orden</li> <li> <p>Mejore la legibilidad</p> </li> <li> <p>Consistencia:</p> </li> <li>En Kotlin/Java preferir <code>&amp;&amp;</code>/<code>||</code></li> <li> <p>En Python usar <code>and</code>/<code>or</code></p> </li> <li> <p>Espaciado:    <pre><code>// \u274c Confuso\nval x=a+b*c-d\n\n// \u2705 Claro\nval x = a + b * c - d\n</code></pre></p> </li> </ol>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#14-casting-y-conversion-de-tipos","title":"1.4. Casting y Conversi\u00f3n de Tipos","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#conceptos-clave","title":"Conceptos Clave","text":"<pre><code>graph TD\n    A[Conversi\u00f3n] --&gt; B[Impl\u00edcita]\n    A --&gt; C[Expl\u00edcita]\n    B --&gt; D[Autom\u00e1tica]\n    C --&gt; E[Manual]</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#tabla-comparativa","title":"Tabla Comparativa","text":"Operaci\u00f3n Kotlin Java Python Conversi\u00f3n impl\u00edcita Limitada (solo promoci\u00f3n) Autom\u00e1tica (primitivos) Din\u00e1mica Conversi\u00f3n expl\u00edcita <code>.toXxx()</code> <code>(tipo)</code> <code>tipo()</code> Comprobaci\u00f3n de tipo <code>is</code> <code>instanceof</code> <code>isinstance()</code> Casting seguro <code>as?</code> - - String a n\u00famero <code>.toInt()</code> <code>Integer.parseInt()</code> <code>int()</code> N\u00famero a String <code>toString()</code> <code>String.valueOf()</code> <code>str()</code>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#kotlin","title":"Kotlin","text":"Kotlin <pre><code>fun main() {\n    // Conversi\u00f3n expl\u00edcita (no hay impl\u00edcita entre tipos diferentes)\n    val doubleVal: Double = 3.14\n    val intVal: Int = doubleVal.toInt() // 3\n\n    // Casting entre tipos (seguro con as?)\n    val obj: Any = \"Hola\"\n    val str: String? = obj as? String // Safe cast\n\n    // Comprobaci\u00f3n de tipo\n    if (obj is String) {\n        println(obj.length) // Smart cast autom\u00e1tico\n    }\n\n    // String a n\u00famero\n    val num = \"123\".toInt()\n}\n</code></pre> <p>Caracter\u00edsticas: - No hay conversi\u00f3n impl\u00edcita que cause p\u00e9rdida de precisi\u00f3n - M\u00e9todos <code>toXxx()</code> para conversiones - Smart casting autom\u00e1tico despu\u00e9s de comprobaciones</p>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#java","title":"Java","text":"Java <pre><code>public class Main {\n    public static void main(String[] args) {\n        // Conversi\u00f3n impl\u00edcita (promoci\u00f3n)\n        int intVal = 5;\n        double doubleVal = intVal; // 5.0\n\n        // Conversi\u00f3n expl\u00edcita (casting)\n        doubleVal = 3.14;\n        intVal = (int) doubleVal; // 3\n\n        // Comprobaci\u00f3n de tipo\n        Object obj = \"Hola\";\n        if (obj instanceof String) {\n            String str = (String) obj;\n            System.out.println(str.length());\n        }\n\n        // String a n\u00famero\n        int num = Integer.parseInt(\"123\");\n    }\n}\n</code></pre> <p>Particularidades: - Casting cl\u00e1sico con <code>(tipo)</code> - <code>instanceof</code> para comprobaci\u00f3n - Autoboxing entre primitivos y wrappers</p>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#python","title":"Python","text":"Python <pre><code>if __name__ == \"__main__\":\n    # Conversi\u00f3n impl\u00edcita din\u00e1mica\n    result = 3 + 2.5  # 5.5 (int -&gt; float)\n\n    # Conversi\u00f3n expl\u00edcita\n    int_val = int(3.14)  # 3\n    float_val = float(\"3.14\")\n\n    # Comprobaci\u00f3n de tipo\n    obj = \"Hola\"\n    if isinstance(obj, str):\n        print(len(obj))\n\n    # Casting entre objetos\n    class Padre: pass\n    class Hijo(Padre): pass\n\n    hijo = Hijo()\n    padre = Padre()\n    cast_hijo = hijo  # No necesita casting expl\u00edcito\n}\n</code></pre> <p>Caracter\u00edsticas: - Duck typing (m\u00e1s importante que el tipo) - Conversiones con constructores (<code>int()</code>, <code>str()</code>, etc.) - No hay casting expl\u00edcito entre objetos</p>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#conversiones-comunes","title":"Conversiones Comunes","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#1-numero-a-string","title":"1. N\u00famero a String","text":"<pre><code>// Kotlin\nval str = 123.toString()\n</code></pre> <pre><code>// Java\nString str = Integer.toString(123);\n</code></pre> <pre><code># Python\nstr_val = str(123)\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#2-string-a-numero","title":"2. String a N\u00famero","text":"<pre><code>// Kotlin\nval num = \"123\".toIntOrNull() ?: 0\n</code></pre> <pre><code>// Java\nint num = Integer.parseInt(\"123\");\n</code></pre> <pre><code># Python\nnum = int(\"123\")  # ValueError si falla\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#3-casting-entre-tipos-de-objetos","title":"3. Casting entre Tipos de Objetos","text":"<pre><code>// Kotlin (safe cast)\nval obj: Any = \"Hola\"\nval str: String? = obj as? String\n</code></pre> <pre><code>// Java (con comprobaci\u00f3n)\nObject obj = \"Hola\";\nif (obj instanceof String) {\n    String str = (String) obj;\n}\n</code></pre> <pre><code># Python (no necesario normalmente)\nobj = \"Hola\"\nif isinstance(obj, str):\n    str_val = obj  # No necesita casting\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#buenas-practicas","title":"Buenas Pr\u00e1cticas","text":"<ol> <li>En Kotlin:</li> <li>Prefiere <code>as?</code> sobre <code>as</code> para evitar <code>ClassCastException</code></li> <li> <p>Usa <code>toXxxOrNull()</code> para conversiones seguras</p> </li> <li> <p>En Java:</p> </li> <li>Siempre verificar con <code>instanceof</code> antes de casting</li> <li> <p>Usar <code>Integer.parseInt()</code> con try-catch</p> </li> <li> <p>En Python:</p> </li> <li>Prefiere <code>isinstance()</code> sobre type()</li> <li>Maneja <code>ValueError</code> en conversiones</li> </ol>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#rendimiento","title":"Rendimiento","text":"Operaci\u00f3n Kotlin Java Python String a Int ~50ns ~30ns ~100ns Double a Int ~10ns ~5ns ~50ns Comprobaci\u00f3n tipo ~5ns ~7ns ~20ns"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#casos-especiales","title":"Casos Especiales","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#kotlin-smart-cast","title":"Kotlin Smart Cast","text":"<pre><code>when (val response = getData()) {\n    is String -&gt; println(response.length)  // Auto-casted a String\n    is Int -&gt; println(response + 1)       // Auto-casted a Int\n}\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#java-pattern-matching-jdk-16","title":"Java Pattern Matching (JDK 16+)","text":"<pre><code>Object obj = \"Hola\";\nif (obj instanceof String str) {\n    System.out.println(str.length());\n}\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#python-duck-typing","title":"Python Duck Typing","text":"<pre><code>def procesar(item):\n    if hasattr(item, '__len__'):\n        return len(item)\n    return 0\n\nprocesar(\"Hola\")  # 4\nprocesar([1,2,3]) # 3\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#errores-comunes","title":"Errores Comunes","text":"<ol> <li> <p>Kotlin/Java:    <pre><code>val num = \"abc\".toInt()  // NumberFormatException\n</code></pre></p> </li> <li> <p>Java:    <pre><code>double d = 3.14;\nint i = d;  // Error: requiere casting expl\u00edcito\n</code></pre></p> </li> <li> <p>Python:    <pre><code>val = int(\"12a\")  # ValueError\n</code></pre></p> </li> </ol>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#15-variables-y-constantes","title":"1.5. Variables y constantes","text":"<p>A la hora de almacenar datos en memoria, debemos analizar c\u00f3mo vamos a utilizarlos. Si vamos a modificarlos, debemos utilizar variables, si no, debemos utilizar constantes. - Constantes: Son valores que no cambian durante la ejecuci\u00f3n del programa. Se declaran con la palabra reservada const/val. Son inmutables. - Variables: Son valores que cambian durante la ejecuci\u00f3n del programa. Se declaran con la palabra reservada var. Son mutables.</p> <p>Se debe aplicar c\u00f3digo limpio y buenas pr\u00e1cticas de programaci\u00f3n. para nombrarlas.</p> <p>Dependiendo del tipo de lenguaje, si es tipado o no, tendremos posibilidad de definir variables o constantes.</p> KotlinJavaPython <pre><code>// Variables mutables (pueden cambiar)\nvar variableMutable: Int = 10\nvariableMutable = 20  // Correcto\n\n// Variables inmutables (NO pueden cambiar)\nval variableInmutable: Int = 30\n// variableInmutable = 40  // Error de compilaci\u00f3n\n\n// Constantes (en tiempo de compilaci\u00f3n)\nconst val CONSTANTE: Int = 50\n// Deben ser inicializadas con un valor conocido en compilaci\u00f3n\n</code></pre> <pre><code>// Variables mutables\nint variableMutable = 10;\nvariableMutable = 20;  // Correcto\n\n// 'Constantes' (en realidad variables inmutables)\nfinal int variableInmutable = 30;\n// variableInmutable = 40;  // Error de compilaci\u00f3n\n\n// Constantes reales (static final)\nstatic final int CONSTANTE = 50;\n// Convenci\u00f3n: nombres en MAY\u00daSCULAS\n</code></pre> <pre><code># Variables mutables (por defecto todas lo son)\nvariable_mutable = 10\nvariable_mutable = 20  # Correcto\n\n# 'Constantes' (convenci\u00f3n, no realmente inmutables)\nCONSTANTE = 30  # Por convenci\u00f3n se usa MAY\u00daSCULAS\nCONSTANTE = 40  # Funciona, pero no deber\u00eda hacerse\n\n# No hay verdadera inmutabilidad para variables simples\n# Para estructuras complejas, usar:\nfrom typing import Final\nCONSTANTE_REAL: Final[int] = 50  # Python 3.8+\n# Aunque t\u00e9cnicamente puede cambiarse, linters avisan\n</code></pre> Definiciones precisas <ul> <li> Kotlin:<ol> <li>var: Variable mutable (puede reasignarse)</li> <li>val: Variable inmutable (solo asignaci\u00f3n inicial)</li> <li>const val: Constante real (valor conocido en compilaci\u00f3n)</li> </ol> </li> <li> Java:<ol> <li>Variables normales: mutables por defecto</li> <li>final: Hace la variable inmutable (solo para primitivos y referencias)</li> <li>static final: Constante real (compartida por todas las instancias)</li> </ol> </li> <li> Python:<ol> <li>Todas las variables son mutables por defecto</li> <li>No tiene verdaderas constantes, solo convenciones (nombres en MAY\u00daSCULAS)</li> <li>Desde Python 3.8: <code>Final</code> (solo para linters, no impide modificaci\u00f3n)</li> </ol> </li> <li> Importante<ul> <li>En Java no existen verdaderas \"constantes\" como en Kotlin, solo variables inmutables (final). Las constantes se simulan con static final.</li> <li>En Python no hay inmutabilidad real para variables simples, solo convenciones y anotaciones para linters. La inmutabilidad solo existe para algunos tipos como tuplas.</li> </ul> </li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#16-conversiones-de-tipo-kotlin-vs-java-vs-python","title":"1.6. Conversiones de Tipo (Kotlin vs Java vs Python)","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#tabla-comparativa-rapida","title":"Tabla Comparativa R\u00e1pida","text":"Operaci\u00f3n Kotlin Java Python Casting expl\u00edcito <code>as</code>, <code>toXxx()</code> <code>(tipo)</code> <code>tipo()</code> Conversi\u00f3n impl\u00edcita M\u00ednima Primitivos Din\u00e1mica String a n\u00famero <code>toIntOrNull()</code> <code>Integer.parseInt()</code> <code>int()</code> N\u00famero a String <code>toString()</code> <code>String.valueOf()</code> <code>str()</code> Char a c\u00f3digo <code>code</code> Cast a <code>int</code> <code>ord()</code> C\u00f3digo a Char <code>toChar()</code> Cast a <code>char</code> <code>chr()</code> Divisi\u00f3n exacta <code>/</code> (con al menos un float) <code>(double)</code> o <code>* 1.0</code> <code>/</code> (siempre float)"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#1-conversiones-numericas","title":"1. Conversiones Num\u00e9ricas","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#casting-explicito","title":"Casting Expl\u00edcito","text":"KotlinJavaPython <pre><code>val bigNum = 65633\nval c: Char = bigNum.toChar()  // 'a' (truncamiento)\nval f = 97.53f\nval c2 = f.toChar()  // 'a' (sin decimales)\nval pi = 3.14159f\nval i = pi.toInt()  // 3 (truncamiento)\n</code></pre> <pre><code>int bigNum = 65633;\nchar c = (char) bigNum;  // 'a'\nfloat f = 97.53f;\nchar c2 = (char) f;  // 'a'\nfloat pi = 3.14159f;\nint i = (int) pi;  // 3\n</code></pre> <pre><code>big_num = 65633\nc = chr(big_num)  # '\u1f81' (no hay truncamiento autom\u00e1tico)\nf = 97.53\nc2 = chr(int(f))  # 'a' (requiere int expl\u00edcito)\npi = 3.14159\ni = int(pi)  # 3\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#division-de-enteros","title":"Divisi\u00f3n de Enteros","text":"KotlinJavaPython <pre><code>val wrong = 5 / 2      // 2 (divisi\u00f3n entera)\nval correct = 5 / 2.0  // 2.5 (al menos un double)\n</code></pre> <pre><code>int wrong = 5 / 2;     // 2\ndouble correct = (double) 5 / 2;  // 2.5\n</code></pre> <pre><code>wrong = 5 / 2    # 2.5 (siempre float en Python 3)\ncorrect = 5 // 2  # 2 (divisi\u00f3n entera expl\u00edcita)\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#2-conversiones-textuales","title":"2. Conversiones Textuales","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#a-string","title":"A String","text":"KotlinJavaPython <pre><code>val s1 = 'a'.toString()  // \"a\"\nval s2 = 865.toString()   // \"865\"\nval s3 = true.toString()  // \"true\"\n</code></pre> <pre><code>String s1 = String.valueOf('a');  // \"a\"\nString s2 = String.valueOf(865);  // \"865\"\nString s3 = \"\" + true;            // \"true\"\n</code></pre> <pre><code>s1 = str('a')    # 'a'\ns2 = str(865)    # '865'\ns3 = str(True)   # 'True'\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#de-string","title":"De String","text":"KotlinJavaPython <pre><code>val c = \"java\"[0]  // 'j' (operador de \u00edndice)\nval num = \"213\".toIntOrNull()  // 213 o null\nval f = \"23.78\".toFloatOrNull() // 23.78f o null\n</code></pre> <pre><code>char c = \"java\".charAt(0);  // 'j'\nint num = Integer.parseInt(\"213\");  // 213\nfloat f = Float.parseFloat(\"23.78\"); // 23.78f\n</code></pre> <pre><code>c = \"java\"[0]       # 'j'\nnum = int(\"213\")    # 213\nf = float(\"23.78\")  # 23.78\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#3-conversiones-de-caracteres","title":"3. Conversiones de Caracteres","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#char-codigo","title":"Char \u2194 C\u00f3digo","text":"KotlinJavaPython <pre><code>val code = '9'.code      // 57 (Unicode)\nval char = 57.toChar()   // '9'\n</code></pre> <pre><code>int code = '9';         // 57\nchar c = (char) 57;     // '9'\n</code></pre> <pre><code>code = ord('9')  # 57\nchar = chr(57)   # '9'\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#4-operaciones-matematicas-avanzadas","title":"4. Operaciones Matem\u00e1ticas Avanzadas","text":"KotlinJavaPython <pre><code>import kotlin.math.*\nval potencia = 3.0.pow(3)  // 27.0\nval raiz = sqrt(9.0)        // 3.0\n</code></pre> <pre><code>import java.lang.Math;\ndouble potencia = Math.pow(3, 3);  // 27.0\ndouble raiz = Math.sqrt(9);        // 3.0\n</code></pre> <pre><code>import math\npotencia = math.pow(3, 3)  # 27.0\nraiz = math.sqrt(9)        # 3.0\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#buenas-practicas-cruzadas","title":"Buenas Pr\u00e1cticas Cruzadas","text":"<ol> <li>Manejo de errores:</li> <li>Kotlin: Usar <code>toIntOrNull()</code></li> <li>Java: Usar <code>try-catch</code> con <code>NumberFormatException</code></li> <li> <p>Python: Usar <code>try-except</code> con <code>ValueError</code></p> </li> <li> <p>Precisi\u00f3n num\u00e9rica:</p> </li> <li>Evitar casting innecesario que cause p\u00e9rdida de precisi\u00f3n</li> <li> <p>Usar tipos adecuados (Double en Kotlin/Java, float en Python)</p> </li> <li> <p>Legibilidad:    <pre><code>// \u274c Poco claro\nval x = y.toString().toFloat()\n\n// \u2705 Mejor\nval x = y.toFloat()\n</code></pre></p> </li> </ol>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#rendimiento-comparativo","title":"Rendimiento Comparativo","text":"Operaci\u00f3n Kotlin Java Python String a Int ~50ns ~30ns ~100ns Double a Int ~10ns ~5ns ~50ns Math.pow() ~80ns ~100ns ~120ns"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#casos-especiales_1","title":"Casos Especiales","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#kotlin-smart-cast_1","title":"Kotlin (Smart Cast)","text":"<pre><code>when(val input: Any = getUserInput()) {\n    is String -&gt; println(input.length)  // Auto-casting\n    is Int -&gt; println(input + 1)\n}\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#java-pattern-matching","title":"Java (Pattern Matching)","text":"<pre><code>Object obj = \"Hola\";\nif(obj instanceof String s) {\n    System.out.println(s.length());  // s ya casteada\n}\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#python-duck-typing_1","title":"Python (Duck Typing)","text":"<pre><code>def process(value):\n    if isinstance(value, (int, float)):\n        return value * 2\n    return str(value) * 2\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#17-operaciones-con-strings-kotlin-vs-java-vs-python","title":"1.7. Operaciones con Strings (Kotlin vs Java vs Python)","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#tabla-comparativa-rapida_1","title":"Tabla Comparativa R\u00e1pida","text":"Operaci\u00f3n Kotlin Java Python Concatenaci\u00f3n <code>+</code>, <code>\"$var\"</code> <code>+</code> <code>+</code>, <code>f-string</code> Longitud <code>length</code> <code>length()</code> <code>len()</code> Acceso a car\u00e1cter <code>[index]</code> <code>charAt(index)</code> <code>[index]</code> B\u00fasqueda <code>indexOf()</code> <code>indexOf()</code> <code>find()</code>, <code>index()</code> Contenido <code>contains()</code> <code>contains()</code> <code>in</code> May\u00fasculas/min\u00fasculas <code>uppercase()</code>/<code>lowercase()</code> <code>toUpperCase()</code>/<code>toLowerCase()</code> <code>upper()</code>/<code>lower()</code> Reemplazo <code>replace()</code> <code>replace()</code> <code>replace()</code> Subcadena <code>substring()</code> <code>substring()</code> <code>[start:end]</code> Divisi\u00f3n <code>split()</code> <code>split()</code> <code>split()</code> Comparaci\u00f3n <code>==</code> (content), <code>equals()</code> <code>equals()</code> <code>==</code> Comparaci\u00f3n alfab\u00e9tica <code>compareTo()</code> <code>compareTo()</code> <code>sorted()</code>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#ejemplos-detallados","title":"Ejemplos Detallados","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#1-concatenacion","title":"1. Concatenaci\u00f3n","text":"KotlinJavaPython <pre><code>val texto1 = \"Hola\"\nval texto2 = \"Mundo\"\nval concatenado = \"$texto1 $texto2\"  // Interpolaci\u00f3n\nval concatenado2 = texto1 + \" \" + texto2\n</code></pre> <pre><code>String texto1 = \"Hola\";\nString texto2 = \"Mundo\";\nString concatenado = texto1 + \" \" + texto2;\n</code></pre> <pre><code>texto1 = \"Hola\"\ntexto2 = \"Mundo\"\nconcatenado = f\"{texto1} {texto2}\"  # f-string\nconcatenado2 = texto1 + \" \" + texto2\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#2-longitud-y-acceso","title":"2. Longitud y Acceso","text":"KotlinJavaPython <pre><code>val texto = \"Kotlin\"\nval longitud = texto.length  // 6\nval primerChar = texto[0]    // 'K'\n</code></pre> <pre><code>String texto = \"Java\";\nint longitud = texto.length();  // 4\nchar primerChar = texto.charAt(0); // 'J'\n</code></pre> <pre><code>texto = \"Python\"\nlongitud = len(texto)  # 6\nprimer_char = texto[0] # 'P'\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#3-busqueda-y-contenido","title":"3. B\u00fasqueda y Contenido","text":"KotlinJavaPython <pre><code>val texto = \"Aprendiendo Kotlin\"\nval pos = texto.indexOf(\"Kotlin\")  // 11\nval contiene = texto.contains(\"die\") // true\n</code></pre> <pre><code>String texto = \"Aprendiendo Java\";\nint pos = texto.indexOf(\"Java\");  // 12\nboolean contiene = texto.contains(\"die\"); // true\n</code></pre> <pre><code>texto = \"Aprendiendo Python\"\npos = texto.find(\"Python\")  # 12\ncontiene = \"die\" in texto   # True\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#4-transformacion","title":"4. Transformaci\u00f3n","text":"KotlinJavaPython <pre><code>val texto = \"Hola\"\nval mayus = texto.uppercase()  // \"HOLA\"\nval minus = texto.lowercase()  // \"hola\"\nval reemplazado = texto.replace(\"H\", \"J\") // \"Jola\"\n</code></pre> <pre><code>String texto = \"Hola\";\nString mayus = texto.toUpperCase();  // \"HOLA\"\nString minus = texto.toLowerCase();  // \"hola\"\nString reemplazado = texto.replace(\"H\", \"J\"); // \"Jola\"\n</code></pre> <pre><code>texto = \"Hola\"\nmayus = texto.upper()  # \"HOLA\"\nminus = texto.lower()  # \"hola\"\nreemplazado = texto.replace(\"H\", \"J\") # \"Jola\"\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#5-subcadenas-y-division","title":"5. Subcadenas y Divisi\u00f3n","text":"KotlinJavaPython <pre><code>val texto = \"Kotlin es genial\"\nval sub = texto.substring(7..9)  // \"es\"\nval partes = texto.split(\" \")    // [\"Kotlin\", \"es\", \"genial\"]\n</code></pre> <pre><code>String texto = \"Java es genial\";\nString sub = texto.substring(5, 7);  // \"es\"\nString[] partes = texto.split(\" \");  // {\"Java\", \"es\", \"genial\"}\n</code></pre> <pre><code>texto = \"Python es genial\"\nsub = texto[7:9]  # \"es\"\npartes = texto.split(\" \")  # ['Python', 'es', 'genial']\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#6-comparacion","title":"6. Comparaci\u00f3n","text":"KotlinJavaPython <pre><code>val texto = \"Hola\"\nval igual = texto == \"Hola\"  // true (compara contenido)\nval orden = texto.compareTo(\"Adios\")  // &gt; 0\n</code></pre> <pre><code>String texto = \"Hola\";\nboolean igual = texto.equals(\"Hola\");  // true\nint orden = texto.compareTo(\"Adios\");  // &gt; 0\n</code></pre> <pre><code>texto = \"Hola\"\nigual = texto == \"Hola\"  # True\norden = sorted([texto, \"Adios\"])  # ['Adios', 'Hola']\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#18-funciones-especiales-por-lenguaje","title":"1.8. Funciones Especiales por Lenguaje","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#kotlin_1","title":"Kotlin","text":"<pre><code>val texto = \"  Kotlin  \"\nval trim = texto.trim()  // Elimina espacios\nval multiLinea = \"\"\"\n    Esto es\n    un texto\n    multil\u00ednea\n\"\"\".trimIndent()\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#java_1","title":"Java","text":"<pre><code>String texto = \"  Java  \";\nString trim = texto.trim();\nboolean vacio = texto.isEmpty();\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#python_1","title":"Python","text":"<pre><code>texto = \"  Python  \"\ntrim = texto.strip()\nformato = \"{} es {}\".format(\"Python\", \"genial\")\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#rendimiento-comparativo_1","title":"Rendimiento Comparativo","text":"Operaci\u00f3n Kotlin Java Python Concatenaci\u00f3n ~50ns ~40ns ~60ns B\u00fasqueda ~80ns ~70ns ~100ns Substring ~30ns ~25ns ~45ns"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#buenas-practicas_1","title":"Buenas Pr\u00e1cticas","text":"<ol> <li>Concatenaci\u00f3n en bucles:</li> <li>Kotlin/Java: Usar <code>StringBuilder</code></li> <li> <p>Python: Usar <code>join()</code></p> </li> <li> <p>Comparaci\u00f3n de contenido:</p> </li> <li>Kotlin: <code>==</code> es seguro (equivale a <code>equals()</code>)</li> <li>Java: Siempre usar <code>equals()</code></li> <li> <p>Python: <code>==</code> compara contenido</p> </li> <li> <p>Manejo de nulos:    <pre><code>val s: String? = null\nval length = s?.length ?: 0  // Safe call + Elvis\n</code></pre></p> </li> <li> <p>Strings multil\u00ednea:</p> </li> <li>Kotlin: Text blocks con <code>\"\"\"</code></li> <li>Java 15+: Text blocks con <code>\"\"\"</code></li> <li>Python: <code>\"\"\"</code> o <code>'''</code></li> </ol>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#19-comentarios","title":"1.9. Comentarios","text":"<p>Los comentarios son fragmentos de c\u00f3digo que no se ejecutan. Se usan para documentar el c\u00f3digo y explicar lo que hace. Pueden ser de una l\u00ednea o de varias. </p> KotlinJavaPython <pre><code>// Esto es un comentario de una l\u00ednea en Kotlin\n\n/*\n   Esto es un comentario multil\u00ednea\n   que puede abarcar varias l\u00edneas\n   en Kotlin\n*/\n\n/**\n * Esto es un comentario de documentaci\u00f3n KDoc\n * usado para documentar clases, funciones, etc.\n * @param nombre Descripci\u00f3n del par\u00e1metro\n * @return Descripci\u00f3n del retorno\n */\nfun ejemplo(nombre: String): Int {\n    return nombre.length\n}\n</code></pre> <pre><code>// Esto es un comentario de una l\u00ednea en Java\n\n/*\n   Esto es un comentario multil\u00ednea\n   que puede abarcar varias l\u00edneas\n   en Java\n*/\n\n/**\n * Esto es un comentario Javadoc\n * usado para documentaci\u00f3n formal\n * @param nombre Descripci\u00f3n del par\u00e1metro\n * @return Descripci\u00f3n del valor de retorno\n */\npublic int ejemplo(String nombre) {\n    return nombre.length();\n}\n</code></pre> <pre><code># Esto es un comentario de una l\u00ednea en Python\n\n\"\"\"\nEsto es un docstring (usado como comentario multil\u00ednea)\nPero t\u00e9cnicamente es una cadena de documentaci\u00f3n\nque Python asigna a __doc__\n\"\"\"\n\n'''\nTambi\u00e9n se pueden usar comillas simples\npara docstrings multil\u00ednea\n'''\n\ndef ejemplo(nombre):\n    \"\"\"\n    Esto es un docstring de funci\u00f3n\n    :param nombre: Descripci\u00f3n del par\u00e1metro\n    :return: Descripci\u00f3n del retorno\n    \"\"\"\n    return len(nombre)\n</code></pre> Diferencias <ul> <li> Comentarios de una l\u00ednea:<ol> <li>Kotlin y Java usan //</li> <li>Python usa #</li> </ol> </li> <li> Comentarios multil\u00ednea:<ol> <li>Kotlin y Java usan / /</li> <li>Python usa triples comillas (\"\"\" o ''') aunque t\u00e9cnicamente son docstrings</li> </ol> </li> <li> Documentaci\u00f3n:<ol> <li>Kotlin usa KDoc (/* /)</li> <li>Java usa Javadoc (/* /)</li> <li>Python usa docstrings (\"\"\")</li> </ol> </li> <li> Caracter\u00edsticas especiales:<ul> <li>En Python, los docstrings son accesibles en tiempo de ejecuci\u00f3n mediante doc</li> <li>Los comentarios de documentaci\u00f3n en Kotlin y Java son procesados por herramientas externas</li> <li>Solo los docstrings de Python pueden contener markup (reStructuredText o Google style)</li> </ul> </li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#2-algoritmo","title":"2. Algoritmo","text":"<p>Un algoritmo es una secuencia ordenada de pasos que conducen a la soluci\u00f3n de un problema. Tienen tres caracter\u00edsticas:</p> <ul> <li>Son precisos en el orden de realizaci\u00f3n de los pasos.</li> <li>Est\u00e1n bien definidos de forma que usando un algoritmo varias veces con los mismos datos, d\u00e9 la misma soluci\u00f3n.</li> <li>Son finitos, deben acabarse en alg\u00fan momento.</li> </ul> <p>Los algoritmos deben representarse de forma independiente del lenguaje de programaci\u00f3n que luego usaremos.</p> <p>Usaremos ordinogramas o diagramas de flujo para representarlos y pseudoc\u00f3digo</p> <p></p> <p>Algoritmo de comprobaci\u00f3n n\u00fameros par/impar</p> <pre><code>flowchart TD\n    A[Inicio] --&gt; B[\"Introduce n\u00famero (n)\"]\n    B --&gt; C{\"n % 2 == 0?\"}\n    C -- S\u00ed --&gt; D[\"El n\u00famero es par\"]\n    C -- No --&gt; E[\"El n\u00famero es impar\"]\n    D --&gt; F[Fin]\n    E --&gt; F</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#3-programacion-estructurada","title":"3. Programaci\u00f3n Estructurada","text":"<p>La programaci\u00f3n estructurada es un paradigma de programaci\u00f3n que se basa en la estructuraci\u00f3n de los programas en tres elementos b\u00e1sicos:</p> <ul> <li>Secuencia: Los programas se ejecutan secuencialmente, es decir, una instrucci\u00f3n tras otra.</li> <li>Condicionales: Los programas pueden ejecutar una parte de c\u00f3digo u otra dependiendo de una condici\u00f3n.</li> <li>Repetitivas: Los programas pueden ejecutar una parte de c\u00f3digo varias veces.</li> </ul> <p></p>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#4-secuencias","title":"4. Secuencias","text":"<p>Las secuencias son la base de la programaci\u00f3n estructurada. Se ejecutan una tras otra, de arriba a abajo. </p>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#41-ejemplos-de-ejecucion-secuencial-sin-pereza","title":"4.1 Ejemplos de Ejecuci\u00f3n Secuencial (sin pereza)","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#kotlin-ejecucion-inmediata","title":"Kotlin (Ejecuci\u00f3n inmediata)","text":"Kotlin <pre><code>fun main() {\n    println(\"Hola\")\n    println(\"\u00bfC\u00f3mo est\u00e1s?\")\n    val nombre = readln() // Bloquea aqu\u00ed\n    println(\"Encantado, $nombre\")\n}\n</code></pre> <p>Caracter\u00edsticas:</p> <ul> <li>\u26a1 Ejecuci\u00f3n lineal e inmediata</li> <li>\ud83d\uded1 Bloquea en <code>readln()</code> hasta entrada del usuario</li> <li>\ud83c\udfce\ufe0f M\u00e1s simple para scripts peque\u00f1os</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#java-flujo-clasico","title":"Java (Flujo cl\u00e1sico)","text":"Java <pre><code>import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Hola\");\n        System.out.println(\"\u00bfC\u00f3mo est\u00e1s?\");\n        Scanner scanner = new Scanner(System.in);\n        String nombre = scanner.nextLine(); // Bloqueo aqu\u00ed\n        System.out.println(\"Encantado, \" + nombre);\n    }\n}\n</code></pre> <p>Notas:</p> <ul> <li>\ud83e\uddf1 Estructura cl\u00e1sica imperativa</li> <li>\ud83d\udce6 Requiere manejo expl\u00edcito de <code>Scanner</code></li> <li>\u23f1\ufe0f Todo se ejecuta en orden estricto</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#python-script-lineal","title":"Python (Script lineal)","text":"Python <pre><code>print(\"Hola\")\nprint(\"\u00bfC\u00f3mo est\u00e1s?\")\nnombre = input()  # Bloquea aqu\u00ed\nprint(f\"Encantado, {nombre}\")\n</code></pre> <p>Ventajas:</p> <ul> <li>\ud83d\udc0d Sintaxis minimalista</li> <li>\ud83d\udcdc Comportamiento predecible</li> <li>\ud83d\udd22 F\u00e1cil de depurar</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#comparativa-de-enfoques","title":"Comparativa de enfoques","text":"Caracter\u00edstica Kotlin Java Python Lectura de entrada <code>readln()</code> <code>Scanner</code> <code>input()</code> Interpolaci\u00f3n <code>$variable</code> <code>+</code> concatenaci\u00f3n <code>f-string</code> Bloqueo S\u00ed S\u00ed S\u00ed Tama\u00f1o del c\u00f3digo Compacto Verboso M\u00ednimo <p>Nota: Estos ejemplos son ideales cuando necesitas:</p> <ul> <li>Simplicidad en l\u00f3gica lineal</li> <li>Comportamiento predecible paso a paso</li> <li>Scripts peque\u00f1os o de un solo uso</li> </ul> <p>Los ejemplos de fragmentos de c\u00f3digo anteriores, son un ejemplo de ejecuci\u00f3n secuencial de instrucciones. En Kotlin, las Sequence son un tipo especial de colecci\u00f3n perezosa (lazy) similar a los Stream de Java o los generadores de Python.</p>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#42-ejemplos-de-secuencias-kotlin-vs-java-vs-python","title":"4.2 Ejemplos de Secuencias (Kotlin vs Java vs Python)","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#kotlin-sequence","title":"Kotlin (Sequence)","text":"Kotlin <pre><code>fun main() {\n    val sequence = sequence {\n        yield(\"Hola\")\n        yield(\"\u00bfC\u00f3mo est\u00e1s?\")\n        val nombre = readln()\n        yield(\"Encantado, $nombre\")\n    }\n\n    sequence.forEach { println(it) }\n}\n</code></pre> <p>Caracter\u00edsticas:</p> <ul> <li>\u23f3 Evaluaci\u00f3n perezosa con <code>yield</code></li> <li>\ud83d\udd04 Consumo con <code>forEach</code></li> <li>\ud83e\udde9 Ideal para flujos de datos grandes o infinitos</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#java-stream","title":"Java (Stream)","text":"Java <pre><code>import java.util.stream.Stream;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Stream&lt;String&gt; stream = Stream.of(\n            \"Hola\",\n            \"\u00bfC\u00f3mo est\u00e1s?\",\n            \"Encantado, \" + new Scanner(System.in).nextLine()\n        );\n\n        stream.forEach(System.out::println);\n    }\n}\n</code></pre> <p>Notas:</p> <ul> <li>\u26a0 Los Streams de Java son de un solo uso</li> <li>\ud83d\udd04 Similar a Kotlin pero con API m\u00e1s verbosa</li> <li>\ud83d\udeab No tiene equivalente exacto a <code>yield</code></li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#python-generadores","title":"Python (Generadores)","text":"Python <pre><code>def generador_saludos():\n    yield \"Hola\"\n    yield \"\u00bfC\u00f3mo est\u00e1s?\"\n    nombre = input()\n    yield f\"Encantado, {nombre}\"\n\nfor mensaje in generador_saludos():\n    print(mensaje)\n</code></pre> <p>Diferencias:</p> <ul> <li>\ud83d\udc0d Sintaxis m\u00e1s minimalista</li> <li>\ud83d\udd04 Usa <code>yield</code> como Kotlin</li> <li>\u2705 M\u00e1s cercano al modelo de Kotlin que Java</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#comparativa","title":"Comparativa","text":"Feature Kotlin (Sequence) Java (Stream) Python (Generator) Evaluaci\u00f3n perezosa \u2705 \u2705 \u2705 Reutilizable \u274c (a menos que se convierta a lista) \u274c \u274c Sintaxis <code>yield</code> \u2705 \u274c \u2705 Infinito \u2705 \u2705 \u2705"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#5-condicionales","title":"5. Condicionales","text":"<p>Los condicionales nos permiten ejecutar una parte de c\u00f3digo u otra dependiendo de una condici\u00f3n. </p> <p>Pueden ser: - Condicionales simples: Se ejecuta una parte de c\u00f3digo u otra dependiendo de una condici\u00f3n (if). La parte de c\u00f3digo que se ejecuta se llama rama verdadera y la otra rama falsa. La parte asociada a else es opcional.</p>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#51-ejemplo-de-condicional-simple","title":"5.1. Ejemplo de Condicional Simple","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#kotlin_2","title":"Kotlin","text":"Kotlin <pre><code>fun main() {\n    val edadAlumno = 20 // Puedes cambiar este valor\n\n    // Condicional simple\n    if (edadAlumno &gt;= 18) {\n        println(\"Eres mayor de edad\")\n    } else {\n        println(\"Eres menor de edad\")\n    }\n}\n</code></pre> <p>Caracter\u00edsticas Kotlin:</p> <ul> <li>Sintaxis limpia y concisa</li> <li>No requiere par\u00e9ntesis en la condici\u00f3n (opcional)</li> <li><code>println</code> es la funci\u00f3n est\u00e1ndar para imprimir</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#java_2","title":"Java","text":"Java <pre><code>public class Main {\n    public static void main(String[] args) {\n        int edadAlumno = 20; // Puedes cambiar este valor\n\n        // Condicional simple\n        if (edadAlumno &gt;= 18) {\n            System.out.println(\"Eres mayor de edad\");\n        } else {\n            System.out.println(\"Eres menor de edad\");\n        }\n    }\n}\n</code></pre> <p>Diferencias Java:</p> <ul> <li>Requiere clase <code>Main</code> y m\u00e9todo <code>main</code></li> <li>Punto y coma obligatorio</li> <li><code>System.out.println</code> para imprimir</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#python_2","title":"Python","text":"Python <pre><code>edad_alumno = 20  # Puedes cambiar este valor\n\n# Condicional simple\nif edad_alumno &gt;= 18:\n    print(\"Eres mayor de edad\")\nelse:\n    print(\"Eres menor de edad\")\n</code></pre> <p>Caracter\u00edsticas Python:</p> <ul> <li>Sintaxis basada en indentaci\u00f3n</li> <li>No requiere llaves</li> <li>Dos puntos (<code>:</code>) despu\u00e9s de la condici\u00f3n</li> <li>Guiones bajos en nombres de variables por convenci\u00f3n</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#comparativa-de-sintaxis","title":"Comparativa de Sintaxis","text":"Elemento Kotlin Java Python Declaraci\u00f3n variable <code>val nombre = valor</code> <code>tipo nombre = valor</code> <code>nombre = valor</code> Estructura <code>if</code> <code>if (condici\u00f3n) { }</code> <code>if (condici\u00f3n) { }</code> <code>if condici\u00f3n:</code> Imprimir en consola <code>println()</code> <code>System.out.println()</code> <code>print()</code> Bloques de c\u00f3digo Llaves <code>{ }</code> Llaves <code>{ }</code> Indentaci\u00f3n - Condicionales m\u00faltiples: Pueden tener varios casos (if-else-if-else). Se ejecuta una parte de c\u00f3digo u otra dependiendo de una condici\u00f3n."},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#52-ejemplo-de-condicionales-multiples","title":"5.2. Ejemplo de Condicionales M\u00faltiples","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#kotlin_3","title":"Kotlin","text":"Kotlin <pre><code>fun main() {\n    val edadAlumno = 17 // Cambia este valor para probar\n\n    // Condicional m\u00faltiple\n    if (edadAlumno &gt;= 18) {\n        println(\"Eres mayor de edad\")\n    } else if (edadAlumno &gt;= 16) {\n        println(\"Casi eres mayor de edad\")\n    } else {\n        println(\"Eres menor de edad\")\n    }\n}\n</code></pre> <p>Caracter\u00edsticas:</p> <ul> <li><code>else if</code> para condiciones intermedias</li> <li>Evaluaci\u00f3n en cascada (de arriba hacia abajo)</li> <li>Bloques delimitados por llaves</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#java_3","title":"Java","text":"Java <pre><code>public class Main {\n    public static void main(String[] args) {\n        int edadAlumno = 17; // Cambia este valor para probar\n\n        if (edadAlumno &gt;= 18) {\n            System.out.println(\"Eres mayor de edad\");\n        } else if (edadAlumno &gt;= 16) {\n            System.out.println(\"Casi eres mayor de edad\");\n        } else {\n            System.out.println(\"Eres menor de edad\");\n        }\n    }\n}\n</code></pre> <p>Notas:</p> <ul> <li>Misma estructura que Kotlin pero m\u00e1s verboso</li> <li>Requiere punto y coma despu\u00e9s de cada sentencia</li> <li><code>System.out.println</code> en lugar de <code>println</code></li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#python_3","title":"Python","text":"Python <pre><code>edad_alumno = 17  # Cambia este valor para probar\n\nif edad_alumno &gt;= 18:\n    print(\"Eres mayor de edad\")\nelif edad_alumno &gt;= 16:\n    print(\"Casi eres mayor de edad\")\nelse:\n    print(\"Eres menor de edad\")\n</code></pre> <p>Diferencias:</p> <ul> <li><code>elif</code> en lugar de <code>else if</code></li> <li>Sin par\u00e9ntesis en la condici\u00f3n (opcionales)</li> <li>Indentaci\u00f3n obligatoria (4 espacios recomendados)</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#tabla-comparativa_1","title":"Tabla Comparativa","text":"Caso de Prueba Kotlin Java Python <code>edadAlumno = 20</code> \"Mayor de edad\" \"Mayor de edad\" \"Mayor de edad\" <code>edadAlumno = 17</code> \"Casi mayor\" \"Casi mayor\" \"Casi mayor\" <code>edadAlumno = 15</code> \"Menor de edad\" \"Menor de edad\" \"Menor de edad\" <pre><code>graph TD\n    A[Inicio] --&gt; B{edad &gt;= 18?}\n    B --&gt;|S\u00ed| C[\"Mayor de edad\"]\n    B --&gt;|No| D{edad &gt;= 16?}\n    D --&gt;|S\u00ed| E[\"Casi mayor\"]\n    D --&gt;|No| F[\"Menor de edad\"]</code></pre> <p>Flujo de ejecuci\u00f3n:</p> <ol> <li>Eval\u00faa la primera condici\u00f3n (<code>&gt;= 18</code>)</li> <li>Si es falsa, eval\u00faa la segunda (<code>&gt;= 16</code>)</li> <li>Si todas son falsas, ejecuta el <code>else</code></li> </ol> <p>Tambien podemos usar switch-case o when para simplificar el if else y evitar efecto Hoduken.</p>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#53-condicionales-con-whenswitch-alternativa-a-if-else","title":"5.3. Condicionales con When/Switch (Alternativa a If-Else)","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#kotlin-when","title":"Kotlin (When)","text":"Kotlin (When) <pre><code>fun main() {\n    val edadAlumno = 17 // Cambia este valor para probar\n\n    // Versi\u00f3n con when (equivalente a switch pero m\u00e1s potente)\n    when {\n        edadAlumno &gt;= 18 -&gt; println(\"Eres mayor de edad\")\n        edadAlumno &gt;= 16 -&gt; println(\"Casi eres mayor de edad\")\n        else -&gt; println(\"Eres menor de edad\")\n    }\n\n    // Versi\u00f3n con rangos (m\u00e1s idiom\u00e1tico)\n    when (edadAlumno) {\n        in 18..Int.MAX_VALUE -&gt; println(\"Mayor de edad\")\n        in 16..17 -&gt; println(\"Casi mayor\")\n        else -&gt; println(\"Menor de edad\")\n    }\n}\n</code></pre> <p>Ventajas:</p> <ul> <li>\u2795 M\u00e1s legible que m\u00faltiples <code>if-else</code></li> <li>\ud83d\udd0d Soporta rangos (<code>in x..y</code>)</li> <li>\ud83e\udde9 Puede devolver valores (\u00fatil en asignaciones)</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#java-switch-expression","title":"Java (Switch Expression)","text":"Java (Switch) <pre><code>public class Main {\n    public static void main(String[] args) {\n        int edadAlumno = 17;\n\n        // Switch tradicional (Java 8+)\n        switch (edadAlumno) {\n            case 18: System.out.println(\"Mayor de edad\"); break;\n            case 16: System.out.println(\"Casi mayor\"); break;\n            default: System.out.println(\"Menor de edad\");\n        }\n\n        // Switch expression (Java 12+)\n        String mensaje = switch (edadAlumno) {\n            case 18 -&gt; \"Mayor de edad\";\n            case 16 -&gt; \"Casi mayor\";\n            default -&gt; \"Menor de edad\";\n        };\n        System.out.println(mensaje);\n    }\n}\n</code></pre> <p>Limitaciones:</p> <ul> <li>\ud83d\udeab No soporta rangos directamente</li> <li>\u26a0 Requiere <code>break</code> en versiones antiguas</li> <li>\u2795 Mejorado en Java 12+ con expresiones</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#python-match-case","title":"Python (Match-Case)","text":"Python (Match) <pre><code>edad_alumno = 17\n\n# Alternativa tradicional (no hay switch en Python &lt; 3.10)\ndef clasificar_edad(edad):\n    if edad &gt;= 18: return \"Mayor\"\n    elif edad &gt;= 16: return \"Casi mayor\"\n    else: return \"Menor\"\nprint(clasificar_edad(edad_alumno))\n\n# Match-case (Python 3.10+)\nmatch edad_alumno:\n    case _ if edad_alumno &gt;= 18: print(\"Mayor de edad\")\n    case _ if edad_alumno &gt;= 16: print(\"Casi mayor\")\n    case _: print(\"Menor de edad\")\n</code></pre> <p>Notas:</p> <ul> <li>\ud83d\udc0d <code>match-case</code> a\u00f1adido en Python 3.10</li> <li>\ud83d\udd04 Similar a <code>when</code> de Kotlin pero menos potente</li> <li>\u23f3 Tradicionalmente se usaban diccionarios como alternativa</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#que-es-el-efecto-hoduken","title":"\u00bfQu\u00e9 es el \"Efecto Hoduken\"?","text":"<pre><code>graph TD\n    A[Condicional] --&gt; B{if}\n    B --&gt; C[else if]\n    C --&gt; D[else if]\n    D --&gt; E[...]\n    E --&gt; F[else]</code></pre> <p>Problema:</p> <ul> <li>\ud83e\udd1c Anidaci\u00f3n excesiva de <code>if-else</code> (como el movimiento de Hadouken)</li> <li>\ud83d\udeab Dificulta la legibilidad</li> <li>\ud83d\udc1b Mayor probabilidad de errores</li> </ul> <p>Soluci\u00f3n:</p> <ul> <li>\u2705 Usar <code>when</code>/<code>switch</code> para casos discretos</li> <li>\u2705 Extraer l\u00f3gica compleja a funciones</li> <li>\u2705 Usar polimorfismo cuando sea posible</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#comparativa-de-rendimiento","title":"Comparativa de Rendimiento","text":"Escenario If-Else When/Switch Notas 3-5 condiciones ~1ms ~1ms Diferencias insignificantes 10+ condiciones ~5ms ~2ms Switch optimiza saltos Rangos complejos ~3ms ~1ms When (Kotlin) gana Condiciones din\u00e1micas ~2ms ~3ms If-else m\u00e1s flexible <p>Conclusi\u00f3n: Es mejor <code>when</code>/<code>switch</code> por legibilidad, no solo por rendimiento.</p>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#6-bucles","title":"6. Bucles","text":"<p>Los bucles nos permiten ejecutar una parte de c\u00f3digo varias veces. Existen varios tipos - Indefinidos: Se ejecutan hasta que se cumple una condici\u00f3n (while). Se ejecuta una parte de c\u00f3digo mientras se cumpla una condici\u00f3n. Si queremos que se ejecute al menos una vez, debemos usar do-while. Es importante manejar correctamente las variables que se usan en la condici\u00f3n (banderas o flags) para evitar bucles infinitos.</p>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#61-bucles-indefinidos-while-y-do-while","title":"6.1. Bucles Indefinidos (while y do-while)","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#kotlin_4","title":"Kotlin","text":"Kotlin <pre><code>fun main() {\n    // While (comprueba antes de ejecutar)\n    var i = 0\n    while (i &lt; 5) {\n        println(\"While: $i\")\n        i++\n    }\n\n    // Do-while (ejecuta al menos una vez)\n    var j = 0\n    do {\n        println(\"Do-While: $j\")\n        j++\n    } while (j &lt; 5)\n}\n</code></pre> <p>Salida: <pre><code>While: 0\nWhile: 1\nWhile: 2\nWhile: 3\nWhile: 4\nDo-While: 0\nDo-While: 1\nDo-While: 2\nDo-While: 3\nDo-While: 4\n</code></pre></p>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#java_4","title":"Java","text":"Java <pre><code>public class Main {\n    public static void main(String[] args) {\n        // While\n        int i = 0;\n        while (i &lt; 5) {\n            System.out.println(\"While: \" + i);\n            i++;\n        }\n\n        // Do-while\n        int j = 0;\n        do {\n            System.out.println(\"Do-While: \" + j);\n            j++;\n        } while (j &lt; 5);\n    }\n}\n</code></pre> <p>Diferencias:</p> <ul> <li>Requiere declaraci\u00f3n de tipo (<code>int</code>)</li> <li>Uso de <code>System.out.println</code></li> <li>Punto y coma obligatorio despu\u00e9s del <code>while</code> en do-while</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#python_4","title":"Python","text":"Python <pre><code># While\ni = 0\nwhile i &lt; 5:\n    print(f\"While: {i}\")\n    i += 1\n\n# Python no tiene do-while nativo\n# Alternativa con loop + break\nj = 0\nwhile True:\n    print(f\"Do-While: {j}\")\n    j += 1\n    if j &gt;= 5:\n        break\n</code></pre> <p>Notas Python:</p> <ul> <li>No existe <code>do-while</code> nativo</li> <li>Se simula con <code>while True</code> + <code>break</code></li> <li>Indentaci\u00f3n obligatoria (4 espacios)</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#comparativa-de-sintaxis_1","title":"Comparativa de Sintaxis","text":"Caracter\u00edstica Kotlin Java Python Sintaxis <code>while</code> <code>while (cond) { }</code> <code>while (cond) { }</code> <code>while cond:</code> Sintaxis <code>do-while</code> <code>do { } while (cond)</code> <code>do { } while (cond);</code> No existe Incremento <code>i++</code> <code>i++</code> <code>i += 1</code> Print <code>println()</code> <code>System.out.println()</code> <code>print()</code>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#cuando-usar-cada-uno","title":"Cu\u00e1ndo Usar Cada Uno","text":"<pre><code>graph TD\n    A[\u00bfNecesitas ejecutar al menos una vez?] \n    A --&gt;|S\u00ed| B[Usa do-while]\n    A --&gt;|No| C[Usa while]\n    D[\u00bfCondici\u00f3n compleja?] --&gt;|S\u00ed| E[Prefiere while]\n    D --&gt;|No| F[Considera for]</code></pre> <p>Reglas pr\u00e1cticas: 1. Usa <code>while</code> cuando:    - El n\u00famero de iteraciones es desconocido    - La condici\u00f3n puede ser falsa desde el inicio</p> <ol> <li>Usa <code>do-while</code> cuando:</li> <li>Debes ejecutar el bloque al menos una vez</li> <li> <p>La condici\u00f3n se eval\u00faa despu\u00e9s (ej: menus)</p> </li> <li> <p>En Python: Prefiere <code>while</code> + <code>break</code> para simular <code>do-while</code></p> </li> <li> <p>Definidos: Se ejecutan un n\u00famero determinado de veces (for) en base a un paso de iteraci\u00f3n. Si el paso es 1 no se suele indicar. </p> </li> </ol>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#62-bucles-definidos-for-con-rango","title":"6.2. Bucles Definidos (for con rango)","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#kotlin-rangos-flexibles","title":"Kotlin (Rangos flexibles)","text":"Kotlin <pre><code>fun main() {\n    // Ascendente (0 a 10 inclusive)\n    println(\"Ascendente:\")\n    for (i in 0..10) {\n        println(i)\n    }\n\n    // Con paso 2\n    println(\"\\nPaso 2:\")\n    for (i in 0..10 step 2) {\n        println(i)\n    }\n\n    // Descendente\n    println(\"\\nDescendente:\")\n    for (i in 10 downTo 0) {\n        println(i)\n    }\n\n    // Descendente con paso 3\n    println(\"\\nDescendente paso 3:\")\n    for (i in 10 downTo 0 step 3) {\n        println(i)\n    }\n}\n</code></pre> <p>Caracter\u00edsticas Kotlin:</p> <ul> <li>Operador <code>..</code> para rangos inclusivos</li> <li><code>step</code> controla el incremento</li> <li><code>downTo</code> para rangos descendentes</li> <li>Sintaxis minimalista sin par\u00e9ntesis</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#java-estilo-tradicional","title":"Java (Estilo tradicional)","text":"Java <pre><code>public class Main {\n    public static void main(String[] args) {\n        // Ascendente\n        System.out.println(\"Ascendente:\");\n        for (int i = 0; i &lt;= 10; i++) {\n            System.out.println(i);\n        }\n\n        // Paso 2\n        System.out.println(\"\\nPaso 2:\");\n        for (int i = 0; i &lt;= 10; i += 2) {\n            System.out.println(i);\n        }\n\n        // Descendente\n        System.out.println(\"\\nDescendente:\");\n        for (int i = 10; i &gt;= 0; i--) {\n            System.out.println(i);\n        }\n\n        // Descendente paso 3\n        System.out.println(\"\\nDescendente paso 3:\");\n        for (int i = 10; i &gt;= 0; i -= 3) {\n            System.out.println(i);\n        }\n    }\n}\n</code></pre> <p>Diferencias Java:</p> <ul> <li>Sintaxis cl\u00e1sica <code>for(init; cond; incr)</code></li> <li>Requiere declaraci\u00f3n de tipo (<code>int</code>)</li> <li>Manual el control de pasos (<code>i += 2</code>)</li> <li>M\u00e1s verboso pero m\u00e1s flexible</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#python-range","title":"Python (range())","text":"Python <pre><code># Ascendente (0 a 10 inclusive)\nprint(\"Ascendente:\")\nfor i in range(0, 11):\n    print(i)\n\n# Paso 2\nprint(\"\\nPaso 2:\")\nfor i in range(0, 11, 2):\n    print(i)\n\n# Descendente\nprint(\"\\nDescendente:\")\nfor i in range(10, -1, -1):\n    print(i)\n\n# Descendente paso 3\nprint(\"\\nDescendente paso 3:\")\nfor i in range(10, -1, -3):\n    print(i)\n</code></pre> <p>Notas Python:</p> <ul> <li><code>range(start, stop, step)</code></li> <li>Stop es exclusivo (por eso <code>11</code> para llegar a 10)</li> <li>Paso negativo para descendente</li> <li>M\u00e1s compacto pero menos intuitivo el stop</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#tabla-comparativa_2","title":"Tabla Comparativa","text":"Operaci\u00f3n Kotlin Java Python Rango ascendente <code>0..10</code> <code>i = 0; i &lt;= 10; i++</code> <code>range(0, 11)</code> Rango con paso <code>step 2</code> <code>i += 2</code> <code>range(0, 11, 2)</code> Rango descendente <code>10 downTo 0</code> <code>i = 10; i &gt;= 0; i--</code> <code>range(10, -1, -1)</code> Sintaxis M\u00e1s declarativa M\u00e1s imperativa Funcional"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#rendimiento-y-uso-de-memoria","title":"Rendimiento y Uso de Memoria","text":"<pre><code>pie\n    title Eficiencia en iteraciones (10,000 elementos)\n    \"Kotlin (Sequence)\" : 85\n    \"Java (for cl\u00e1sico)\" : 95\n    \"Python (range)\" : 70</code></pre> <p>Recomendaciones:</p> <ol> <li>Para colecciones peque\u00f1as: Cualquier opci\u00f3n es v\u00e1lida</li> <li>Para rangos grandes:<ul> <li>Kotlin: Usa <code>sequence</code> para evaluaci\u00f3n perezosa</li> <li>Java: Optimo por defecto</li> <li>Python: <code>range</code> es eficiente en memoria</li> </ul> </li> <li>Cuando necesites flexibilidad:<ul> <li>Java para control fino</li> <li>Kotlin para legibilidad</li> <li>Python para rapidez de desarrollo</li> </ul> </li> </ol>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#7-programacion-modular","title":"7. Programaci\u00f3n Modular","text":"<p>La programaci\u00f3n modular es un paradigma de programaci\u00f3n que se basa en la descomposici\u00f3n de los programas en funciones (y procedimientos). Las funciones son bloques de c\u00f3digo que realizan una tarea concreta y devuelven un valor. Los procedimientos son bloques de c\u00f3digo que realizan una tarea concreta pero no devuelven ning\u00fan valor. Las ventajas que ofrece la programaci\u00f3n modular son: - Facilita la resoluci\u00f3n del problema. - Aumenta la claridad y legibilidad de todo el programa. - Permite que varios programadores trabajen en el mismo proyecto. - Reduce el tiempo de desarrollo ya que se pueden reutilizar esos m\u00f3dulos en varios programas. - Aumenta la fiabilidad porque es m\u00e1s sencillo dise\u00f1ar y depurar m\u00f3dulos y el mantenimiento en mas f\u00e1cil.</p> <p>La descomposici\u00f3n modular se basa en la t\u00e9cnica \u201cDivide y Vencer\u00e1s\u201d (DAC o Divide And Conquer), esta t\u00e9cnica tiene dos pasos: - Identificaci\u00f3n de los subproblemas y construcci\u00f3n de los m\u00f3dulos que lo resuelven. - Combinaci\u00f3n de los m\u00f3dulos para resolver el problema original.</p> <p></p>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#71-funciones","title":"7.1. Funciones","text":"<p>Las funciones son bloques de c\u00f3digo que realizan una tarea concreta y devuelven un valor. </p>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#funciones-basicas-sintaxis-comparada","title":"Funciones B\u00e1sicas (Sintaxis Comparada)","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#kotlin_5","title":"Kotlin","text":"Kotlin <pre><code>// Funci\u00f3n con retorno expl\u00edcito\nfun suma(a: Int, b: Int): Int {\n    return a + b\n}\n\n// Funci\u00f3n de expresi\u00f3n \u00fanica (return impl\u00edcito)\nfun resta(a: Int, b: Int) = a - b\n\nfun main() {\n    println(\"Suma: ${suma(5, 3)}\")  // 8\n    println(\"Resta: ${resta(5, 3)}\") // 2\n}\n</code></pre> <p>Caracter\u00edsticas Kotlin:</p> <ul> <li>Palabra clave <code>fun</code></li> <li>Tipo de retorno despu\u00e9s de par\u00e1metros <code>: Int</code></li> <li>Sintaxis abreviada para funciones de una l\u00ednea</li> <li>Interpolaci\u00f3n de strings con <code>${}</code></li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#java_5","title":"Java","text":"Java <pre><code>public class Calculadora {\n    // Funci\u00f3n tradicional\n    public static int suma(int a, int b) {\n        return a + b;\n    }\n\n    // Java no tiene equivalente a funciones de expresi\u00f3n \u00fanica\n\n    public static void main(String[] args) {\n        System.out.println(\"Suma: \" + suma(5, 3)); // 8\n    }\n}\n</code></pre> <p>Diferencias Java:</p> <ul> <li>Requiere clase contenedora</li> <li>Modificadores de acceso obligatorios (<code>public static</code>)</li> <li>Tipo de retorno antes del nombre</li> <li>M\u00e1s verboso en general</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#python_5","title":"Python","text":"Python <pre><code># Funci\u00f3n b\u00e1sica\ndef suma(a: int, b: int) -&gt; int:\n    return a + b\n\n# Funci\u00f3n de expresi\u00f3n \u00fanica (lambda)\nresta = lambda a, b: a - b\n\nif __name__ == \"__main__\":\n    print(f\"Suma: {suma(5, 3)}\")  # 8\n    print(f\"Resta: {resta(5, 3)}\") # 2\n</code></pre> <p>Notas Python:</p> <ul> <li>Palabra clave <code>def</code></li> <li>Type hints opcionales (<code>-&gt; int</code>)</li> <li><code>lambda</code> para funciones an\u00f3nimas</li> <li><code>__name__ == \"__main__\"</code> para c\u00f3digo ejecutable</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#tabla-comparativa_3","title":"Tabla Comparativa","text":"Caracter\u00edstica Kotlin Java Python Declaraci\u00f3n funci\u00f3n <code>fun nombre()</code> <code>tipoRetorno nombre()</code> <code>def nombre():</code> Tipo retorno Obligatorio Obligatorio Opcional (type hints) Return impl\u00edcito S\u00ed (con <code>=</code>) No No (solo con lambda) Funci\u00f3n como expresi\u00f3n S\u00ed No S\u00ed (lambda) Punto de entrada <code>fun main()</code> <code>public static void main()</code> <code>if __name__ == ...</code>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#ejemplo-avanzado-funciones-como-ciudadanas-de-primera-clase","title":"Ejemplo Avanzado (Funciones como ciudadanas de primera clase)","text":"KotlinJavaPython <pre><code>fun operacion(a: Int, b: Int, fn: (Int, Int) -&gt; Int): Int {\n    return fn(a, b)\n}\n\nfun main() {\n    val resultado = operacion(5, 3) { x, y -&gt; x * y }\n    println(\"Multiplicaci\u00f3n: $resultado\") // 15\n}\n</code></pre> <pre><code>import java.util.function.BiFunction;\n\npublic class Main {\n    static int operacion(int a, int b, BiFunction&lt;Integer, Integer, Integer&gt; fn) {\n        return fn.apply(a, b);\n    }\n\n    public static void main(String[] args) {\n        int resultado = operacion(5, 3, (x, y) -&gt; x * y);\n        System.out.println(\"Multiplicaci\u00f3n: \" + resultado); // 15\n    }\n}\n</code></pre> <pre><code>def operacion(a: int, b: int, fn) -&gt; int:\n    return fn(a, b)\n\nif __name__ == \"__main__\":\n    resultado = operacion(5, 3, lambda x, y: x * y)\n    print(f\"Multiplicaci\u00f3n: {resultado}\")  # 15\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#buenas-practicas_2","title":"Buenas Pr\u00e1cticas","text":"<ol> <li> <p>Nombramiento:</p> </li> <li> <p>Kotlin/Java: <code>camelCase</code></p> </li> <li> <p>Python: <code>snake_case</code></p> </li> <li> <p>Par\u00e1metros:</p> </li> <li> <p>Kotlin: Par\u00e1metros inmutables por defecto</p> </li> <li>Java: <code>final</code> para inmutabilidad</li> <li> <p>Python: Mutables por defecto</p> </li> <li> <p>Documentaci\u00f3n:</p> </li> </ol> <pre><code>/**\n * Suma dos n\u00fameros enteros\n * @param a Primer sumando\n * @param b Segundo sumando\n * @return Resultado de la suma\n */\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#72-procedimientos","title":"7.2. Procedimientos","text":"<p>Los procedimientos son bloques de c\u00f3digo que realizan una tarea concreta pero no devuelven ning\u00fan valor. </p>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#procedimientos-funciones-sin-retorno","title":"Procedimientos (Funciones sin Retorno)","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#kotlin_6","title":"Kotlin","text":"Kotlin <pre><code>// Procedimiento expl\u00edcito (Unit es opcional)\nfun mostrarSuma(a: Int, b: Int): Unit {\n    println(\"La suma es: ${a + b}\")\n}\n\n// Procedimiento con tipo inferido (Unit omitido)\nfun mostrarResta(a: Int, b: Int) {\n    println(\"La resta es: ${a - b}\")\n}\n\nfun main() {\n    mostrarSuma(5, 3)  // La suma es: 8\n    mostrarResta(5, 3) // La resta es: 2\n}\n</code></pre> <p>Caracter\u00edsticas Kotlin:</p> <ul> <li><code>Unit</code> equivale a <code>void</code> en Java (se puede omitir)</li> <li>Sintaxis consistente con funciones</li> <li>Puede usar interpolaci\u00f3n de strings</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#java_6","title":"Java","text":"Java <pre><code>public class Procedimientos {\n    // Void indica que no retorna valor\n    static void mostrarSuma(int a, int b) {\n        System.out.println(\"La suma es: \" + (a + b));\n    }\n\n    // Tambi\u00e9n puede no tener par\u00e1metros\n    static void saludar() {\n        System.out.println(\"Hola Mundo\");\n    }\n\n    public static void main(String[] args) {\n        mostrarSuma(5, 3);  // La suma es: 8\n        saludar();          // Hola Mundo\n    }\n}\n</code></pre> <p>Diferencias Java:</p> <ul> <li>Obligatorio usar <code>void</code></li> <li>Requiere clase contenedora</li> <li>M\u00e1s verboso en impresi\u00f3n</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#python_6","title":"Python","text":"Python <pre><code># Procedimiento (sin return o con return None)\ndef mostrar_suma(a: int, b: int) -&gt; None:\n    print(f\"La suma es: {a + b}\")\n\n# Sin anotaciones de tipo (equivalente)\ndef saludar():\n    print(\"Hola Mundo\")\n\nif __name__ == \"__main__\":\n    mostrar_suma(5, 3)  # La suma es: 8\n    saludar()          # Hola Mundo\n</code></pre> <p>Notas Python:</p> <ul> <li><code>None</code> es el equivalente a <code>Unit</code>/<code>void</code></li> <li>Anotaciones de tipo opcionales</li> <li>Sintaxis minimalista</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#tabla-comparativa_4","title":"Tabla Comparativa","text":"Caracter\u00edstica Kotlin Java Python Tipo de retorno <code>Unit</code> (opcional) <code>void</code> <code>None</code> (impl\u00edcito) Sintaxis declaraci\u00f3n <code>fun nombre()</code> <code>void nombre()</code> <code>def nombre():</code> Ejecuci\u00f3n Llamada directa Llamada est\u00e1tica Llamada directa Punto de entrada <code>fun main()</code> <code>public static void main()</code> <code>if __name__ == ...</code>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#ejemplo-avanzado-efectos-secundarios","title":"Ejemplo Avanzado (Efectos Secundarios)","text":"KotlinJavaPython <pre><code>var contador = 0\n\nfun incrementar() {\n    contador++\n    println(\"Contador: $contador\")\n}\n\nfun main() {\n    repeat(3) { incrementar() }\n}\n</code></pre> <pre><code>public class Contador {\n    static int contador = 0;\n\n    static void incrementar() {\n        contador++;\n        System.out.println(\"Contador: \" + contador);\n    }\n\n    public static void main(String[] args) {\n        for(int i = 0; i &lt; 3; i++) {\n            incrementar();\n        }\n    }\n}\n</code></pre> <pre><code>contador = 0\n\ndef incrementar():\n    global contador\n    contador += 1\n    print(f\"Contador: {contador}\")\n\nif __name__ == \"__main__\":\n    for _ in range(3):\n        incrementar()\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#buenas-practicas_3","title":"Buenas Pr\u00e1cticas","text":"<ol> <li>Nombramiento:</li> <li> <p>Usar verbos para indicar acci\u00f3n (<code>mostrar...</code>, <code>imprimir...</code>, <code>actualizar...</code>)</p> </li> <li> <p>Efectos secundarios:</p> </li> <li>Limitar su uso en lo posible</li> <li> <p>Documentar claramente cuando modifican estado externo</p> </li> <li> <p>Tama\u00f1o:    <pre><code>// \u274c Demasiado largo\nfun procesarYMostrarYGuardar() { /* ... */ }\n\n// \u2705 Mejor separado\nfun procesar() { /* ... */ }\nfun mostrar() { /* ... */ }\nfun guardar() { /* ... */ }\n</code></pre></p> </li> <li> <p>Documentaci\u00f3n:    <pre><code>/**\n * Muestra el resultado de una suma en consola\n * @param a Primer sumando\n * @param b Segundo sumando\n */\n</code></pre></p> </li> </ol>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#8-parametros","title":"8. Par\u00e1metros","text":"<p>Los par\u00e1metros son variables que se pasan a una funci\u00f3n o procedimiento. Con ellos podemos modificar el comportamiento de la funci\u00f3n o procedimiento y devolver un resultado diferente. Desde el lugar donde llamamos a la funci\u00f3n se les asigna los valores a estos par\u00e1metros</p> <pre><code>// Par\u00e1metros son a y b\nfun suma(a: Int, b: Int): Int {\n    return a + b\n}\n\nfun main() {\n    // Los valores 2 y 3 se asignan a los par\u00e1metros a y b\n    println(suma(2, 3))\n}\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#81-paso-por-valor-copia-y-paso-por-referencia","title":"8.1. Paso por valor, copia y paso por referencia","text":"<ul> <li>Paso por valor:</li> </ul> <p>Se crea una copia del valor del par\u00e1metro y se pasa a la funci\u00f3n. Si se modifica el valor del par\u00e1metro dentro de la funci\u00f3n, no se modifica el valor original. Es el modelo que hemos estado utilizando hasta ahora y significa que las variables del algoritmo principal que le pasamos al subalgoritmo, no pueden ser modificadas en su valor por dicho subalgoritmo.</p>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#parametros-en-funciones","title":"Par\u00e1metros en Funciones","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#conceptos-clave_1","title":"Conceptos Clave","text":"<pre><code>graph LR\n    A[Llamada a funci\u00f3n] --&gt; B[Paso de par\u00e1metros]\n    B --&gt; C[Ejecuci\u00f3n con valores]\n    C --&gt; D[Retorno de resultado]</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#kotlin_7","title":"Kotlin","text":"Kotlin <pre><code>// Par\u00e1metros con tipo expl\u00edcito\nfun potencia(base: Int, exponente: Int): Int {\n    return Math.pow(base.toDouble(), exponente.toDouble()).toInt()\n}\n\n// Par\u00e1metro con valor por defecto\nfun saludar(nombre: String = \"Invitado\") {\n    println(\"Hola, $nombre!\")\n}\n\nfun main() {\n    // Paso posicional\n    println(\"Potencia: ${potencia(2, 3)}\") // 8\n\n    // Paso nominal (named parameters)\n    println(\"Potencia: ${potencia(base = 5, exponente = 2)}\") // 25\n\n    // Usando valor por defecto\n    saludar() // Hola, Invitado!\n}\n</code></pre> <p>Caracter\u00edsticas Kotlin:</p> <ul> <li>Tipado est\u00e1tico obligatorio</li> <li>Par\u00e1metros nombrados (<code>nombre = valor</code>)</li> <li>Valores por defecto</li> <li>Inmutables por defecto (no se pueden reasignar)</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#java_7","title":"Java","text":"Java <pre><code>public class Calculadora {\n    // Par\u00e1metros tradicionales\n    static int potencia(int base, int exponente) {\n        return (int) Math.pow(base, exponente);\n    }\n\n    // Java no soporta par\u00e1metros nombrados directamente\n    // Ni valores por defecto (se necesitan overloads)\n\n    static void saludar() {\n        saludar(\"Invitado\");\n    }\n\n    static void saludar(String nombre) {\n        System.out.println(\"Hola, \" + nombre + \"!\");\n    }\n\n    public static void main(String[] args) {\n        // Solo paso posicional\n        System.out.println(\"Potencia: \" + potencia(2, 3)); // 8\n\n        // Alternativa para par\u00e1metros nombrados (Builder Pattern)\n        saludar(); // Hola, Invitado!\n    }\n}\n</code></pre> <p>Limitaciones Java:</p> <ul> <li>No soporta par\u00e1metros nombrados nativamente</li> <li>No tiene valores por defecto</li> <li>Requiere overloads para simular funcionalidades avanzadas</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#python_7","title":"Python","text":"Python <pre><code># Par\u00e1metros con type hints (opcionales)\ndef potencia(base: int, exponente: int) -&gt; int:\n    return base ** exponente\n\n# Par\u00e1metros con valor por defecto\ndef saludar(nombre: str = \"Invitado\") -&gt; None:\n    print(f\"Hola, {nombre}!\")\n\nif __name__ == \"__main__\":\n    # Paso posicional\n    print(f\"Potencia: {potencia(2, 3)}\")  # 8\n\n    # Paso nominal\n    print(f\"Potencia: {potencia(exponente=2, base=5)}\")  # 25\n\n    # Usando valor por defecto\n    saludar()  # Hola, Invitado!\n</code></pre> <p>Ventajas Python:</p> <ul> <li>Par\u00e1metros nombrados</li> <li>Valores por defecto</li> <li>Flexibilidad en tipos (aunque hay type hints)</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#tabla-comparativa_5","title":"Tabla Comparativa","text":"Caracter\u00edstica Kotlin Java Python Tipado Est\u00e1tico (obligatorio) Est\u00e1tico (obligatorio) Din\u00e1mico (type hints opcionales) Par\u00e1metros nombrados S\u00ed No (sin librer\u00edas) S\u00ed Valores por defecto S\u00ed No S\u00ed Inmutabilidad S\u00ed (por defecto) No No"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#ejemplo-avanzado-parametros-variables","title":"Ejemplo Avanzado (Par\u00e1metros Variables)","text":"KotlinJavaPython <pre><code>fun sumar(vararg numeros: Int): Int {\n    return numeros.sum()\n}\n\nfun main() {\n    println(\"Suma: ${sumar(1, 2, 3, 4)}\") // 10\n}\n</code></pre> <pre><code>public class Calculadora {\n    static int sumar(int... numeros) {\n        int total = 0;\n        for(int n : numeros) total += n;\n        return total;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"Suma: \" + sumar(1, 2, 3, 4)); // 10\n    }\n}\n</code></pre> <pre><code>def sumar(*numeros: int) -&gt; int:\n    return sum(numeros)\n\nif __name__ == \"__main__\":\n    print(f\"Suma: {sumar(1, 2, 3, 4)}\")  # 10\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#buenas-practicas_4","title":"Buenas Pr\u00e1cticas","text":"<ol> <li> <p>Orden de par\u00e1metros:    <pre><code>// \u274c Confuso\nfun crearUsuario(edad: Int, nombre: String, esAdmin: Boolean)\n\n// \u2705 Mejor\nfun crearUsuario(nombre: String, edad: Int, esAdmin: Boolean)\n</code></pre></p> </li> <li> <p>N\u00famero de par\u00e1metros:</p> </li> <li>Ideal: 3 o menos</li> <li> <p>M\u00e1ximo aceptable: 5 (considerar usar Data Class/objeto)</p> </li> <li> <p>Documentaci\u00f3n:    <pre><code>/**\n * Calcula la potencia entre dos n\u00fameros\n * @param base N\u00famero base\n * @param exponente Potencia a elevar\n * @return Resultado de la operaci\u00f3n\n */\n</code></pre></p> </li> <li> <p>Evitar par\u00e1metros booleanos:    <pre><code>// \u274c Poco claro\nfun renderizar(modo: Boolean)\n\n// \u2705 Mejor\nfun renderizar(modo: ModoRenderizado)\n</code></pre></p> </li> <li> <p>Paso por referencia: </p> </li> </ol> <p>Se pasa la direcci\u00f3n de memoria, por lo tanto si modificamos el par\u00e1metro dentro de la funci\u00f3n, se modifica el valor original. El par\u00e1metro del subalgoritmo, es decir, las modificaciones que sufra el par\u00e1metro, se reflejan en la variable que usamos en la llamada. En pseudoc\u00f3digo reflejaremos esta situaci\u00f3n con la palabra \u201cRef\u201d. En los lenguajes actuales los tipos de datos simples pasan siempre por valor y los tipos compuestos pueden pasar por referencia. El paso por referencia se usa sobre todo cuando el subalgoritmo tiene que devolver m\u00e1s de un valor o trabajamos con objetos o estructuras de almacenamiento o colecciones, donde no es necesario indicar el Ref (lo veremos m\u00e1s adelante). OJO, en Kotlin o Java no existe Ref para indicar que un paso de par\u00e1metros se pasa por referencia, es solo una ilustraci\u00f3n did\u00e1ctica de c\u00f3mo podr\u00eda indicarse. Como se ha indicado los tipos simples pasan por valor y los compuestos (arrays, colecciones u objetos) por referencia.</p>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#paso-por-referencia-vs-valor","title":"Paso por Referencia vs Valor","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#concepto-clave","title":"Concepto Clave","text":"<pre><code>graph TD\n    A[Paso por Valor] --&gt; B[Copia del valor]\n    A --&gt; C[Modificaciones no se reflejan]\n    D[Paso por Referencia] --&gt; E[Direcci\u00f3n de memoria]\n    D --&gt; F[Modificaciones afectan original]</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#kotlin_8","title":"Kotlin","text":"Kotlin <pre><code>// Tipos simples (Int, Double, Boolean, etc.) -&gt; Paso por VALOR\nfun modificarNumero(num: Int) {\n    // num += 1  // Error: num es inmutable (siempre en Kotlin)\n    val nuevoNum = num + 1  // Solo afecta al \u00e1mbito local\n}\n\n// Tipos compuestos (Array, List, objetos) -&gt; Paso por REFERENCIA\nfun modificarArray(arr: Array&lt;Int&gt;) {\n    arr[0] = 100  // Modifica el original\n}\n\nfun main() {\n    val numero = 5\n    modificarNumero(numero)\n    println(numero)  // Sigue siendo 5\n\n    val array = arrayOf(1, 2, 3)\n    modificarArray(array)\n    println(array.contentToString())  // [100, 2, 3]\n}\n</code></pre> <p>Comportamiento en Kotlin:</p> <ul> <li>Todos los par\u00e1metros son inmutables por defecto</li> <li>Tipos primitivos: Siempre paso por valor</li> <li>Objetos y colecciones: Paso por referencia (pero la referencia es inmutable)</li> <li>Para \"simular\" paso por referencia: usar clases wrapper</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#java_8","title":"Java","text":"Java <pre><code>public class Main {\n    // Paso por valor (siempre en Java)\n    static void modificarPrimitivo(int num) {\n        num += 1;  // Solo afecta localmente\n    }\n\n    // Objetos: se pasa referencia pero es copiada\n    static void modificarArray(int[] arr) {\n        arr[0] = 100;  // Modifica el original\n    }\n\n    public static void main(String[] args) {\n        int numero = 5;\n        modificarPrimitivo(numero);\n        System.out.println(numero);  // 5\n\n        int[] array = {1, 2, 3};\n        modificarArray(array);\n        System.out.println(Arrays.toString(array));  // [100, 2, 3]\n    }\n}\n</code></pre> <p>En Java:</p> <ul> <li>Todo es paso por valor (pero las referencias a objetos se copian)</li> <li>Efecto similar a paso por referencia con objetos</li> <li>No se puede cambiar la referencia original de un objeto</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#python_8","title":"Python","text":"Python <pre><code>def modificar_primitivo(num: int):\n    num += 1  # No afecta al original\n    return num\n\ndef modificar_lista(lst: list):\n    lst[0] = 100  # Modifica el original\n\nif __name__ == \"__main__\":\n    numero = 5\n    modificar_primitivo(numero)\n    print(numero)  # 5\n\n    lista = [1, 2, 3]\n    modificar_lista(lista)\n    print(lista)  # [100, 2, 3]\n</code></pre> <p>Comportamiento Python:</p> <ul> <li>Similar a Java (todo es paso por valor de referencia)</li> <li>Tipos mutables (listas, dicts) pueden modificarse</li> <li>Tipos inmutables (int, str, tuples) no pueden modificarse</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#tabla-comparativa_6","title":"Tabla Comparativa","text":"Lenguaje Tipos Primitivos Objetos/Colecciones \u00bfMutable? Kotlin Por valor Por referencia Inmutable por defecto Java Por valor Valor de referencia Depende del tipo Python Por valor Valor de referencia Depende del tipo"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#como-simular-paso-por-referencia","title":"C\u00f3mo Simular Paso por Referencia","text":"KotlinJavaPython <pre><code>class Ref&lt;T&gt;(var value: T)\n\nfun modificar(ref: Ref&lt;Int&gt;) {\n    ref.value += 10\n}\n\nfun main() {\n    val referencia = Ref(5)\n    modificar(referencia)\n    println(referencia.value)  // 15\n}\n</code></pre> <pre><code>class MutableInt {\n    int value;\n    MutableInt(int value) { this.value = value; }\n}\n\npublic class Main {\n    static void modificar(MutableInt num) {\n        num.value += 10;\n    }\n\n    public static void main(String[] args) {\n        MutableInt num = new MutableInt(5);\n        modificar(num);\n        System.out.println(num.value);  // 15\n    }\n}\n</code></pre> <pre><code>def modificar(num):\n    num[0] += 10\n\nif __name__ == \"__main__\":\n    num = [5]  # Usamos lista como contenedor\n    modificar(num)\n    print(num[0])  # 15\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#buenas-practicas_5","title":"Buenas Pr\u00e1cticas","text":"<ol> <li>Evitar modificar par\u00e1metros:</li> <li> <p>Preferir retornar nuevos valores en lugar de modificar entradas</p> </li> <li> <p>Documentar efectos secundarios:    <pre><code>/**\n * Ordena la lista IN-PLACE (modifica el original)\n * @param lista Lista a modificar\n */\n</code></pre></p> </li> <li> <p>Usar tipos inmutables cuando sea posible:    <pre><code>fun procesar(lista: List&lt;Int&gt;): List&lt;Int&gt; { // List es interfaz inmutable\n    return lista.map { it * 2 }\n}\n</code></pre></p> </li> <li> <p>Para m\u00faltiples retornos:</p> </li> <li>Usar data classes (Kotlin)</li> <li>Tuplas (Python)</li> <li>Clases wrapper (Java)</li> </ol>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#9-ambito-de-variables","title":"9. \u00c1mbito de variables","text":"<p>El \u00e1mbito de una variable es el lugar donde se puede utilizar. Las variables pueden tener \u00e1mbito local o global. Las variables locales solo se pueden utilizar dentro de la funci\u00f3n o procedimiento donde se han declarado. Las variables globales se pueden utilizar en cualquier parte del programa. Se deben intentar no abusar de las variables globales ya que pueden provocar errores en el programa.</p>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#91-ambito-de-variables-scope","title":"9.1. \u00c1mbito de Variables (Scope)","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#conceptos-clave_2","title":"Conceptos Clave","text":"<pre><code>graph TD\n    A[\u00c1mbito] --&gt; B[Global]\n    A --&gt; C[Local]\n    C --&gt; D[Funci\u00f3n]\n    C --&gt; E[Bloque]</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#kotlin_9","title":"Kotlin","text":"Kotlin <pre><code>// Variable global (evitar en lo posible)\nvar contadorGlobal = 0\n\nfun ejemploScope() {\n    // Variable local a la funci\u00f3n\n    val localFuncion = 10\n\n    if (true) {\n        // Variable local al bloque\n        val localBloque = 20\n        println(localBloque)\n        println(localFuncion)\n        contadorGlobal++\n    }\n\n    // println(localBloque) // Error: fuera de \u00e1mbito\n}\n\nfun main() {\n    ejemploScope()\n    println(contadorGlobal) // Acceso a global\n    // println(localFuncion) // Error: no visible\n}\n</code></pre> <p>Caracter\u00edsticas Kotlin:</p> <ul> <li><code>val</code>: Inmutable (recomendado)</li> <li><code>var</code>: Mutable</li> <li>\u00c1mbito de bloque (if, when, for, etc.)</li> <li>Globales: Accesibles desde cualquier funci\u00f3n en el mismo archivo</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#java_9","title":"Java","text":"Java <pre><code>public class Ambito {\n    // Variable global (static para este ejemplo)\n    static int contadorGlobal = 0;\n\n    static void ejemploScope() {\n        int localFuncion = 10;\n\n        if (true) {\n            int localBloque = 20;\n            System.out.println(localBloque);\n            contadorGlobal++;\n        }\n\n        // System.out.println(localBloque); // Error\n    }\n\n    public static void main(String[] args) {\n        ejemploScope();\n        System.out.println(contadorGlobal);\n    }\n}\n</code></pre> <p>Diferencias Java:</p> <ul> <li>Variables deben declararse con tipo</li> <li><code>final</code> para constantes (equivalente a <code>val</code>)</li> <li>Globales deben ser <code>static</code> para este ejemplo</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#python_9","title":"Python","text":"Python <pre><code># Variable global\ncontador_global = 0\n\ndef ejemplo_scope():\n    local_funcion = 10\n\n    if True:\n        local_bloque = 20\n        print(local_bloque)\n        global contador_global\n        contador_global += 1\n\n    # print(local_bloque)  # Error si se descomenta\n\nif __name__ == \"__main__\":\n    ejemplo_scope()\n    print(contador_global)\n</code></pre> <p>Notas Python:</p> <ul> <li><code>global</code> necesario para modificar variables globales</li> <li>No hay declaraci\u00f3n de tipo por defecto</li> <li>\u00c1mbito de bloque menos estricto que Kotlin/Java</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#tabla-comparativa_7","title":"Tabla Comparativa","text":"Caracter\u00edstica Kotlin Java Python Variables globales Nivel archivo <code>static</code> en clases Nivel m\u00f3dulo Constantes <code>val</code> <code>final</code> Convenci\u00f3n (MAY\u00daSCULAS) Modificar globales Directo Directo Requiere <code>global</code> \u00c1mbito de bloque Estricto Estricto Menos estricto"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#buenas-practicas_6","title":"Buenas Pr\u00e1cticas","text":"<ol> <li> <p>Minimizar variables globales:    <pre><code>// \u274c\nvar config = loadConfig()\n\n// \u2705 Mejor\nclass ConfigProvider {\n    private val config = loadConfig()\n    fun getConfig() = config\n}\n</code></pre></p> </li> <li> <p>\u00c1mbito m\u00ednimo necesario:    <pre><code>// \u274c Demasiado amplio\nfun procesar() {\n    val db = Database()\n    // 100 l\u00edneas de c\u00f3digo...\n}\n\n// \u2705 Mejor\nfun procesar(db: Database) {\n    // Usar db\n}\n</code></pre></p> </li> <li> <p>Constantes bien definidas:    <pre><code>// \u2705\nconst val MAX_INTENTOS = 3\nprivate val PI = 3.1416\n</code></pre></p> </li> <li> <p>Evitar shadowing:    <pre><code>// \u274c Confuso\nval x = 10\nfun ejemplo() {\n    val x = 20 // Shadowing\n}\n</code></pre></p> </li> </ol>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#ejemplo-avanzado-ambito-de-extension","title":"Ejemplo Avanzado (\u00c1mbito de Extensi\u00f3n)","text":"KotlinJavaPython <pre><code>fun String.miExtension() {\n    println(this) // this est\u00e1 en \u00e1mbito aqu\u00ed\n}\n\nfun main() {\n    \"Hola\".miExtension()\n}\n</code></pre> <pre><code>public class StringUtil {\n    public static void miMetodo(String str) {\n        System.out.println(str);\n    }\n}\n</code></pre> <pre><code>class String(str):\n    def mi_metodo(self):\n        print(self)\n\ndef usar():\n    s = String(\"Hola\")\n    s.mi_metodo()\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#riesgos-comunes","title":"Riesgos Comunes","text":"<ol> <li> <p>Accidental global:    <pre><code># \u274c Python\ndef suma(a, b):\n    global resultado  # Innecesario y peligroso\n    resultado = a + b\n    return resultado\n</code></pre></p> </li> <li> <p>Contaminaci\u00f3n de \u00e1mbito:    <pre><code>// \u274c\nfun ejemplo() {\n    val lista = mutableListOf&lt;Int&gt;()\n    // ... mucha l\u00f3gica ...\n    // lista sigue en \u00e1mbito cuando ya no se necesita\n}\n</code></pre></p> </li> <li> <p>Mutable global state:    <pre><code>// \u274c Java\npublic class Config {\n    public static String ENVIRONMENT; // Peligroso\n}\n</code></pre></p> </li> </ol>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#10-recursividad","title":"10. Recursividad","text":"<p>La recursividad es una t\u00e9cnica que consiste en llamar a una funci\u00f3n o procedimiento dentro de s\u00ed mismo. La funci\u00f3n o procedimiento se llama a s\u00ed misma hasta que se cumple una condici\u00f3n que hace que la funci\u00f3n o procedimiento deje de llamarse a s\u00ed misma (condici\u00f3n de parada o salida). Es importante siempre mostrar la condici\u00f3n de parada. Muchos problemas son mucho m\u00e1s sencillos de resolver con recursividad que con iteraci\u00f3n. Por ejemplo, el c\u00e1lculo de un factorial es mucho m\u00e1s sencillo de resolver con recursividad que con iteraci\u00f3n.</p>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#101-recursividad-vs-iteracion","title":"10.1 Recursividad vs Iteraci\u00f3n","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#concepto-clave_1","title":"Concepto Clave","text":"<pre><code>graph TD\n    A[Recursividad] --&gt; B[Caso Base]\n    A --&gt; C[Llamada Recursiva]\n    D[Iteraci\u00f3n] --&gt; E[Bucles]\n    D --&gt; F[Acumuladores]</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#kotlin_10","title":"Kotlin","text":"Kotlin <pre><code>// Versi\u00f3n recursiva\nfun factorialRec(n: Int): Int {\n    require(n &gt;= 0) { \"n debe ser positivo\" }\n    return if (n &lt;= 1) 1 else n * factorialRec(n - 1)\n}\n\n// Versi\u00f3n iterativa (tailrec optimizado)\ntailrec fun factorialTailRec(n: Int, acc: Int = 1): Int {\n    return if (n &lt;= 1) acc else factorialTailRec(n - 1, acc * n)\n}\n\nfun main() {\n    println(\"Recursivo: ${factorialRec(5)}\") // 120\n    println(\"TailRec: ${factorialTailRec(5)}\") // 120\n}\n</code></pre> <p>Ventajas Kotlin:</p> <ul> <li><code>tailrec</code> optimiza recursi\u00f3n a iteraci\u00f3n (evita StackOverflow)</li> <li>Expresividad en funciones recursivas</li> <li>Chequeo de par\u00e1metros con <code>require</code></li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#java_10","title":"Java","text":"Java <pre><code>public class Factorial {\n    // Recursivo cl\u00e1sico\n    static int factorialRec(int n) {\n        if (n &lt; 0) throw new IllegalArgumentException(\"n debe ser positivo\");\n        return (n &lt;= 1) ? 1 : n * factorialRec(n - 1);\n    }\n\n    // Iterativo\n    static int factorialIter(int n) {\n        int result = 1;\n        for (int i = 2; i &lt;= n; i++) {\n            result *= i;\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"Recursivo: \" + factorialRec(5)); // 120\n        System.out.println(\"Iterativo: \" + factorialIter(5)); // 120\n    }\n}\n</code></pre> <p>Limitaciones Java:</p> <ul> <li>No tiene optimizaci\u00f3n autom\u00e1tica de tail recursion</li> <li>M\u00e1s propenso a StackOverflowError</li> <li>Sintaxis m\u00e1s verbosa</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#python_10","title":"Python","text":"Python <pre><code># Recursivo\ndef factorial_rec(n: int) -&gt; int:\n    if n &lt; 0:\n        raise ValueError(\"n debe ser positivo\")\n    return 1 if n &lt;= 1 else n * factorial_rec(n - 1)\n\n# Iterativo\ndef factorial_iter(n: int) -&gt; int:\n    result = 1\n    for i in range(2, n + 1):\n        result *= i\n    return result\n\nif __name__ == \"__main__\":\n    print(f\"Recursivo: {factorial_rec(5)}\")  # 120\n    print(f\"Iterativo: {factorial_iter(5)}\")  # 120\n</code></pre> <p>Notas Python:</p> <ul> <li>L\u00edmite de recursi\u00f3n bajo (~1000 por defecto)</li> <li>No hay optimizaci\u00f3n de tail recursion</li> <li>Sintaxis muy legible para algoritmos recursivos</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#comparacion-de-rendimiento","title":"Comparaci\u00f3n de Rendimiento","text":"Escenario Recursi\u00f3n Cl\u00e1sica Tail Recursion Iteraci\u00f3n n = 5 ~0.1ms ~0.05ms ~0.01ms n = 1000 StackOverflow ~1.2ms ~0.8ms Memoria O(n) O(1) O(1) Legibilidad Alta Media Baja"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#ejemplo-avanzado-fibonacci","title":"Ejemplo Avanzado (Fibonacci)","text":"KotlinJavaPython <pre><code>// Versi\u00f3n ineficiente (O(2^n))\nfun fibRec(n: Int): Int = when (n) {\n    0, 1 -&gt; n\n    else -&gt; fibRec(n - 1) + fibRec(n - 2)\n}\n\n// Versi\u00f3n eficiente (O(n))\ntailrec fun fibTailRec(n: Int, a: Int = 0, b: Int = 1): Int {\n    return if (n == 0) a else fibTailRec(n - 1, b, a + b)\n}\n</code></pre> <pre><code>// Versi\u00f3n ineficiente\nstatic int fibRec(int n) {\n    if (n &lt;= 1) return n;\n    return fibRec(n-1) + fibRec(n-2);\n}\n\n// Versi\u00f3n iterativa\nstatic int fibIter(int n) {\n    int a = 0, b = 1, c;\n    for (int i = 0; i &lt; n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return a;\n}\n</code></pre> <pre><code># Versi\u00f3n ineficiente\ndef fib_rec(n):\n    if n &lt;= 1:\n        return n\n    return fib_rec(n-1) + fib_rec(n-2)\n\n# Versi\u00f3n eficiente con memoization\nfrom functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef fib_memo(n):\n    if n &lt;= 1:\n        return n\n    return fib_memo(n-1) + fib_memo(n-2)\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#cuando-usar-recursion","title":"Cu\u00e1ndo Usar Recursi\u00f3n","text":"<ol> <li>Problemas recursivos por naturaleza:</li> <li>Algoritmos de divide y vencer\u00e1s</li> <li> <p>Estructuras de datos recursivas (\u00e1rboles, grafos)</p> </li> <li> <p>Ventajas:</p> </li> <li>C\u00f3digo m\u00e1s legible y expresivo</li> <li> <p>M\u00e1s f\u00e1cil de probar matem\u00e1ticamente</p> </li> <li> <p>Precauciones:</p> </li> <li>Siempre definir caso base</li> <li>Asegurar convergencia al caso base</li> <li>Para recursi\u00f3n m\u00faltiple, considerar memoization</li> </ol> <pre><code>flowchart TD\n    A[\u00bfEl problema es recursivo?] --&gt;|S\u00ed| B[Considera recursi\u00f3n]\n    A --&gt;|No| C[Usa iteraci\u00f3n]\n    B --&gt; D[\u00bfPuede ser tail recursion?]\n    D --&gt;|S\u00ed| E[Optimiza con tailrec]\n    D --&gt;|No| F[Considera l\u00edmite de stack]</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#buenas-practicas_7","title":"Buenas Pr\u00e1cticas","text":"<ol> <li>Documentar el caso base:</li> </ol> <pre><code>/**\n * Calcula factorial recursivo\n * @param n N\u00famero positivo (caso base n &lt;= 1 retorna 1)\n */\n</code></pre> <ol> <li>Validar par\u00e1metros:</li> </ol> <pre><code>require(n &gt;= 0) { \"n debe ser positivo\" }\n</code></pre> <ol> <li>Para recursi\u00f3n m\u00faltiple:</li> </ol> <pre><code>@lru_cache  # Python\nmemo = mutableMapOf&lt;Int, Int&gt;()  # Kotlin\n</code></pre> <ol> <li> <p>Alternativas:</p> </li> <li> <p>Usar iteraci\u00f3n para problemas lineales simples</p> </li> <li>Considerar tail recursion cuando sea posible</li> <li>Para problemas complejos: dividir en subproblemas</li> </ol>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#11-paquete-o-modulo","title":"11. Paquete o m\u00f3dulo","text":"<p>Un paquete o m\u00f3dulo es un conjunto de funciones y procedimientos que realizan una tarea concreta. Por ejemplo, un paquete de funciones matem\u00e1ticas, un paquete de funciones de entrada y salida, un paquete de funciones de gesti\u00f3n de arrays, etc. Usamos estos paquetes para agrupar funciones y procedimientos que realizan una tarea concreta y que podemos reutilizar en otros programas o en otras partes del mismo. Es una forma de ordenar nuestro c\u00f3digo por funcionalidades.</p>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#111-paquetes-y-modulos","title":"11.1 Paquetes y M\u00f3dulos","text":""},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#concepto-clave_2","title":"Concepto Clave","text":"<pre><code>graph TD\n    A[Organizaci\u00f3n de c\u00f3digo] --&gt; B[Paquetes]\n    A --&gt; C[M\u00f3dulos]\n    B --&gt; D[Agrupar funcionalidades relacionadas]\n    C --&gt; E[Unidades independientes de c\u00f3digo]</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#kotlin_11","title":"Kotlin","text":"Kotlin <pre><code>// Definici\u00f3n de paquete (opcional, al inicio del archivo)\npackage com.ejemplo.matematicas\n\n// Funci\u00f3n p\u00fablica (visible fuera del paquete)\nfun suma(a: Int, b: Int): Int = a + b\n\n// Funci\u00f3n interna (solo visible dentro del m\u00f3dulo)\ninternal fun resta(a: Int, b: Int): Int = a - b\n\n// Uso desde otro archivo\n/*\nimport com.ejemplo.matematicas.suma\n\nfun main() {\n    println(suma(2, 3))\n}\n*/\n</code></pre> <p>Caracter\u00edsticas Kotlin:</p> <ul> <li>Estructura jer\u00e1rquica de paquetes</li> <li>Control de visibilidad (<code>public</code>, <code>internal</code>, <code>private</code>)</li> <li>Paquetes pueden no coincidir con estructura de directorios</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#java_11","title":"Java","text":"Java <pre><code>// Definici\u00f3n de paquete (debe coincidir con estructura de directorios)\npackage com.ejemplo.matematicas;\n\npublic class Calculadora {\n    // M\u00e9todo p\u00fablico\n    public static int suma(int a, int b) {\n        return a + b;\n    }\n\n    // M\u00e9todo package-private (visible solo en el paquete)\n    static int resta(int a, int b) {\n        return a - b;\n    }\n}\n\n// Uso desde otra clase\n/*\nimport com.ejemplo.matematicas.Calculadora;\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(Calculadora.suma(2, 3));\n    }\n}\n*/\n</code></pre> <p>Diferencias Java:</p> <ul> <li>Paquetes deben coincidir con estructura de directorios</li> <li>Clases como unidades b\u00e1sicas de organizaci\u00f3n</li> <li>Visibilidad m\u00e1s granular (<code>public</code>, <code>protected</code>, <code>package-private</code>, <code>private</code>)</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#python_11","title":"Python","text":"Python <pre><code># m\u00f3dulo/matematicas.py\ndef suma(a: int, b: int) -&gt; int:\n    return a + b\n\ndef _resta(a: int, b: int) -&gt; int:  # Convenci\u00f3n para \"privado\"\n    return a - b\n\n# Uso desde otro archivo\n\"\"\"\nfrom modulo.matematicas import suma\n\nif __name__ == \"__main__\":\n    print(suma(2, 3))\n\"\"\"\n</code></pre> <p>Notas Python:</p> <ul> <li>Sistema de m\u00f3dulos basado en archivos</li> <li>Convenciones (<code>_nombre</code> para \"privado\")</li> <li>Paquetes con <code>__init__.py</code></li> <li>Importaci\u00f3n m\u00e1s flexible</li> </ul>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#comparativa-de-caracteristicas","title":"Comparativa de Caracter\u00edsticas","text":"Caracter\u00edstica Kotlin Java Python Unidad b\u00e1sica Archivo Clase Archivo Estructura directorios Recomendada Obligatoria Obligatoria para paquetes Visibilidad <code>public</code>, <code>internal</code>, <code>private</code> 4 niveles Convenci\u00f3n (<code>_nombre</code>) Importaci\u00f3n Flexible Estricta Muy flexible Paquetes est\u00e1ndar <code>kotlin.math</code>, etc. <code>java.util</code>, etc. <code>math</code>, <code>os</code>, etc."},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#ejemplo-de-estructura","title":"Ejemplo de Estructura","text":"Estructura de Proyecto <pre><code>proyecto/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 main/\n\u2502   \u2502   \u251c\u2500\u2500 kotlin/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 com/\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 ejemplo/\n\u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 matematicas.kt\n\u2502   \u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 util.kt\n\u2502   \u251c\u2500\u2500 java/\n\u2502   \u2502   \u251c\u2500\u2500 com/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 ejemplo/\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Calculadora.java\n\u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 Main.java\n\u2502   \u251c\u2500\u2500 python/\n\u2502   \u2502   \u251c\u2500\u2500 modulo/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 matematicas.py\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 main.py\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#buenas-practicas_8","title":"Buenas Pr\u00e1cticas","text":"<ol> <li>Nombrado de paquetes:</li> <li>Kotlin/Java: Dominio inverso (<code>com.ejemplo.miprojecto</code>)</li> <li> <p>Python: Min\u00fasculas sin espacios (<code>mi_paquete</code>)</p> </li> <li> <p>Organizaci\u00f3n:    <pre><code>// \u274c Demasiado amplio\npackage utils\n\n// \u2705 Espec\u00edfico\npackage com.ejemplo.utils.validacion\n</code></pre></p> </li> <li> <p>Visibilidad adecuada:    <pre><code>// \u274c Todo p\u00fablico\npublic class Utils { /* ... */ }\n\n// \u2705 Solo lo necesario p\u00fablico\nclass StringUtils { /* ... */ }\n</code></pre></p> </li> <li> <p>Documentaci\u00f3n:    <pre><code>/**\n * Paquete para operaciones matem\u00e1ticas b\u00e1sicas\n * Incluye funciones para c\u00e1lculo aritm\u00e9tico\n */\npackage com.ejemplo.matematicas\n</code></pre></p> </li> </ol>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#ejemplo-avanzado-multiplataforma","title":"Ejemplo Avanzado (Multiplataforma)","text":"Kotlin MultiplatformJava Modules (JPMS)Python Subpaquetes <pre><code>// commonMain/kotlin/com/ejemplo/core/\nexpect class Platform() {\n    val name: String\n}\n\n// jsMain/kotlin/com/ejemplo/core/\nactual class Platform actual constructor() {\n    actual val name = \"JavaScript\"\n}\n</code></pre> <pre><code>module com.ejemplo.matematicas {\n    exports com.ejemplo.matematicas;\n    requires java.base;\n}\n</code></pre> <pre><code># proyecto/paquete/subpaquete/__init__.py\nfrom .modulo import Clase\n\n__all__ = ['Clase']\n</code></pre>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#gestion-de-dependencias","title":"Gesti\u00f3n de Dependencias","text":"Lenguaje Herramienta Archivo de configuraci\u00f3n Kotlin Gradle/Maven <code>build.gradle.kts</code> Java Gradle/Maven <code>pom.xml</code> Python pip/Poetry <code>requirements.txt</code>"},{"location":"Unidad%202%20Programaci%C3%B3n%20estructurada%20y%20modular/2_Programaci%C3%B3n%20estructurada%20y%20modular/#12-referencias","title":"12. Referencias","text":"<ul> <li>https://es.wikipedia.org/wiki/Tipo_de_dato</li> <li>https://es.wikipedia.org/wiki/Programaci%C3%B3n_estructurada</li> <li>https://es.wikipedia.org/wiki/Programaci%C3%B3n_modular</li> <li>https://es.stackoverflow.com/questions/1493/cu%C3%A1l-es-la-diferencia-entre-paso-de-variables-por-valor-y-por-referencia</li> <li>https://es.wikipedia.org/wiki/Recursi%C3%B3n</li> </ul>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/","title":"Programaci\u00f3n - 03 Aplicaci\u00f3n de Estructuras de Almacenamiento","text":"<p>Tema 03 Aplicaci\u00f3n de Estructuras de Almacenamiento. 1DAM. Curso 2025/2026.</p>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#1-arrays-unidimensionales","title":"1. Arrays unidimensionales","text":""},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#definicion","title":"\ud83d\udd0d Definici\u00f3n","text":"<p>Un array es una estructura de datos que permite almacenar un conjunto de datos contiguos del mismo tipo. Se caracterizan por tener un tama\u00f1o fijo, es decir, una vez definido el array no se puede modificar su tama\u00f1o y que su acceso de lectura y escritura se realiza mediante un \u00edndice.</p> <p>Si una variable es como un caj\u00f3n de un tama\u00f1o del tipo de dato (es decir, el identificador apunta a la zona de memoria donde se almacena el valor), un array puede verse como un conjunto de cajones (una cajonera) del mismo tama\u00f1o del tipo de dato, donde cada caj\u00f3n tiene un \u00edndice que nos permite acceder a \u00e9l. Por tanto, un array es una estructura de datos que nos permite almacenar un conjunto de datos del mismo tipo.</p> <p>En Kotlin y Java, el primer \u00edndice es el 0. Esto se debe a la forma de redireccionar de memoria que han ido heredando los lenguajes y compiladores (como en C), el primer elemento de un array se almacena en la posici\u00f3n 0. Por tanto, si tenemos un array de 10 elementos, el \u00faltimo elemento se almacena en la posici\u00f3n 9. Si nos salimos del l\u00edmite obtendremos una excepci\u00f3n (tanto si consultamos como \u00edndice un n\u00famero negativo, como si consultamos un \u00edndice mayor o igual al tama\u00f1o del array). Esta excepci\u00f3n es <code>ArrayIndexOutOfBoundsException</code>.</p> Value 7 11 6 55 98 45 16 96 46 Index 0 1 2 3 4 5 6 7 8 <p>Lower Bound = 0 Array Length = 9</p>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#definicion-de-arrays","title":"\ud83d\udcdd Definici\u00f3n de arrays","text":"KotlinJavaPython <pre><code>// Array de 10 enteros\nvar arrayEnteros = IntArray(10) // valor inicial 0\nvar arrayEnteros = intArrayOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\nvar arrayEnteros = IntArray(10) { 0 } // array de 10 enteros inicializados a 0\nvar arrayCaracteres = CharArray(10)\nvar arrayBooleanos = BooleanArray(10)\n\n// Otros tipos de arrays\nvar arrayCadenas = arrayOf(\"Hola\", \"mundo\")\nvar arrayEnteros = arrayOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n// Usando Array&lt;Tipo&gt;\nvar arrayEnteros = Array&lt;Int&gt;(10) { 0 }\nvar arrayCadenas = Array&lt;String&gt;(10) { \"\" }\n</code></pre> <pre><code>// Array de 10 enteros\nint[] arrayEnteros = new int[10]; // valor inicial 0\nint[] arrayEnteros = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\nint[] arrayEnteros = new int[10]; // todos inicializados a 0\nchar[] arrayCaracteres = new char[10];\nboolean[] arrayBooleanos = new boolean[10];\n\n// Arrays de objetos\nString[] arrayCadenas = {\"Hola\", \"mundo\"};\nString[] arrayCadenas = new String[10]; // inicializados a null\n</code></pre> <pre><code># Lista en Python (equivalente a array)\narray_enteros = [0] * 10  # lista de 10 ceros\narray_enteros = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\narray_cadenas = [\"Hola\", \"mundo\"]\n\n# Usando array module para arrays tipados\nimport array\narray_enteros = array.array('i', [1, 2, 3, 4, 5])\n</code></pre>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#recorrido","title":"\ud83d\udd04 Recorrido","text":"<p>Para recorrer un array y trabajar con \u00e9l, el \u00edndice ser\u00e1 clave. Para ello, podemos utilizar un bucle for o for-each o while, que nos permitir\u00e1 recorrer el array de principio a fin.</p> KotlinJavaPython <pre><code>fun main() {\n    val array = arrayOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n\n    // Recorrido con for indices\n    for (i in array.indices) {\n        println(array[i])\n    }\n\n    // Con reversed con indices\n    for (i in array.indices.reversed()) {\n        println(array[i])\n    }\n\n    // Con for each\n    for (i in array) {\n        println(i)\n    }\n\n    // Saltando posiciones\n    for (i in array.indices step 2) {\n        println(array[i])\n    }\n\n    // Con while\n    var i = 0\n    while (i &lt; array.size) {\n        println(array[i])\n        i++\n    }\n\n    // With index, para obtener el \u00edndice y el valor\n    for ((index, value) in array.withIndex()) {\n        println(\"El elemento $value est\u00e1 en la posici\u00f3n $index\")\n    }\n}\n</code></pre> <pre><code>public class Main {\n    public static void main(String[] args) {\n        int[] array = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\n        // Recorrido con for tradicional\n        for (int i = 0; i &lt; array.length; i++) {\n            System.out.println(array[i]);\n        }\n\n        // Recorrido inverso\n        for (int i = array.length - 1; i &gt;= 0; i--) {\n            System.out.println(array[i]);\n        }\n\n        // For-each\n        for (int elemento : array) {\n            System.out.println(elemento);\n        }\n\n        // Saltando posiciones\n        for (int i = 0; i &lt; array.length; i += 2) {\n            System.out.println(array[i]);\n        }\n\n        // Con while\n        int i = 0;\n        while (i &lt; array.length) {\n            System.out.println(array[i]);\n            i++;\n        }\n    }\n}\n</code></pre> <pre><code>def main():\n    array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n    # Recorrido con for tradicional\n    for i in range(len(array)):\n        print(array[i])\n\n    # Recorrido inverso\n    for i in range(len(array)-1, -1, -1):\n        print(array[i])\n\n    # For-each\n    for elemento in array:\n        print(elemento)\n\n    # Saltando posiciones\n    for i in range(0, len(array), 2):\n        print(array[i])\n\n    # Con while\n    i = 0\n    while i &lt; len(array):\n        print(array[i])\n        i += 1\n\n    # Con enumerate (\u00edndice y valor)\n    for indice, valor in enumerate(array):\n        print(f\"El elemento {valor} est\u00e1 en la posici\u00f3n {indice}\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#paso-por-referencia","title":"\ud83d\udce4 Paso por referencia","text":"<p>Los arrays siempre pasan por referencia en las funciones, esto quiere decir, que si modificamos un array en una funci\u00f3n, este cambio ser\u00e1 visible despu\u00e9s de ejecutar la funci\u00f3n.</p> KotlinJavaPython <pre><code>fun main() {\n    val array = arrayOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n    println(\"Array original: ${array.contentToString()}\")\n    // Modificamos el array\n    modificarArray(array)\n    println(\"Array modificado: ${array.contentToString()}\")\n}\n\nfun modificarArray(array: IntArray) {\n    array[0] = 100\n    array[1] = 200\n    array[2] = 300\n}\n</code></pre> <pre><code>public class Main {\n    public static void main(String[] args) {\n        int[] array = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n        System.out.println(\"Array original: \" + java.util.Arrays.toString(array));\n        // Modificamos el array\n        modificarArray(array);\n        System.out.println(\"Array modificado: \" + java.util.Arrays.toString(array));\n    }\n\n    public static void modificarArray(int[] array) {\n        array[0] = 100;\n        array[1] = 200;\n        array[2] = 300;\n    }\n}\n</code></pre> <pre><code>def modificar_array(array):\n    array[0] = 100\n    array[1] = 200\n    array[2] = 300\n\ndef main():\n    array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print(f\"Array original: {array}\")\n    # Modificamos el array\n    modificar_array(array)\n    print(f\"Array modificado: {array}\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#devolucion-de-arrays","title":"\ud83d\udd19 Devoluci\u00f3n de arrays","text":"<p>Para devolver un array, podemos utilizar la palabra reservada return, pero en este caso, no devolveremos el array, sino que devolveremos la referencia a la posici\u00f3n de memoria donde se encuentra el array.</p> KotlinJavaPython <pre><code>fun main() {\n    val array = arrayOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n    println(\"Array original: ${array.contentToString()}\")\n    // Modificamos el array\n    val array2 = modificarArray(array)\n    println(\"Array modified: ${array.contentToString()}\")\n    println(\"Array2 modified: ${array2.contentToString()}\")\n}\n\nfun modificarArray(array: IntArray): IntArray {\n    array[0] = 100\n    array[1] = 200\n    array[2] = 300\n    return array\n}\n</code></pre> <pre><code>public class Main {\n    public static void main(String[] args) {\n        int[] array = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n        System.out.println(\"Array original: \" + java.util.Arrays.toString(array));\n        // Modificamos el array\n        int[] array2 = modificarArray(array);\n        System.out.println(\"Array modified: \" + java.util.Arrays.toString(array));\n        System.out.println(\"Array2 modified: \" + java.util.Arrays.toString(array2));\n    }\n\n    public static int[] modificarArray(int[] array) {\n        array[0] = 100;\n        array[1] = 200;\n        array[2] = 300;\n        return array;\n    }\n}\n</code></pre> <pre><code>def modificar_array(array):\n    array[0] = 100\n    array[1] = 200\n    array[2] = 300\n    return array\n\ndef main():\n    array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print(f\"Array original: {array}\")\n    # Modificamos el array\n    array2 = modificar_array(array)\n    print(f\"Array modified: {array}\")\n    print(f\"Array2 modified: {array2}\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#identidad-vs-igualdad","title":"\u2696\ufe0f Identidad vs Igualdad","text":"<p>Uno de los problemas fundamentales en la programaci\u00f3n es la identidad y la igualdad.</p> <ul> <li>Se dice que dos objetos son id\u00e9nticos si apuntan a la misma posici\u00f3n de memoria, es decir, si son el mismo objeto.</li> <li>Se dice que dos objetos son iguales si tienen el mismo contenido, es decir, si tienen el mismo valor.</li> </ul> KotlinJavaPython <pre><code>fun main() {\n    val arrayA = arrayOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n    val arrayB = arrayOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n\n    println(\"Array A: ${arrayA.contentToString()}\")\n    println(\"Array B: ${arrayB.contentToString()}\")\n\n    // Igualdad\n    println(\"Son iguales: ${igualdad(arrayA, arrayB)}\")\n    // ==\n    println(\"Son iguales: ${arrayA == arrayB}\")\n    // contentEquals\n    println(\"Son iguales: ${arrayA.contentEquals(arrayB)}\")\n    // Identidad\n    println(\"Son id\u00e9nticos: ${arrayA === arrayB}\")\n}\n\nfun igualdad(origin: IntArray, destino: IntArray): Boolean {\n    // Early exit\n    if (origin.size != destino.size) {\n        return false\n    }\n    for (i in origin.indices) {\n        if (origin[i] != destino[i]) {\n            return false\n        }\n    }\n    return true\n}\n</code></pre> <pre><code>import java.util.Arrays;\n\npublic class Main {\n    public static void main(String[] args) {\n        int[] arrayA = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n        int[] arrayB = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\n        System.out.println(\"Array A: \" + Arrays.toString(arrayA));\n        System.out.println(\"Array B: \" + Arrays.toString(arrayB));\n\n        // Igualdad\n        System.out.println(\"Son iguales: \" + igualdad(arrayA, arrayB));\n        // Arrays.equals\n        System.out.println(\"Son iguales: \" + Arrays.equals(arrayA, arrayB));\n        // Identidad\n        System.out.println(\"Son id\u00e9nticos: \" + (arrayA == arrayB));\n    }\n\n    public static boolean igualdad(int[] origin, int[] destino) {\n        // Early exit\n        if (origin.length != destino.length) {\n            return false;\n        }\n        for (int i = 0; i &lt; origin.length; i++) {\n            if (origin[i] != destino[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n</code></pre> <pre><code>def igualdad(origin, destino):\n    # Early exit\n    if len(origin) != len(destino):\n        return False\n    for i in range(len(origin)):\n        if origin[i] != destino[i]:\n            return False\n    return True\n\ndef main():\n    arrayA = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    arrayB = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n    print(f\"Array A: {arrayA}\")\n    print(f\"Array B: {arrayB}\")\n\n    # Igualdad\n    print(f\"Son iguales: {igualdad(arrayA, arrayB)}\")\n    # ==\n    print(f\"Son iguales: {arrayA == arrayB}\")\n    # Identidad\n    print(f\"Son id\u00e9nticos: {arrayA is arrayB}\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#metodos-y-propiedades","title":"\ud83d\udccb M\u00e9todos y propiedades","text":"<p>Algunos m\u00e9todos interesantes para trabajar con arrays:</p> KotlinJavaPython <pre><code>val numeros = arrayOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n\n// tama\u00f1o\nprintln(\"Tama\u00f1o: ${numeros.size}\")\n// primer elemento\nprintln(\"Primer elemento: ${numeros.first()}\")\n// \u00faltimo elemento\nprintln(\"\u00daltimo elemento: ${numeros.last()}\")\n// a string\nprintln(\"Array a string: ${numeros.contentToString()}\")\n// a string con separador\nprintln(\"Array a string con separador: ${numeros.joinToString(\" - \")}\")\n// saber si existe en qu\u00e9 \u00edndice esta\nprintln(\"\u00cdndice del elemento 5: ${numeros.indexOf(5)}\")\n// Subarray\nprintln(\"Subarray: ${numeros.sliceArray(0..4).contentToString()}\")\n</code></pre> <pre><code>import java.util.Arrays;\n\npublic class Main {\n    public static void main(String[] args) {\n        int[] numeros = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\n        // tama\u00f1o\n        System.out.println(\"Tama\u00f1o: \" + numeros.length);\n        // primer elemento\n        System.out.println(\"Primer elemento: \" + numeros[0]);\n        // \u00faltimo elemento\n        System.out.println(\"\u00daltimo elemento: \" + numeros[numeros.length - 1]);\n        // a string\n        System.out.println(\"Array a string: \" + Arrays.toString(numeros));\n        // saber si existe en qu\u00e9 \u00edndice esta\n        int index = -1;\n        for (int i = 0; i &lt; numeros.length; i++) {\n            if (numeros[i] == 5) {\n                index = i;\n                break;\n            }\n        }\n        System.out.println(\"\u00cdndice del elemento 5: \" + index);\n        // Subarray\n        int[] subarray = Arrays.copyOfRange(numeros, 0, 5);\n        System.out.println(\"Subarray: \" + Arrays.toString(subarray));\n    }\n}\n</code></pre> <pre><code>def main():\n    numeros = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n    # tama\u00f1o\n    print(f\"Tama\u00f1o: {len(numeros)}\")\n    # primer elemento\n    print(f\"Primer elemento: {numeros[0]}\")\n    # \u00faltimo elemento\n    print(f\"\u00daltimo elemento: {numeros[-1]}\")\n    # a string\n    print(f\"Array a string: {numeros}\")\n    # a string con separador\n    print(f\"Array a string con separador: {' - '.join(map(str, numeros))}\")\n    # saber si existe en qu\u00e9 \u00edndice esta\n    try:\n        index = numeros.index(5)\n        print(f\"\u00cdndice del elemento 5: {index}\")\n    except ValueError:\n        print(\"Elemento no encontrado\")\n    # Subarray\n    subarray = numeros[0:5]\n    print(f\"Subarray: {subarray}\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#2-arrays-multidimensionales","title":"2. Arrays multidimensionales","text":"<p>Los arrays multidimensionales son arrays que contienen otros arrays, por ejemplo, un array de dos dimensiones es un array donde cada elemento es un array. Es decir, es un array de arrays. Para recorrerlo usaremos tanto \u00edndices como dimensiones tenga.</p>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#estructura","title":"\ud83d\udcca Estructura","text":"<pre><code>Columns\nColumn 1   Column 2   Column 3\n\nRow 1      111        112        113        Array 1    Arrays 6\nRow 2      121        211        212        213        Array 2\nRow 3      131        221        311        312        313        Array 3\n                    231        321        322        323\n                    331        332        333\n</code></pre>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#definicion_1","title":"\ud83d\udcdd Definici\u00f3n","text":"KotlinJavaPython <pre><code>val array = arrayOf(\n    arrayOf(1, 2, 3), \n    arrayOf(4, 5, 6), \n    arrayOf(7, 8, 9)\n)\nval array2 = arrayOfNulls&lt;Array&lt;Int&gt;&gt;(3)\nval array3 = Array(3) { IntArray(3) } // array de 3x3\n</code></pre> <pre><code>int[][] array = {\n    {1, 2, 3},\n    {4, 5, 6},\n    {7, 8, 9}\n};\nint[][] array2 = new int[3][3]; // array de 3x3\nInteger[][] array3 = new Integer[3][3]; // con nulls\n</code></pre> <pre><code># Lista de listas\narray = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\n\n# Crear array 3x3 con ceros\narray2 = [[0] * 3 for _ in range(3)]\n</code></pre>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#recorrido_1","title":"\ud83d\udd04 Recorrido","text":"<p>Necesitaremos tantos \u00edndices como dimensiones, y por lo tanto tantos bucles definidos como dimensiones.</p> KotlinJavaPython <pre><code>fun main() {\n    val array = arrayOf(\n        arrayOf(1, 2, 3),\n        arrayOf(4, 5, 6), \n        arrayOf(7, 8, 9)\n    )\n\n    // Usando \u00edndices\n    for (i in array.indices) {\n        for (j in array[i].indices) {\n            println(\"array[$i][$j] = ${array[i][j]}\")\n        }\n    }\n\n    // Con while\n    var i = 0\n    while (i &lt; array.size) {\n        var j = 0\n        while (j &lt; array[i].size) {\n            println(\"array[$i][$j] = ${array[i][j]}\")\n            j++\n        }\n        i++\n    }\n\n    // Con for each\n    for (fila in array) {\n        for (elemento in fila) {\n            println(\"element = $elemento\")\n        }\n    }\n}\n</code></pre> <pre><code>public class Main {\n    public static void main(String[] args) {\n        int[][] array = {\n            {1, 2, 3},\n            {4, 5, 6},\n            {7, 8, 9}\n        };\n\n        // Usando \u00edndices\n        for (int i = 0; i &lt; array.length; i++) {\n            for (int j = 0; j &lt; array[i].length; j++) {\n                System.out.println(\"array[\" + i + \"][\" + j + \"] = \" + array[i][j]);\n            }\n        }\n\n        // Con while\n        int i = 0;\n        while (i &lt; array.length) {\n            int j = 0;\n            while (j &lt; array[i].length) {\n                System.out.println(\"array[\" + i + \"][\" + j + \"] = \" + array[i][j]);\n                j++;\n            }\n            i++;\n        }\n\n        // Con for-each\n        for (int[] fila : array) {\n            for (int elemento : fila) {\n                System.out.println(\"element = \" + elemento);\n            }\n        }\n    }\n}\n</code></pre> <pre><code>def main():\n    array = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    # Usando \u00edndices\n    for i in range(len(array)):\n        for j in range(len(array[i])):\n            print(f\"array[{i}][{j}] = {array[i][j]}\")\n\n    # Con while\n    i = 0\n    while i &lt; len(array):\n        j = 0\n        while j &lt; len(array[i]):\n            print(f\"array[{i}][{j}] = {array[i][j]}\")\n            j += 1\n        i += 1\n\n    # Con for-each\n    for fila in array:\n        for elemento in fila:\n            print(f\"element = {elemento}\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#3-cadenas-de-caracteres-strings","title":"3. Cadenas de caracteres (Strings)","text":"<p>Una cadena es una secuencia de caracteres, es decir, una cadena es un array de caracteres. En Kotlin y Java, las cadenas son inmutables, es decir, no podemos modificar una cadena, si queremos modificar una cadena, tendremos que crear una nueva cadena.</p>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#definicion_2","title":"\ud83d\udcdd Definici\u00f3n","text":"KotlinJavaPython <pre><code>val cadena = \"Hola mundo\"\nval cadenaVacia = \"\"\nval cadenaNula: String? = null\n</code></pre> <pre><code>String cadena = \"Hola mundo\";\nString cadenaVacia = \"\";\nString cadenaNula = null;\n</code></pre> <pre><code>cadena = \"Hola mundo\"\ncadena_vacia = \"\"\ncadena_nula = None\n</code></pre>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#recorrido_2","title":"\ud83d\udd04 Recorrido","text":"KotlinJavaPython <pre><code>fun main() {\n    val cadena = \"Hola mundo\"\n\n    for (caracter in cadena) {\n        println(\"caracter = $caracter\")\n    }\n\n    // Con indices\n    for (i in cadena.indices) {\n        println(\"cadena[$i] = ${cadena[i]}\")\n    }\n}\n</code></pre> <pre><code>public class Main {\n    public static void main(String[] args) {\n        String cadena = \"Hola mundo\";\n\n        // Con for-each (convertir a char array)\n        for (char caracter : cadena.toCharArray()) {\n            System.out.println(\"caracter = \" + caracter);\n        }\n\n        // Con indices\n        for (int i = 0; i &lt; cadena.length(); i++) {\n            System.out.println(\"cadena[\" + i + \"] = \" + cadena.charAt(i));\n        }\n    }\n}\n</code></pre> <pre><code>def main():\n    cadena = \"Hola mundo\"\n\n    for caracter in cadena:\n        print(f\"caracter = {caracter}\")\n\n    # Con indices\n    for i in range(len(cadena)):\n        print(f\"cadena[{i}] = {cadena[i]}\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#metodos-y-operadores","title":"\ud83d\udee0\ufe0f M\u00e9todos y operadores","text":"KotlinJavaPython <pre><code>val cadena = \"Hola mundo\"\n\n// Longitud\nprintln(\"Longitud: ${cadena.length}\")\n// Obtener un car\u00e1cter\nprintln(\"Car\u00e1cter: ${cadena[0]}\")\n// Obtener un subcadena\nprintln(\"Subcadena: ${cadena.substring(0, 4)}\")\n// Obtener un array de caracteres\nprintln(\"Array de caracteres: ${cadena.toCharArray().contentToString()}\")\n// Obtener un array de cadenas\nprintln(\"Array de cadenas: ${cadena.split(\" \")}\")\n// Concatenaci\u00f3n\nprintln(\"Concatenaci\u00f3n: ${cadena + \"!!\"}\")\n// Comparaci\u00f3n\nprintln(\"Son iguales: ${cadena == \"Hola mundo\"}\")\n// pasar a may\u00fasculas\nprintln(\"May\u00fasculas: ${cadena.uppercase()}\")\n// pasar a min\u00fasculas\nprintln(\"Min\u00fasculas: ${cadena.lowercase()}\")\n// Contiene\nprintln(\"Contiene: ${cadena.contains(\"Hola\")}\")\n// primer elemento\nprintln(\"Primer elemento: ${cadena.first()}\")\n// \u00faltimo elemento\nprintln(\"\u00daltimo elemento: ${cadena.last()}\")\n// Eliminar espacios en blanco\nprintln(\"Eliminar espacios en blanco: ${cadena.trim()}\")\n// saber si existe en qu\u00e9 \u00edndice est\u00e1\nprintln(\"\u00cdndice: ${cadena.indexOf(\"mundo\")}\")\n// Subarray con slice\nprintln(\"Subarray: ${cadena.slice(0..4)}\")\n// reemplazar\nprintln(\"Reemplazar: ${cadena.replace(\"Hola\", \"Adi\u00f3s\")}\")\n</code></pre> <pre><code>public class Main {\n    public static void main(String[] args) {\n        String cadena = \"Hola mundo\";\n\n        // Longitud\n        System.out.println(\"Longitud: \" + cadena.length());\n        // Obtener un car\u00e1cter\n        System.out.println(\"Car\u00e1cter: \" + cadena.charAt(0));\n        // Obtener un subcadena\n        System.out.println(\"Subcadena: \" + cadena.substring(0, 4));\n        // Obtener un array de caracteres\n        System.out.println(\"Array de caracteres: \" + java.util.Arrays.toString(cadena.toCharArray()));\n        // Obtener un array de cadenas\n        System.out.println(\"Array de cadenas: \" + java.util.Arrays.toString(cadena.split(\" \")));\n        // Concatenaci\u00f3n\n        System.out.println(\"Concatenaci\u00f3n: \" + cadena + \"!!\");\n        // Comparaci\u00f3n\n        System.out.println(\"Son iguales: \" + cadena.equals(\"Hola mundo\"));\n        // pasar a may\u00fasculas\n        System.out.println(\"May\u00fasculas: \" + cadena.toUpperCase());\n        // pasar a min\u00fasculas\n        System.out.println(\"Min\u00fasculas: \" + cadena.toLowerCase());\n        // Contiene\n        System.out.println(\"Contiene: \" + cadena.contains(\"Hola\"));\n        // primer elemento\n        System.out.println(\"Primer elemento: \" + cadena.charAt(0));\n        // \u00faltimo elemento\n        System.out.println(\"\u00daltimo elemento: \" + cadena.charAt(cadena.length() - 1));\n        // Eliminar espacios en blanco\n        System.out.println(\"Eliminar espacios en blanco: \" + cadena.trim());\n        // saber si existe en qu\u00e9 \u00edndice est\u00e1\n        System.out.println(\"\u00cdndice: \" + cadena.indexOf(\"mundo\"));\n        // Subarray con substring\n        System.out.println(\"Subarray: \" + cadena.substring(0, 5));\n        // reemplazar\n        System.out.println(\"Reemplazar: \" + cadena.replace(\"Hola\", \"Adi\u00f3s\"));\n    }\n}\n</code></pre> <pre><code>def main():\n    cadena = \"Hola mundo\"\n\n    # Longitud\n    print(f\"Longitud: {len(cadena)}\")\n    # Obtener un car\u00e1cter\n    print(f\"Car\u00e1cter: {cadena[0]}\")\n    # Obtener un subcadena\n    print(f\"Subcadena: {cadena[0:4]}\")\n    # Obtener un array de caracteres\n    print(f\"Array de caracteres: {list(cadena)}\")\n    # Obtener un array de cadenas\n    print(f\"Array de cadenas: {cadena.split(' ')}\")\n    # Concatenaci\u00f3n\n    print(f\"Concatenaci\u00f3n: {cadena + '!!'}\")\n    # Comparaci\u00f3n\n    print(f\"Son iguales: {cadena == 'Hola mundo'}\")\n    # pasar a may\u00fasculas\n    print(f\"May\u00fasculas: {cadena.upper()}\")\n    # pasar a min\u00fasculas\n    print(f\"Min\u00fasculas: {cadena.lower()}\")\n    # Contiene\n    print(f\"Contiene: {'Hola' in cadena}\")\n    # primer elemento\n    print(f\"Primer elemento: {cadena[0]}\")\n    # \u00faltimo elemento\n    print(f\"\u00daltimo elemento: {cadena[-1]}\")\n    # Eliminar espacios en blanco\n    print(f\"Eliminar espacios en blanco: {cadena.strip()}\")\n    # saber si existe en qu\u00e9 \u00edndice est\u00e1\n    print(f\"\u00cdndice: {cadena.find('mundo')}\")\n    # Subarray con slice\n    print(f\"Subarray: {cadena[0:5]}\")\n    # reemplazar\n    print(f\"Reemplazar: {cadena.replace('Hola', 'Adi\u00f3s')}\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#stringbuilder","title":"\ud83d\udd27 StringBuilder","text":"<p>StringBuilder es una clase que nos permite crear cadenas de forma mutable, es decir, podemos modificarlas.</p> KotlinJavaPython <pre><code>val sb = StringBuilder()\nval sb2 = StringBuilder(\"Hola mundo\")\nsb.append(\"Hola mundo\")\nval mensaje = sb2.toString()\n</code></pre> <pre><code>StringBuilder sb = new StringBuilder();\nStringBuilder sb2 = new StringBuilder(\"Hola mundo\");\nsb.append(\"Hola mundo\");\nString mensaje = sb2.toString();\n</code></pre> <pre><code># En Python las cadenas son inmutables, pero podemos usar join o f-strings\n# Para operaciones complejas podemos usar lista y join\npartes = []\npartes.append(\"Hola\")\npartes.append(\"mundo\")\nmensaje = \" \".join(partes)\n\n# O usando f-strings\nnombre = \"mundo\"\nmensaje = f\"Hola {nombre}\"\n</code></pre>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#4-expresiones-regulares","title":"4. Expresiones regulares","text":"<p>Una expresi\u00f3n regular es una secuencia de caracteres que forma un patr\u00f3n de b\u00fasqueda, principalmente utilizada para la b\u00fasqueda de patrones de cadenas de caracteres u operaciones de sustituci\u00f3n.</p>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#definicion_3","title":"\ud83d\udcdd Definici\u00f3n","text":"KotlinJavaPython <pre><code>val regex = Regex(\"Hola\")\nval regex2 = \"\\\\d+\".toRegex()\n</code></pre> <pre><code>import java.util.regex.Pattern;\nimport java.util.regex.Matcher;\n\nPattern regex = Pattern.compile(\"Hola\");\nPattern regex2 = Pattern.compile(\"\\\\d+\");\n</code></pre> <pre><code>import re\n\nregex = re.compile(\"Hola\")\nregex2 = re.compile(r\"\\d+\")\n</code></pre>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#metodos-y-operadores_1","title":"\ud83d\udee0\ufe0f M\u00e9todos y operadores","text":"KotlinJavaPython <pre><code>val regex = Regex(\"Hola\")\n\n// Comprobar si una cadena cumple el patr\u00f3n\nprintln(\"Cumple el patr\u00f3n: ${regex.matches(\"Hola mundo\")}\")\n// Obtener un array de cadenas\nprintln(\"Array de cadenas: ${regex.split(\"Hola mundo\").contentToString()}\")\n// Reemplazar\nprintln(\"Reemplazar: ${regex.replace(\"Hola mundo\", \"Adi\u00f3s mundo\")}\")\n</code></pre> <pre><code>import java.util.regex.Pattern;\nimport java.util.regex.Matcher;\n\npublic class Main {\n    public static void main(String[] args) {\n        Pattern regex = Pattern.compile(\"Hola\");\n\n        // Comprobar si una cadena cumple el patr\u00f3n\n        Matcher matcher = regex.matcher(\"Hola mundo\");\n        System.out.println(\"Cumple el patr\u00f3n: \" + matcher.matches());\n\n        // Obtener un array de cadenas\n        String[] partes = regex.split(\"Hola mundo\");\n        System.out.println(\"Array de cadenas: \" + java.util.Arrays.toString(partes));\n\n        // Reemplazar\n        String resultado = regex.matcher(\"Hola mundo\").replaceAll(\"Adi\u00f3s mundo\");\n        System.out.println(\"Reemplazar: \" + resultado);\n    }\n}\n</code></pre> <pre><code>import re\n\ndef main():\n    regex = re.compile(\"Hola\")\n\n    # Comprobar si una cadena cumple el patr\u00f3n\n    print(f\"Cumple el patr\u00f3n: {bool(regex.match('Hola mundo'))}\")\n    # Obtener un array de cadenas\n    print(f\"Array de cadenas: {regex.split('Hola mundo')}\")\n    # Reemplazar\n    print(f\"Reemplazar: {regex.sub('Adi\u00f3s mundo', 'Hola mundo')}\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#ejemplos","title":"\ud83d\udd0d Ejemplos","text":"KotlinJavaPython <pre><code>fun main() {\n    // Solo n\u00fameros\n    val regexNum = \"\\\\d+\".toRegex()\n    println(\"Solo n\u00fameros: ${regexNum.matches(\"1234567890\")}\")\n\n    // Letras min\u00fasculas\n    val regexMin = \"[a-z]+\".toRegex()\n    println(\"Letras min\u00fasculas: ${regexMin.matches(\"abcdefghijklmn\u00f1opqrstuvwxyz\")}\")\n\n    // Letras may\u00fasculas\n    val regexMay = \"[A-Z]+\".toRegex()\n    println(\"Letras may\u00fasculas: ${regexMay.matches(\"ABCDEFGHIJKLMN\u00d1OPQRSTUVWXYZ\")}\")\n\n    // Letras min\u00fasculas y may\u00fasculas\n    val regexLetras = \"[a-zA-Z]+\".toRegex()\n    println(\"Letras min\u00fasculas y may\u00fasculas: ${regexLetras.matches(\"abcdefghijklmn\u00f1opqrstuvwxyzABCDEFGHIJKLMN\u00d1OPQRSTUVWXYZ\")}\")\n\n    // Tel\u00e9fono\n    val regexTel = \"\\\\d{9}\".toRegex()\n    println(\"Tel\u00e9fono: ${regexTel.matches(\"123456789\")}\")\n\n    // DNI\n    val regexDNI = \"\\\\d{8}[A-Z]\".toRegex()\n    println(\"DNI: ${regexDNI.matches(\"12345678A\")}\")\n\n    // Email\n    val regexEmail = \"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}\".toRegex()\n    println(\"Email: ${regexEmail.matches(\"pepe@pepilandia.com\")}\")\n\n    // URL\n    val regexURL = \"^(http|https)://[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}\".toRegex()\n    println(\"URL: ${regexURL.matches(\"http://pepilandia.com\")}\")\n\n    // Tarjeta de cr\u00e9dito\n    val regexTarjeta = \"\\\\d{4} \\\\d{4} \\\\d{4} \\\\d{4}\".toRegex()\n    println(\"Tarjeta de cr\u00e9dito: ${regexTarjeta.matches(\"1234 5678 9012 3456\")}\")\n\n    // Fecha\n    val regexFecha = \"\\\\d{2}/\\\\d{2}/\\\\d{4}\".toRegex()\n    println(\"Fecha: ${regexFecha.matches(\"01/01/2020\")}\")\n}\n</code></pre> <pre><code>import java.util.regex.Pattern;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Solo n\u00fameros\n        Pattern regexNum = Pattern.compile(\"\\\\d+\");\n        System.out.println(\"Solo n\u00fameros: \" + regexNum.matcher(\"1234567890\").matches());\n\n        // Letras min\u00fasculas\n        Pattern regexMin = Pattern.compile(\"[a-z]+\");\n        System.out.println(\"Letras min\u00fasculas: \" + regexMin.matcher(\"abcdefghijklmn\u00f1opqrstuvwxyz\").matches());\n\n        // Letras may\u00fasculas\n        Pattern regexMay = Pattern.compile(\"[A-Z]+\");\n        System.out.println(\"Letras may\u00fasculas: \" + regexMay.matcher(\"ABCDEFGHIJKLMN\u00d1OPQRSTUVWXYZ\").matches());\n\n        // Tel\u00e9fono\n        Pattern regexTel = Pattern.compile(\"\\\\d{9}\");\n        System.out.println(\"Tel\u00e9fono: \" + regexTel.matcher(\"123456789\").matches());\n\n        // DNI\n        Pattern regexDNI = Pattern.compile(\"\\\\d{8}[A-Z]\");\n        System.out.println(\"DNI: \" + regexDNI.matcher(\"12345678A\").matches());\n\n        // Email\n        Pattern regexEmail = Pattern.compile(\"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}\");\n        System.out.println(\"Email: \" + regexEmail.matcher(\"pepe@pepilandia.com\").matches());\n    }\n}\n</code></pre> <pre><code>import re\n\ndef main():\n    # Solo n\u00fameros\n    regex_num = re.compile(r\"\\d+\")\n    print(f\"Solo n\u00fameros: {bool(regex_num.match('1234567890'))}\")\n\n    # Letras min\u00fasculas\n    regex_min = re.compile(r\"[a-z]+\")\n    print(f\"Letras min\u00fasculas: {bool(regex_min.match('abcdefghijklmn\u00f1opqrstuvwxyz'))}\")\n\n    # Letras may\u00fasculas\n    regex_may = re.compile(r\"[A-Z]+\")\n    print(f\"Letras may\u00fasculas: {bool(regex_may.match('ABCDEFGHIJKLMN\u00d1OPQRSTUVWXYZ'))}\")\n\n    # Tel\u00e9fono\n    regex_tel = re.compile(r\"\\d{9}\")\n    print(f\"Tel\u00e9fono: {bool(regex_tel.match('123456789'))}\")\n\n    # DNI\n    regex_dni = re.compile(r\"\\d{8}[A-Z]\")\n    print(f\"DNI: {bool(regex_dni.match('12345678A'))}\")\n\n    # Email\n    regex_email = re.compile(r\"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}\")\n    print(f\"Email: {bool(regex_email.match('pepe@pepilandia.com'))}\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#5-metodos-de-ordenacion","title":"5. M\u00e9todos de ordenaci\u00f3n","text":"<p>Los m\u00e9todos de ordenaci\u00f3n nos permite ordenar arrays. Pero debemos tener en cuenta que dependiendo del m\u00e9todo de ordenaci\u00f3n as\u00ed ser\u00e1 su eficiencia.</p>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#burbuja","title":"\ud83d\udd34 Burbuja","text":"<p>Es un m\u00e9todo de ordenaci\u00f3n con eficiencia O(n\u00b2). Consiste en ir comparando cada elemento con el siguiente, y si el elemento actual es mayor que el siguiente, se intercambian.</p> <pre><code>6  5  3  1  8  7  2  4\n</code></pre> KotlinJavaPython <pre><code>fun burbuja(array: IntArray) {\n    var aux: Int\n    for (i in 0 until array.size) {\n        for (j in 0 until array.size - 1) {\n            if (array[j] &gt; array[j + 1]) {\n                aux = array[j]\n                array[j] = array[j + 1]\n                array[j + 1] = aux\n            }\n        }\n    }\n}\n</code></pre> <pre><code>public static void burbuja(int[] array) {\n    int aux;\n    for (int i = 0; i &lt; array.length; i++) {\n        for (int j = 0; j &lt; array.length - 1; j++) {\n            if (array[j] &gt; array[j + 1]) {\n                aux = array[j];\n                array[j] = array[j + 1];\n                array[j + 1] = aux;\n            }\n        }\n    }\n}\n</code></pre> <pre><code>def burbuja(array):\n    for i in range(len(array)):\n        for j in range(len(array) - 1):\n            if array[j] &gt; array[j + 1]:\n                array[j], array[j + 1] = array[j + 1], array[j]\n</code></pre>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#seleccion","title":"\ud83d\udd35 Selecci\u00f3n","text":"<p>El algoritmo de selecci\u00f3n tiene eficiencia O(n\u00b2). Consiste en ir buscando el elemento m\u00e1s peque\u00f1o del array y colocarlo en la primera posici\u00f3n, luego el segundo m\u00e1s peque\u00f1o y colocarlo en la segunda posici\u00f3n, y as\u00ed sucesivamente.</p> KotlinJavaPython <pre><code>fun seleccion(array: IntArray) {\n    var aux: Int\n    var min: Int\n    for (i in 0 until array.size) {\n        min = i\n        for (j in i + 1 until array.size) {\n            if (array[j] &lt; array[min]) {\n                min = j\n            }\n        }\n        aux = array[i]\n        array[i] = array[min]\n        array[min] = aux\n    }\n}\n</code></pre> <pre><code>public static void seleccion(int[] array) {\n    int aux, min;\n    for (int i = 0; i &lt; array.length; i++) {\n        min = i;\n        for (int j = i + 1; j &lt; array.length; j++) {\n            if (array[j] &lt; array[min]) {\n                min = j;\n            }\n        }\n        aux = array[i];\n        array[i] = array[min];\n        array[min] = aux;\n    }\n}\n</code></pre> <pre><code>def seleccion(array):\n    for i in range(len(array)):\n        min_idx = i\n        for j in range(i + 1, len(array)):\n            if array[j] &lt; array[min_idx]:\n                min_idx = j\n        array[i], array[min_idx] = array[min_idx], array[i]\n</code></pre>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#insercion","title":"\ud83d\udfe2 Inserci\u00f3n","text":"<p>El algoritmo de inserci\u00f3n tiene eficiencia O(n\u00b2). Inicialmente se tiene un solo elemento, que obviamente es un conjunto ordenado. Despu\u00e9s, cuando hay k elementos ordenados de menor a mayor, se toma el elemento k+1 y se compara con todos los elementos ya ordenados.</p> KotlinJavaPython <pre><code>fun insercion(array: IntArray) {\n    var aux: Int\n    var j: Int\n    for (i in 1 until array.size) {\n        aux = array[i]\n        j = i - 1\n        while (j &gt;= 0 &amp;&amp; array[j] &gt; aux) {\n            array[j + 1] = array[j]\n            j--\n        }\n        array[j + 1] = aux\n    }\n}\n</code></pre> <pre><code>public static void insercion(int[] array) {\n    int aux, j;\n    for (int i = 1; i &lt; array.length; i++) {\n        aux = array[i];\n        j = i - 1;\n        while (j &gt;= 0 &amp;&amp; array[j] &gt; aux) {\n            array[j + 1] = array[j];\n            j--;\n        }\n        array[j + 1] = aux;\n    }\n}\n</code></pre> <pre><code>def insercion(array):\n    for i in range(1, len(array)):\n        aux = array[i]\n        j = i - 1\n        while j &gt;= 0 and array[j] &gt; aux:\n            array[j + 1] = array[j]\n            j -= 1\n        array[j + 1] = aux\n</code></pre>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#shell","title":"\ud83d\udfe1 Shell","text":"<p>El algoritmo de Shell es una mejora del algoritmo de inserci\u00f3n. Su eficiencia es de O(n log n). Este m\u00e9todo consiste en ordenar los elementos de un array de forma que los elementos que est\u00e1n lejos entre s\u00ed se ordenan primero.</p> KotlinJavaPython <pre><code>fun shell(array: IntArray) {\n    var aux: Int\n    var j: Int\n    var intervalo = 1\n    while (intervalo &lt; array.size) {\n        intervalo = intervalo * 3 + 1\n    }\n    while (intervalo &gt; 0) {\n        for (i in intervalo until array.size) {\n            aux = array[i]\n            j = i\n            while (j &gt; intervalo - 1 &amp;&amp; array[j - intervalo] &gt;= aux) {\n                array[j] = array[j - intervalo]\n                j -= intervalo\n            }\n            array[j] = aux\n        }\n        intervalo = (intervalo - 1) / 3\n    }\n}\n</code></pre> <pre><code>public static void shell(int[] array) {\n    int aux, j, intervalo = 1;\n    while (intervalo &lt; array.length) {\n        intervalo = intervalo * 3 + 1;\n    }\n    while (intervalo &gt; 0) {\n        for (int i = intervalo; i &lt; array.length; i++) {\n            aux = array[i];\n            j = i;\n            while (j &gt; intervalo - 1 &amp;&amp; array[j - intervalo] &gt;= aux) {\n                array[j] = array[j - intervalo];\n                j -= intervalo;\n            }\n            array[j] = aux;\n        }\n        intervalo = (intervalo - 1) / 3;\n    }\n}\n</code></pre> <pre><code>def shell(array):\n    n = len(array)\n    intervalo = 1\n    while intervalo &lt; n:\n        intervalo = intervalo * 3 + 1\n\n    while intervalo &gt; 0:\n        for i in range(intervalo, n):\n            aux = array[i]\n            j = i\n            while j &gt;= intervalo and array[j - intervalo] &gt; aux:\n                array[j] = array[j - intervalo]\n                j -= intervalo\n            array[j] = aux\n        intervalo = (intervalo - 1) // 3\n</code></pre>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#quicksort","title":"\ud83d\udfe3 QuickSort","text":"<p>El algoritmo de quicksort es el algoritmo m\u00e1s r\u00e1pido que veremos. Su eficiencia es de O(n log n). Consiste en dividir el array en dos partes, una con los elementos menores que el pivote y otra con los elementos mayores que el pivote.</p> <p>Veamos este ejemplo de Wikipedia</p> <p>En el siguiente ejemplo se marcan el pivote y los \u00edndices i y j con las letras p, i y j respectivamente.</p> <pre><code>Comenzamos con la lista completa. El elemento pivote ser\u00e1 el 4:\n 5 - 3 - 7 - 6 - 2 - 1 - 4\n                         p\nComparamos con el 5 por la izquierda y el 1 por la derecha.\n 5 - 3 - 7 - 6 - 2 - 1 - 4 \n i                   j   p\n5 es mayor que 4 y 1 es menor. Intercambiamos:\n 1 - 3 - 7 - 6 - 2 - 5 - 4\n i                   j   p \nAvanzamos por la izquierda y la derecha:\n 1 - 3 - 7 - 6 - 2 - 5 - 4\n     i           j       p \n3 es menor que 4: avanzamos por la izquierda. 2 es menor que 4: nos mantenemos ah\u00ed.\n 1 - 3 - 7 - 6 - 2 - 5 - 4\n         i       j       p \n7 es mayor que 4 y 2 es menor: intercambiamos.\n 1 - 3 - 2 - 6 - 7 - 5 - 4\n         i       j       p \nAvanzamos por ambos lados:\n 1 - 3 - 2 - 6 - 7 - 5 - 4\n            iyj          p \nEn este momento termina el ciclo principal, porque los \u00edndices se cruzaron. Ahora intercambiamos lista[i] con lista[p] (pasos 16-18):\n 1 - 3 - 2 - 4 - 7 - 5 - 6\n             p \nAplicamos recursivamente a la sublista de la izquierda (\u00edndices 0 - 2). Tenemos lo siguiente:\n 1 - 3 - 2 \n1 es menor que 2: avanzamos por la izquierda. 3 es mayor: avanzamos por la derecha. Como se intercambiaron los \u00edndices termina el ciclo. Se intercambia lista[i] con lista[p]:\n 1 - 2 - 3 \nEl mismo procedimiento se aplicar\u00e1 a la otra sublista. Al finalizar y unir todas las sublistas queda la lista inicial ordenada en forma ascendente.\n 1 - 2 - 3 - 4 - 5 - 6 - 7\n</code></pre> KotlinJava <pre><code>fun pivote(array: IntArray, izq: Int, der: Int): Int {\n    var i = izq\n    var j = der\n    var pivote = array[izq]\n    while (i &lt; j) {\n        while (array[i] &lt;= pivote &amp;&amp; i &lt; j) {\n            i++\n        }\n        while (array[j] &gt; pivote) {\n            j--\n        }\n        if (i &lt; j) {\n            val aux = array[i]\n            array[i] = array[j]\n            array[j] = aux\n        }\n    }\n    array[izq] = array[j]\n    array[j] = pivote\n    return j\n}\n\nfun quicksort(array: IntArray, izq: Int, der: Int) {\n    var piv: Int\n    if (izq &lt; der) {\n        piv = pivote(array, izq, der)\n        quicksort(array, izq, piv - 1)\n        quicksort(array, piv + 1, der)\n    }\n}\n</code></pre> <pre><code>import java.util.Arrays;\npublic class Main {\n\n    public static int pivote(int[] array, int izq, int der) {\n        int i = izq;\n        int j = der;\n        int pivote = array[izq];\n        while (i &lt; j) {\n            while (array[i] &lt;= pivote &amp;&amp; i &lt; j) {\n                i++;\n            }\n            while (array[j] &gt; pivote) {\n                j--;\n            }\n            if (i &lt; j) {\n                int aux = array[i];\n                array[i] = array[j];\n                array[j] = aux;\n            }\n        }\n        array[izq] = array[j];\n        array[j] = pivote;\n        return j;\n    }\n\n    public static void quicksort(int[] array, int izq, int der) {\n        int piv;\n        if (izq &lt; der) {\n            piv = pivote(array, izq, der);\n            quicksort(array, izq, piv - 1);\n            quicksort(array, piv + 1, der);\n        }\n    }\n\n    public static void main(String[] args) {\n       int[] vector = {5, 3, 7, 6, 2, 1, 4};\n        quicksort(vector, 0, vector.length - 1);\n        System.out.println(Arrays.toString(vector));\n\n    }\n}\n</code></pre> Python <pre><code>def pivote(array, izq, der):\n    i = izq\n    j = der\n    pivote = array[izq]\n    while i &lt; j:\n        while array[i] &lt;= pivote and i &lt; j:\n            i += 1\n        while array[j] &gt; pivote:\n            j -= 1\n        if i &lt; j:\n            array[i], array[j] = array[j], array[i]\n    array[izq] = array[j]\n    array[j] = pivote\n    return j\n\ndef quicksort(array, izq, der):\n    if izq &lt; der:\n        piv = pivote(array, izq, der)\n        quicksort(array, izq, piv - 1)\n        quicksort(array, piv + 1, der)\n</code></pre>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#6-metodos-de-busqueda","title":"6. M\u00e9todos de b\u00fasqueda","text":"<p>Los m\u00e9todos de b\u00fasqueda nos servir\u00e1n para encontrar un elemento en un array.</p>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#busqueda-secuencial","title":"\ud83d\udd0d B\u00fasqueda secuencial","text":"<p>La b\u00fasqueda secuencial o lineal consiste en recorrer el vector hasta devolver el elemento buscado. Su eficiencia es de O(n).</p> <pre><code>0  1  2  3  4  5  6  7  8  9  10\n| I | N | F | O | R | M | A | T | I | C | A |\n| M | M | M | M | M | M | M | INDICE=5 |\n</code></pre> KotlinJavaPython <pre><code>fun busquedaSecuencial(array: IntArray, elemento: Int): Int {\n    for (i in array.indices) {\n        if (array[i] == elemento) {\n            return i\n        }\n    }\n    return -1\n}\n</code></pre> <pre><code>public static int busquedaSecuencial(int[] array, int elemento) {\n    for (int i = 0; i &lt; array.length; i++) {\n        if (array[i] == elemento) {\n            return i;\n        }\n    }\n    return -1;\n}\n</code></pre> <pre><code>def busqueda_secuencial(array, elemento):\n    for i in range(len(array)):\n        if array[i] == elemento:\n            return i\n    return -1\n</code></pre>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#busqueda-binaria","title":"\ud83d\udd0e B\u00fasqueda binaria","text":"<p>En la b\u00fasqueda binaria partimos de un array ordenado. Su eficiencia es de O(log n). Se compara el dato buscado con el elemento en el centro del vector.</p> <p>Definici\u00f3n de Wikipedia</p> <p>Elemento buscado: 12</p> <pre><code>izq = 1   medio = 4   der = 7\n(=(izq+der)/2)\n\n12 &gt; v[medio] = 4\n\nCogemos el subvector derecho\nizq = 5   medio = 6   der = 7\n(=medio+1)   (=(izq+der)/2)\n\n12 &lt; v[medio] = 13\n\nCogemos el subvector izquierdo\nizq = 5   medio = 5   der = 5\n(=(izq+der)/2)   (=medio-1)\n(antes de modificar medio)\n\n12 = v[medio] = 12\n\nENCONTRADO\n</code></pre> KotlinJavaPython <pre><code>// Versi\u00f3n Iterativa\nfun busquedaBinariaIterativa(array: IntArray, elemento: Int): Int {\n    var centro: Int\n    var inf = 0\n    var sup = array.size - 1\n    while (inf &lt;= sup) {\n        centro = (sup + inf) / 2\n        if (array[centro] == elemento) {\n            return centro\n        } else if (elemento &lt; array[centro]) {\n            sup = centro - 1\n        } else {\n            inf = centro + 1\n        }\n    }\n    return -1\n}\n\n// Versi\u00f3n recursiva\nfun busquedaBinariaRecursiva(array: IntArray, elemento: Int, inf: Int, sup: Int): Int {\n    if (inf &gt; sup) {\n        return -1\n    }\n    val centro = (sup + inf) / 2\n    return if (array[centro] == elemento) {\n        centro\n    } else if (elemento &lt; array[centro]) {\n        busquedaBinariaRecursiva(array, elemento, inf, centro - 1)\n    } else {\n        busquedaBinariaRecursiva(array, elemento, centro + 1, sup)\n    }\n}\n</code></pre> <pre><code>// Versi\u00f3n Iterativa\npublic static int busquedaBinariaIterativa(int[] array, int elemento) {\n    int centro, inf = 0, sup = array.length - 1;\n    while (inf &lt;= sup) {\n        centro = (sup + inf) / 2;\n        if (array[centro] == elemento) {\n            return centro;\n        } else if (elemento &lt; array[centro]) {\n            sup = centro - 1;\n        } else {\n            inf = centro + 1;\n        }\n    }\n    return -1;\n}\n\n// Versi\u00f3n recursiva\npublic static int busquedaBinariaRecursiva(int[] array, int elemento, int inf, int sup) {\n    if (inf &gt; sup) {\n        return -1;\n    }\n    int centro = (sup + inf) / 2;\n    if (array[centro] == elemento) {\n        return centro;\n    } else if (elemento &lt; array[centro]) {\n        return busquedaBinariaRecursiva(array, elemento, inf, centro - 1);\n    } else {\n        return busquedaBinariaRecursiva(array, elemento, centro + 1, sup);\n    }\n}\n</code></pre> <pre><code># Versi\u00f3n Iterativa\ndef busqueda_binaria_iterativa(array, elemento):\n    inf = 0\n    sup = len(array) - 1\n    while inf &lt;= sup:\n        centro = (sup + inf) // 2\n        if array[centro] == elemento:\n            return centro\n        elif elemento &lt; array[centro]:\n            sup = centro - 1\n        else:\n            inf = centro + 1\n    return -1\n\n# Versi\u00f3n recursiva\ndef busqueda_binaria_recursiva(array, elemento, inf, sup):\n    if inf &gt; sup:\n        return -1\n    centro = (sup + inf) // 2\n    if array[centro] == elemento:\n        return centro\n    elif elemento &lt; array[centro]:\n        return busqueda_binaria_recursiva(array, elemento, inf, centro - 1)\n    else:\n        return busqueda_binaria_recursiva(array, elemento, centro + 1, sup)\n</code></pre>"},{"location":"Unidad%203%20Aplicaci%C3%B3n%20de%20las%20estructuras%20de%20almacenamiento/03_Aplicaci%C3%B3n%20de%20Estructuras%20de%20Almacenamiento/#7-nulabilidad","title":"7. Nulabilidad","text":"<p>En determinados lenguajes de programaci\u00f3n existe el concepto de variable nula, es decir, una variable que no tiene valor (no apunta a ninguna zona de memoria o dicha zona no tiene valor).</p> KotlinJavaPython <pre><code>// En Kotlin, todas las variables son no nulas por defecto\nvar numero: Int? = null\n\n// Comprobar nulabilidad\nval nombre: String? = null\nprintln(nombre?.length)  // Safe call\n\n// Operador Elvis\nval longitud = nombre?.length ?: 0\n\n// Operador !! (peligroso)\n// val longitud = nombre!!.length  // Lanza excepci\u00f3n si es null\n\n// Ejemplo pr\u00e1ctico\nvar numero: Int? = null\ndo {\n    print(\"Introduce un n\u00famero: \")\n    numero = readln().toIntOrNull()\n} while (numero == null)\nprintln(\"N\u00famero introducido: $numero\")\n\n// Arrays de componentes nulas\nval array = arrayOfNulls&lt;Int&gt;(10)\nval otro: Array&lt;Int?&gt; = arrayOfNulls(10)\n</code></pre> <pre><code>// En Java, los objetos pueden ser null\nInteger numero = null;\nString nombre = null;\n\n// Comprobar nulabilidad\nif (nombre != null) {\n    System.out.println(nombre.length());\n}\n\n// Operador ternario (similar a Elvis)\nint longitud = (nombre != null) ? nombre.length() : 0;\n\n// Ejemplo pr\u00e1ctico\nInteger numero = null;\nScanner scanner = new Scanner(System.in);\ndo {\n    System.out.print(\"Introduce un n\u00famero: \");\n    try {\n        numero = Integer.parseInt(scanner.nextLine());\n    } catch (NumberFormatException e) {\n        numero = null;\n    }\n} while (numero == null);\nSystem.out.println(\"N\u00famero introducido: \" + numero);\n\n// Arrays de objetos (pueden ser null)\nInteger[] array = new Integer[10];  // Todos null inicialmente\nString[] otro = new String[10];     // Todos null inicialmente\n</code></pre> <pre><code># En Python, None es el equivalente a null\nnumero = None\nnombre = None\n\n# Comprobar nulabilidad\nif nombre is not None:\n    print(len(nombre))\n\n# Operador ternario (similar a Elvis)\nlongitud = len(nombre) if nombre is not None else 0\n\n# Ejemplo pr\u00e1ctico\nnumero = None\nwhile numero is None:\n    try:\n        entrada = input(\"Introduce un n\u00famero: \")\n        numero = int(entrada)\n    except ValueError:\n        numero = None\n        print(\"Por favor, introduce un n\u00famero v\u00e1lido\")\nprint(f\"N\u00famero introducido: {numero}\")\n\n# Listas pueden contener None\narray = [None] * 10\notro = [1, None, 3, None, 5]\n</code></pre>"}]}